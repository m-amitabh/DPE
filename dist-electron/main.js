"use strict";var Wl=Object.defineProperty;var xi=e=>{throw TypeError(e)};var ql=(e,t,n)=>t in e?Wl(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var ct=(e,t,n)=>ql(e,typeof t!="symbol"?t+"":t,n),sr=(e,t,n)=>t.has(e)||xi("Cannot "+n);var v=(e,t,n)=>(sr(e,t,"read from private field"),n?n.call(e):t.get(e)),X=(e,t,n)=>t.has(e)?xi("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),ne=(e,t,n,r)=>(sr(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n),Pt=(e,t,n)=>(sr(e,t,"access private method"),n);const x=require("electron"),gs=require("node:url"),se=require("node:path"),R=require("electron-log"),me=require("fs/promises"),z=require("path"),ms=require("os"),ua=require("util"),Fn=require("stream"),Vl=require("events"),vt=require("fs"),la=require("crypto"),Ut=require("node:child_process"),fa=require("node:string_decoder"),pe=require("node:util"),K=require("node:process"),hn=require("node:tty"),zl=require("child_process"),Ht=require("node:timers/promises"),tt=require("node:os"),Y=require("node:events"),Kl=require("node:v8"),Ce=require("node:fs"),ee=require("node:stream"),ys=require("node:buffer"),Ve=require("node:stream/promises");var ir=typeof document<"u"?document.currentScript:null;function da(e){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const n in e)if(n!=="default"){const r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:()=>e[n]})}}return t.default=e,Object.freeze(t)}const Fe=da(me),ke=da(z);class Yl{constructor(){this.data=null,this.settingsCache=null,this.writeDebounceTimer=null,this.pendingWrites=new Map;const t=x.app.getPath("userData");this.filePath=z.join(t,"projects.json"),this.backupPath=z.join(t,"projects.json.bak"),this.tmpPath=z.join(t,"projects.json.tmp"),this.settingsPath=z.join(t,"settings.json"),R.info(`JSON Store initialized at: ${this.filePath}`)}async getSettings(){if(this.settingsCache)return this.settingsCache;try{const t=await me.readFile(this.settingsPath,"utf-8");return this.settingsCache=JSON.parse(t),this.settingsCache}catch(t){if(t.code==="ENOENT")return this.settingsCache={scanPaths:[],ignoredPatterns:["node_modules",".git","dist"],ideCommand:"code {path}",terminalCommand:""},this.settingsCache;throw t}}async setSettings(t){this.settingsCache=t;const n=JSON.stringify(t,null,2);await me.writeFile(this.settingsPath,n,"utf-8")}async initialize(){try{await this.load()}catch(t){throw R.error("Failed to initialize JSON store:",t),t}}async load(){try{const t=await me.readFile(this.filePath,"utf-8"),n=JSON.parse(t);this.data=this.migrate(n),R.info(`Loaded ${this.data.projects.length} projects`)}catch(t){t.code==="ENOENT"?(R.info("No projects.json found, creating new"),this.data=this.createEmpty(),await this.flush()):(R.warn("Main file corrupt, attempting backup recovery"),await this.loadBackup())}}async loadBackup(){try{const t=await me.readFile(this.backupPath,"utf-8"),n=JSON.parse(t);this.data=this.migrate(n),R.info("Recovered from backup successfully"),await this.flush()}catch{R.error("Both main and backup files failed, starting fresh"),this.data=this.createEmpty(),await this.flush()}}createEmpty(){return{meta:{version:1,lastScanAt:new Date().toISOString(),projectCount:0},projects:[]}}migrate(t){var r,s,i;return(((r=t.meta)==null?void 0:r.version)||0)<1&&(t.projects=(t.projects||[]).map(o=>({...o,scanStatus:o.scanStatus||"complete"})),t.meta={...t.meta||{},version:1}),t.meta={version:1,lastScanAt:((s=t.meta)==null?void 0:s.lastScanAt)||new Date().toISOString(),projectCount:((i=t.projects)==null?void 0:i.length)||0,...t.meta},t}async getAllProjects(){var t;return this.data||await this.load(),[...((t=this.data)==null?void 0:t.projects)||[]]}async getProject(t){var n;return this.data||await this.load(),((n=this.data)==null?void 0:n.projects.find(r=>r.id===t))||null}async upsertProject(t){this.data||await this.load();const n=this.data.projects.findIndex(r=>r.id===t.id);n>=0?this.data.projects[n]=t:this.data.projects.push(t),this.data.meta.projectCount=this.data.projects.length,this.data.meta.lastScanAt=new Date().toISOString(),await this.debouncedWrite()}async updateProject(t,n){this.data||await this.load();const r=this.data.projects.find(s=>s.id===t);return r?(Object.assign(r,n),r.scanStatus="user-modified",await this.debouncedWrite(),r):null}async deleteProject(t){this.data||await this.load();const n=this.data.projects.length;return this.data.projects=this.data.projects.filter(r=>r.id!==t),this.data.projects.length<n?(this.data.meta.projectCount=this.data.projects.length,await this.debouncedWrite(),!0):!1}async clear(){this.data=this.createEmpty(),await this.flush()}async debouncedWrite(){this.writeDebounceTimer&&clearTimeout(this.writeDebounceTimer),this.writeDebounceTimer=setTimeout(()=>{this.flush().catch(t=>{R.error("Failed to flush data:",t)})},500)}async flush(){if(this.data)try{const t=JSON.stringify(this.data,null,2);await me.writeFile(this.tmpPath,t,"utf-8");try{await me.copyFile(this.filePath,this.backupPath)}catch(n){n.code!=="ENOENT"&&R.warn("Failed to create backup:",n)}await me.rename(this.tmpPath,this.filePath),R.info("Data flushed to disk successfully")}catch(t){throw R.error("Failed to flush data to disk:",t),t}}async export(){return this.data||await this.load(),JSON.parse(JSON.stringify(this.data))}async import(t){this.data=this.migrate(t),await this.flush(),R.info("Data imported successfully")}}let or=null;function $t(){return or||(or=new Yl),or}var ha=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Jl(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var re={},q={},St={};Object.defineProperty(St,"__esModule",{value:!0});St.splitWhen=St.flatten=void 0;function Ql(e){return e.reduce((t,n)=>[].concat(t,n),[])}St.flatten=Ql;function Xl(e,t){const n=[[]];let r=0;for(const s of e)t(s)?(r++,n[r]=[]):n[r].push(s);return n}St.splitWhen=Xl;var jn={};Object.defineProperty(jn,"__esModule",{value:!0});jn.isEnoentCodeError=void 0;function Zl(e){return e.code==="ENOENT"}jn.isEnoentCodeError=Zl;var Nn={};Object.defineProperty(Nn,"__esModule",{value:!0});Nn.createDirentFromStats=void 0;let ef=class{constructor(t,n){this.name=t,this.isBlockDevice=n.isBlockDevice.bind(n),this.isCharacterDevice=n.isCharacterDevice.bind(n),this.isDirectory=n.isDirectory.bind(n),this.isFIFO=n.isFIFO.bind(n),this.isFile=n.isFile.bind(n),this.isSocket=n.isSocket.bind(n),this.isSymbolicLink=n.isSymbolicLink.bind(n)}};function tf(e,t){return new ef(e,t)}Nn.createDirentFromStats=tf;var Z={};Object.defineProperty(Z,"__esModule",{value:!0});Z.convertPosixPathToPattern=Z.convertWindowsPathToPattern=Z.convertPathToPattern=Z.escapePosixPath=Z.escapeWindowsPath=Z.escape=Z.removeLeadingDotSegment=Z.makeAbsolute=Z.unixify=void 0;const nf=ms,rf=z,pa=nf.platform()==="win32",sf=2,of=/(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g,af=/(\\?)([()[\]{}]|^!|[!+@](?=\())/g,cf=/^\\\\([.?])/,uf=/\\(?![!()+@[\]{}])/g;function lf(e){return e.replace(/\\/g,"/")}Z.unixify=lf;function ff(e,t){return rf.resolve(e,t)}Z.makeAbsolute=ff;function df(e){if(e.charAt(0)==="."){const t=e.charAt(1);if(t==="/"||t==="\\")return e.slice(sf)}return e}Z.removeLeadingDotSegment=df;Z.escape=pa?Ss:bs;function Ss(e){return e.replace(af,"\\$2")}Z.escapeWindowsPath=Ss;function bs(e){return e.replace(of,"\\$2")}Z.escapePosixPath=bs;Z.convertPathToPattern=pa?ga:ma;function ga(e){return Ss(e).replace(cf,"//$1").replace(uf,"/")}Z.convertWindowsPathToPattern=ga;function ma(e){return bs(e)}Z.convertPosixPathToPattern=ma;var D={};/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */var hf=function(t){if(typeof t!="string"||t==="")return!1;for(var n;n=/(\\).|([@?!+*]\(.*\))/g.exec(t);){if(n[2])return!0;t=t.slice(n.index+n[0].length)}return!1};/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var pf=hf,ya={"{":"}","(":")","[":"]"},gf=function(e){if(e[0]==="!")return!0;for(var t=0,n=-2,r=-2,s=-2,i=-2,o=-2;t<e.length;){if(e[t]==="*"||e[t+1]==="?"&&/[\].+)]/.test(e[t])||r!==-1&&e[t]==="["&&e[t+1]!=="]"&&(r<t&&(r=e.indexOf("]",t)),r>t&&(o===-1||o>r||(o=e.indexOf("\\",t),o===-1||o>r)))||s!==-1&&e[t]==="{"&&e[t+1]!=="}"&&(s=e.indexOf("}",t),s>t&&(o=e.indexOf("\\",t),o===-1||o>s))||i!==-1&&e[t]==="("&&e[t+1]==="?"&&/[:!=]/.test(e[t+2])&&e[t+3]!==")"&&(i=e.indexOf(")",t),i>t&&(o=e.indexOf("\\",t),o===-1||o>i))||n!==-1&&e[t]==="("&&e[t+1]!=="|"&&(n<t&&(n=e.indexOf("|",t)),n!==-1&&e[n+1]!==")"&&(i=e.indexOf(")",n),i>n&&(o=e.indexOf("\\",n),o===-1||o>i))))return!0;if(e[t]==="\\"){var a=e[t+1];t+=2;var c=ya[a];if(c){var l=e.indexOf(c,t);l!==-1&&(t=l+1)}if(e[t]==="!")return!0}else t++}return!1},mf=function(e){if(e[0]==="!")return!0;for(var t=0;t<e.length;){if(/[*?{}()[\]]/.test(e[t]))return!0;if(e[t]==="\\"){var n=e[t+1];t+=2;var r=ya[n];if(r){var s=e.indexOf(r,t);s!==-1&&(t=s+1)}if(e[t]==="!")return!0}else t++}return!1},yf=function(t,n){if(typeof t!="string"||t==="")return!1;if(pf(t))return!0;var r=gf;return n&&n.strict===!1&&(r=mf),r(t)},Sf=yf,bf=z.posix.dirname,wf=ms.platform()==="win32",ar="/",_f=/\\/g,Ef=/[\{\[].*[\}\]]$/,Af=/(^|[^\\])([\{\[]|\([^\)]+$)/,vf=/\\([\!\*\?\|\[\]\(\)\{\}])/g,Rf=function(t,n){var r=Object.assign({flipBackslashes:!0},n);r.flipBackslashes&&wf&&t.indexOf(ar)<0&&(t=t.replace(_f,ar)),Ef.test(t)&&(t+=ar),t+="a";do t=bf(t);while(Sf(t)||Af.test(t));return t.replace(vf,"$1")},Bn={};(function(e){e.isInteger=t=>typeof t=="number"?Number.isInteger(t):typeof t=="string"&&t.trim()!==""?Number.isInteger(Number(t)):!1,e.find=(t,n)=>t.nodes.find(r=>r.type===n),e.exceedsLimit=(t,n,r=1,s)=>s===!1||!e.isInteger(t)||!e.isInteger(n)?!1:(Number(n)-Number(t))/Number(r)>=s,e.escapeNode=(t,n=0,r)=>{const s=t.nodes[n];s&&(r&&s.type===r||s.type==="open"||s.type==="close")&&s.escaped!==!0&&(s.value="\\"+s.value,s.escaped=!0)},e.encloseBrace=t=>t.type!=="brace"||t.commas>>0+t.ranges>>0?!1:(t.invalid=!0,!0),e.isInvalidBrace=t=>t.type!=="brace"?!1:t.invalid===!0||t.dollar?!0:!(t.commas>>0+t.ranges>>0)||t.open!==!0||t.close!==!0?(t.invalid=!0,!0):!1,e.isOpenOrClose=t=>t.type==="open"||t.type==="close"?!0:t.open===!0||t.close===!0,e.reduce=t=>t.reduce((n,r)=>(r.type==="text"&&n.push(r.value),r.type==="range"&&(r.type="text"),n),[]),e.flatten=(...t)=>{const n=[],r=s=>{for(let i=0;i<s.length;i++){const o=s[i];if(Array.isArray(o)){r(o);continue}o!==void 0&&n.push(o)}return n};return r(t),n}})(Bn);const Mi=Bn;var ws=(e,t={})=>{const n=(r,s={})=>{const i=t.escapeInvalid&&Mi.isInvalidBrace(s),o=r.invalid===!0&&t.escapeInvalid===!0;let a="";if(r.value)return(i||o)&&Mi.isOpenOrClose(r)?"\\"+r.value:r.value;if(r.value)return r.value;if(r.nodes)for(const c of r.nodes)a+=n(c);return a};return n(e)};/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */var Tf=function(e){return typeof e=="number"?e-e===0:typeof e=="string"&&e.trim()!==""?Number.isFinite?Number.isFinite(+e):isFinite(+e):!1};/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */const Li=Tf,et=(e,t,n)=>{if(Li(e)===!1)throw new TypeError("toRegexRange: expected the first argument to be a number");if(t===void 0||e===t)return String(e);if(Li(t)===!1)throw new TypeError("toRegexRange: expected the second argument to be a number.");let r={relaxZeros:!0,...n};typeof r.strictZeros=="boolean"&&(r.relaxZeros=r.strictZeros===!1);let s=String(r.relaxZeros),i=String(r.shorthand),o=String(r.capture),a=String(r.wrap),c=e+":"+t+"="+s+i+o+a;if(et.cache.hasOwnProperty(c))return et.cache[c].result;let l=Math.min(e,t),u=Math.max(e,t);if(Math.abs(l-u)===1){let g=e+"|"+t;return r.capture?`(${g})`:r.wrap===!1?g:`(?:${g})`}let f=Ui(e)||Ui(t),d={min:e,max:t,a:l,b:u},p=[],h=[];if(f&&(d.isPadded=f,d.maxLen=String(d.max).length),l<0){let g=u<0?Math.abs(u):1;h=Fi(g,Math.abs(l),d,r),l=d.a=0}return u>=0&&(p=Fi(l,u,d,r)),d.negatives=h,d.positives=p,d.result=Pf(h,p),r.capture===!0?d.result=`(${d.result})`:r.wrap!==!1&&p.length+h.length>1&&(d.result=`(?:${d.result})`),et.cache[c]=d,d.result};function Pf(e,t,n){let r=cr(e,t,"-",!1)||[],s=cr(t,e,"",!1)||[],i=cr(e,t,"-?",!0)||[];return r.concat(i).concat(s).join("|")}function If(e,t){let n=1,r=1,s=Ni(e,n),i=new Set([t]);for(;e<=s&&s<=t;)i.add(s),n+=1,s=Ni(e,n);for(s=Bi(t+1,r)-1;e<s&&s<=t;)i.add(s),r+=1,s=Bi(t+1,r)-1;return i=[...i],i.sort(Cf),i}function Of(e,t,n){if(e===t)return{pattern:e,count:[],digits:0};let r=Df(e,t),s=r.length,i="",o=0;for(let a=0;a<s;a++){let[c,l]=r[a];c===l?i+=c:c!=="0"||l!=="9"?i+=$f(c,l):o++}return o&&(i+=n.shorthand===!0?"\\d":"[0-9]"),{pattern:i,count:[o],digits:s}}function Fi(e,t,n,r){let s=If(e,t),i=[],o=e,a;for(let c=0;c<s.length;c++){let l=s[c],u=Of(String(o),String(l),r),f="";if(!n.isPadded&&a&&a.pattern===u.pattern){a.count.length>1&&a.count.pop(),a.count.push(u.count[0]),a.string=a.pattern+ki(a.count),o=l+1;continue}n.isPadded&&(f=xf(l,n,r)),u.string=f+u.pattern+ki(u.count),i.push(u),o=l+1,a=u}return i}function cr(e,t,n,r,s){let i=[];for(let o of e){let{string:a}=o;!r&&!ji(t,"string",a)&&i.push(n+a),r&&ji(t,"string",a)&&i.push(n+a)}return i}function Df(e,t){let n=[];for(let r=0;r<e.length;r++)n.push([e[r],t[r]]);return n}function Cf(e,t){return e>t?1:t>e?-1:0}function ji(e,t,n){return e.some(r=>r[t]===n)}function Ni(e,t){return Number(String(e).slice(0,-t)+"9".repeat(t))}function Bi(e,t){return e-e%Math.pow(10,t)}function ki(e){let[t=0,n=""]=e;return n||t>1?`{${t+(n?","+n:"")}}`:""}function $f(e,t,n){return`[${e}${t-e===1?"":"-"}${t}]`}function Ui(e){return/^-?(0+)\d/.test(e)}function xf(e,t,n){if(!t.isPadded)return e;let r=Math.abs(t.maxLen-String(e).length),s=n.relaxZeros!==!1;switch(r){case 0:return"";case 1:return s?"0?":"0";case 2:return s?"0{0,2}":"00";default:return s?`0{0,${r}}`:`0{${r}}`}}et.cache={};et.clearCache=()=>et.cache={};var Mf=et;/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */const Lf=ua,Sa=Mf,Hi=e=>e!==null&&typeof e=="object"&&!Array.isArray(e),Ff=e=>t=>e===!0?Number(t):String(t),ur=e=>typeof e=="number"||typeof e=="string"&&e!=="",xt=e=>Number.isInteger(+e),lr=e=>{let t=`${e}`,n=-1;if(t[0]==="-"&&(t=t.slice(1)),t==="0")return!1;for(;t[++n]==="0";);return n>0},jf=(e,t,n)=>typeof e=="string"||typeof t=="string"?!0:n.stringify===!0,Nf=(e,t,n)=>{if(t>0){let r=e[0]==="-"?"-":"";r&&(e=e.slice(1)),e=r+e.padStart(r?t-1:t,"0")}return n===!1?String(e):e},Sn=(e,t)=>{let n=e[0]==="-"?"-":"";for(n&&(e=e.slice(1),t--);e.length<t;)e="0"+e;return n?"-"+e:e},Bf=(e,t,n)=>{e.negatives.sort((a,c)=>a<c?-1:a>c?1:0),e.positives.sort((a,c)=>a<c?-1:a>c?1:0);let r=t.capture?"":"?:",s="",i="",o;return e.positives.length&&(s=e.positives.map(a=>Sn(String(a),n)).join("|")),e.negatives.length&&(i=`-(${r}${e.negatives.map(a=>Sn(String(a),n)).join("|")})`),s&&i?o=`${s}|${i}`:o=s||i,t.wrap?`(${r}${o})`:o},ba=(e,t,n,r)=>{if(n)return Sa(e,t,{wrap:!1,...r});let s=String.fromCharCode(e);if(e===t)return s;let i=String.fromCharCode(t);return`[${s}-${i}]`},wa=(e,t,n)=>{if(Array.isArray(e)){let r=n.wrap===!0,s=n.capture?"":"?:";return r?`(${s}${e.join("|")})`:e.join("|")}return Sa(e,t,n)},_a=(...e)=>new RangeError("Invalid range arguments: "+Lf.inspect(...e)),Ea=(e,t,n)=>{if(n.strictRanges===!0)throw _a([e,t]);return[]},kf=(e,t)=>{if(t.strictRanges===!0)throw new TypeError(`Expected step "${e}" to be a number`);return[]},Uf=(e,t,n=1,r={})=>{let s=Number(e),i=Number(t);if(!Number.isInteger(s)||!Number.isInteger(i)){if(r.strictRanges===!0)throw _a([e,t]);return[]}s===0&&(s=0),i===0&&(i=0);let o=s>i,a=String(e),c=String(t),l=String(n);n=Math.max(Math.abs(n),1);let u=lr(a)||lr(c)||lr(l),f=u?Math.max(a.length,c.length,l.length):0,d=u===!1&&jf(e,t,r)===!1,p=r.transform||Ff(d);if(r.toRegex&&n===1)return ba(Sn(e,f),Sn(t,f),!0,r);let h={negatives:[],positives:[]},g=I=>h[I<0?"negatives":"positives"].push(Math.abs(I)),w=[],_=0;for(;o?s>=i:s<=i;)r.toRegex===!0&&n>1?g(s):w.push(Nf(p(s,_),f,d)),s=o?s-n:s+n,_++;return r.toRegex===!0?n>1?Bf(h,r,f):wa(w,null,{wrap:!1,...r}):w},Hf=(e,t,n=1,r={})=>{if(!xt(e)&&e.length>1||!xt(t)&&t.length>1)return Ea(e,t,r);let s=r.transform||(d=>String.fromCharCode(d)),i=`${e}`.charCodeAt(0),o=`${t}`.charCodeAt(0),a=i>o,c=Math.min(i,o),l=Math.max(i,o);if(r.toRegex&&n===1)return ba(c,l,!1,r);let u=[],f=0;for(;a?i>=o:i<=o;)u.push(s(i,f)),i=a?i-n:i+n,f++;return r.toRegex===!0?wa(u,null,{wrap:!1,options:r}):u},pn=(e,t,n,r={})=>{if(t==null&&ur(e))return[e];if(!ur(e)||!ur(t))return Ea(e,t,r);if(typeof n=="function")return pn(e,t,1,{transform:n});if(Hi(n))return pn(e,t,0,n);let s={...r};return s.capture===!0&&(s.wrap=!0),n=n||s.step||1,xt(n)?xt(e)&&xt(t)?Uf(e,t,n,s):Hf(e,t,Math.max(Math.abs(n),1),s):n!=null&&!Hi(n)?kf(n,s):pn(e,t,1,n)};var Aa=pn;const Gf=Aa,Gi=Bn,Wf=(e,t={})=>{const n=(r,s={})=>{const i=Gi.isInvalidBrace(s),o=r.invalid===!0&&t.escapeInvalid===!0,a=i===!0||o===!0,c=t.escapeInvalid===!0?"\\":"";let l="";if(r.isOpen===!0)return c+r.value;if(r.isClose===!0)return console.log("node.isClose",c,r.value),c+r.value;if(r.type==="open")return a?c+r.value:"(";if(r.type==="close")return a?c+r.value:")";if(r.type==="comma")return r.prev.type==="comma"?"":a?r.value:"|";if(r.value)return r.value;if(r.nodes&&r.ranges>0){const u=Gi.reduce(r.nodes),f=Gf(...u,{...t,wrap:!1,toRegex:!0,strictZeros:!0});if(f.length!==0)return u.length>1&&f.length>1?`(${f})`:f}if(r.nodes)for(const u of r.nodes)l+=n(u,r);return l};return n(e)};var qf=Wf;const Vf=Aa,Wi=ws,ht=Bn,Qe=(e="",t="",n=!1)=>{const r=[];if(e=[].concat(e),t=[].concat(t),!t.length)return e;if(!e.length)return n?ht.flatten(t).map(s=>`{${s}}`):t;for(const s of e)if(Array.isArray(s))for(const i of s)r.push(Qe(i,t,n));else for(let i of t)n===!0&&typeof i=="string"&&(i=`{${i}}`),r.push(Array.isArray(i)?Qe(s,i,n):s+i);return ht.flatten(r)},zf=(e,t={})=>{const n=t.rangeLimit===void 0?1e3:t.rangeLimit,r=(s,i={})=>{s.queue=[];let o=i,a=i.queue;for(;o.type!=="brace"&&o.type!=="root"&&o.parent;)o=o.parent,a=o.queue;if(s.invalid||s.dollar){a.push(Qe(a.pop(),Wi(s,t)));return}if(s.type==="brace"&&s.invalid!==!0&&s.nodes.length===2){a.push(Qe(a.pop(),["{}"]));return}if(s.nodes&&s.ranges>0){const f=ht.reduce(s.nodes);if(ht.exceedsLimit(...f,t.step,n))throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");let d=Vf(...f,t);d.length===0&&(d=Wi(s,t)),a.push(Qe(a.pop(),d)),s.nodes=[];return}const c=ht.encloseBrace(s);let l=s.queue,u=s;for(;u.type!=="brace"&&u.type!=="root"&&u.parent;)u=u.parent,l=u.queue;for(let f=0;f<s.nodes.length;f++){const d=s.nodes[f];if(d.type==="comma"&&s.type==="brace"){f===1&&l.push(""),l.push("");continue}if(d.type==="close"){a.push(Qe(a.pop(),l,c));continue}if(d.value&&d.type!=="open"){l.push(Qe(l.pop(),d.value));continue}d.nodes&&r(d,s)}return l};return ht.flatten(r(e))};var Kf=zf,Yf={MAX_LENGTH:1e4,CHAR_LEFT_PARENTHESES:"(",CHAR_RIGHT_PARENTHESES:")",CHAR_BACKSLASH:"\\",CHAR_BACKTICK:"`",CHAR_COMMA:",",CHAR_DOT:".",CHAR_DOUBLE_QUOTE:'"',CHAR_LEFT_CURLY_BRACE:"{",CHAR_LEFT_SQUARE_BRACKET:"[",CHAR_NO_BREAK_SPACE:"Â ",CHAR_RIGHT_CURLY_BRACE:"}",CHAR_RIGHT_SQUARE_BRACKET:"]",CHAR_SINGLE_QUOTE:"'",CHAR_ZERO_WIDTH_NOBREAK_SPACE:"\uFEFF"};const Jf=ws,{MAX_LENGTH:qi,CHAR_BACKSLASH:fr,CHAR_BACKTICK:Qf,CHAR_COMMA:Xf,CHAR_DOT:Zf,CHAR_LEFT_PARENTHESES:ed,CHAR_RIGHT_PARENTHESES:td,CHAR_LEFT_CURLY_BRACE:nd,CHAR_RIGHT_CURLY_BRACE:rd,CHAR_LEFT_SQUARE_BRACKET:Vi,CHAR_RIGHT_SQUARE_BRACKET:zi,CHAR_DOUBLE_QUOTE:sd,CHAR_SINGLE_QUOTE:id,CHAR_NO_BREAK_SPACE:od,CHAR_ZERO_WIDTH_NOBREAK_SPACE:ad}=Yf,cd=(e,t={})=>{if(typeof e!="string")throw new TypeError("Expected a string");const n=t||{},r=typeof n.maxLength=="number"?Math.min(qi,n.maxLength):qi;if(e.length>r)throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${r})`);const s={type:"root",input:e,nodes:[]},i=[s];let o=s,a=s,c=0;const l=e.length;let u=0,f=0,d;const p=()=>e[u++],h=g=>{if(g.type==="text"&&a.type==="dot"&&(a.type="text"),a&&a.type==="text"&&g.type==="text"){a.value+=g.value;return}return o.nodes.push(g),g.parent=o,g.prev=a,a=g,g};for(h({type:"bos"});u<l;)if(o=i[i.length-1],d=p(),!(d===ad||d===od)){if(d===fr){h({type:"text",value:(t.keepEscaping?d:"")+p()});continue}if(d===zi){h({type:"text",value:"\\"+d});continue}if(d===Vi){c++;let g;for(;u<l&&(g=p());){if(d+=g,g===Vi){c++;continue}if(g===fr){d+=p();continue}if(g===zi&&(c--,c===0))break}h({type:"text",value:d});continue}if(d===ed){o=h({type:"paren",nodes:[]}),i.push(o),h({type:"text",value:d});continue}if(d===td){if(o.type!=="paren"){h({type:"text",value:d});continue}o=i.pop(),h({type:"text",value:d}),o=i[i.length-1];continue}if(d===sd||d===id||d===Qf){const g=d;let w;for(t.keepQuotes!==!0&&(d="");u<l&&(w=p());){if(w===fr){d+=w+p();continue}if(w===g){t.keepQuotes===!0&&(d+=w);break}d+=w}h({type:"text",value:d});continue}if(d===nd){f++;const w={type:"brace",open:!0,close:!1,dollar:a.value&&a.value.slice(-1)==="$"||o.dollar===!0,depth:f,commas:0,ranges:0,nodes:[]};o=h(w),i.push(o),h({type:"open",value:d});continue}if(d===rd){if(o.type!=="brace"){h({type:"text",value:d});continue}const g="close";o=i.pop(),o.close=!0,h({type:g,value:d}),f--,o=i[i.length-1];continue}if(d===Xf&&f>0){if(o.ranges>0){o.ranges=0;const g=o.nodes.shift();o.nodes=[g,{type:"text",value:Jf(o)}]}h({type:"comma",value:d}),o.commas++;continue}if(d===Zf&&f>0&&o.commas===0){const g=o.nodes;if(f===0||g.length===0){h({type:"text",value:d});continue}if(a.type==="dot"){if(o.range=[],a.value+=d,a.type="range",o.nodes.length!==3&&o.nodes.length!==5){o.invalid=!0,o.ranges=0,a.type="text";continue}o.ranges++,o.args=[];continue}if(a.type==="range"){g.pop();const w=g[g.length-1];w.value+=a.value+d,a=w,o.ranges--;continue}h({type:"dot",value:d});continue}h({type:"text",value:d})}do if(o=i.pop(),o.type!=="root"){o.nodes.forEach(_=>{_.nodes||(_.type==="open"&&(_.isOpen=!0),_.type==="close"&&(_.isClose=!0),_.nodes||(_.type="text"),_.invalid=!0)});const g=i[i.length-1],w=g.nodes.indexOf(o);g.nodes.splice(w,1,...o.nodes)}while(i.length>0);return h({type:"eos"}),s};var ud=cd;const Ki=ws,ld=qf,fd=Kf,dd=ud,de=(e,t={})=>{let n=[];if(Array.isArray(e))for(const r of e){const s=de.create(r,t);Array.isArray(s)?n.push(...s):n.push(s)}else n=[].concat(de.create(e,t));return t&&t.expand===!0&&t.nodupes===!0&&(n=[...new Set(n)]),n};de.parse=(e,t={})=>dd(e,t);de.stringify=(e,t={})=>Ki(typeof e=="string"?de.parse(e,t):e,t);de.compile=(e,t={})=>(typeof e=="string"&&(e=de.parse(e,t)),ld(e,t));de.expand=(e,t={})=>{typeof e=="string"&&(e=de.parse(e,t));let n=fd(e,t);return t.noempty===!0&&(n=n.filter(Boolean)),t.nodupes===!0&&(n=[...new Set(n)]),n};de.create=(e,t={})=>e===""||e.length<3?[e]:t.expand!==!0?de.compile(e,t):de.expand(e,t);var hd=de,Gt={};const pd=z,Pe="\\\\/",Yi=`[^${Pe}]`,je="\\.",gd="\\+",md="\\?",kn="\\/",yd="(?=.)",va="[^/]",_s=`(?:${kn}|$)`,Ra=`(?:^|${kn})`,Es=`${je}{1,2}${_s}`,Sd=`(?!${je})`,bd=`(?!${Ra}${Es})`,wd=`(?!${je}{0,1}${_s})`,_d=`(?!${Es})`,Ed=`[^.${kn}]`,Ad=`${va}*?`,Ta={DOT_LITERAL:je,PLUS_LITERAL:gd,QMARK_LITERAL:md,SLASH_LITERAL:kn,ONE_CHAR:yd,QMARK:va,END_ANCHOR:_s,DOTS_SLASH:Es,NO_DOT:Sd,NO_DOTS:bd,NO_DOT_SLASH:wd,NO_DOTS_SLASH:_d,QMARK_NO_DOT:Ed,STAR:Ad,START_ANCHOR:Ra},vd={...Ta,SLASH_LITERAL:`[${Pe}]`,QMARK:Yi,STAR:`${Yi}*?`,DOTS_SLASH:`${je}{1,2}(?:[${Pe}]|$)`,NO_DOT:`(?!${je})`,NO_DOTS:`(?!(?:^|[${Pe}])${je}{1,2}(?:[${Pe}]|$))`,NO_DOT_SLASH:`(?!${je}{0,1}(?:[${Pe}]|$))`,NO_DOTS_SLASH:`(?!${je}{1,2}(?:[${Pe}]|$))`,QMARK_NO_DOT:`[^.${Pe}]`,START_ANCHOR:`(?:^|[${Pe}])`,END_ANCHOR:`(?:[${Pe}]|$)`},Rd={alnum:"a-zA-Z0-9",alpha:"a-zA-Z",ascii:"\\x00-\\x7F",blank:" \\t",cntrl:"\\x00-\\x1F\\x7F",digit:"0-9",graph:"\\x21-\\x7E",lower:"a-z",print:"\\x20-\\x7E ",punct:"\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",space:" \\t\\r\\n\\v\\f",upper:"A-Z",word:"A-Za-z0-9_",xdigit:"A-Fa-f0-9"};var Un={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:Rd,REGEX_BACKSLASH:/\\(?![*+?^${}(|)[\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\].,$*+?^{}()|\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\?)((\W)(\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\[.*?[^\\]\]|\\(?=.))/g,REPLACEMENTS:{"***":"*","**/**":"**","**/**/**":"**"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:pd.sep,extglobChars(e){return{"!":{type:"negate",open:"(?:(?!(?:",close:`))${e.STAR})`},"?":{type:"qmark",open:"(?:",close:")?"},"+":{type:"plus",open:"(?:",close:")+"},"*":{type:"star",open:"(?:",close:")*"},"@":{type:"at",open:"(?:",close:")"}}},globChars(e){return e===!0?vd:Ta}};(function(e){const t=z,n=process.platform==="win32",{REGEX_BACKSLASH:r,REGEX_REMOVE_BACKSLASH:s,REGEX_SPECIAL_CHARS:i,REGEX_SPECIAL_CHARS_GLOBAL:o}=Un;e.isObject=a=>a!==null&&typeof a=="object"&&!Array.isArray(a),e.hasRegexChars=a=>i.test(a),e.isRegexChar=a=>a.length===1&&e.hasRegexChars(a),e.escapeRegex=a=>a.replace(o,"\\$1"),e.toPosixSlashes=a=>a.replace(r,"/"),e.removeBackslashes=a=>a.replace(s,c=>c==="\\"?"":c),e.supportsLookbehinds=()=>{const a=process.version.slice(1).split(".").map(Number);return a.length===3&&a[0]>=9||a[0]===8&&a[1]>=10},e.isWindows=a=>a&&typeof a.windows=="boolean"?a.windows:n===!0||t.sep==="\\",e.escapeLast=(a,c,l)=>{const u=a.lastIndexOf(c,l);return u===-1?a:a[u-1]==="\\"?e.escapeLast(a,c,u-1):`${a.slice(0,u)}\\${a.slice(u)}`},e.removePrefix=(a,c={})=>{let l=a;return l.startsWith("./")&&(l=l.slice(2),c.prefix="./"),l},e.wrapOutput=(a,c={},l={})=>{const u=l.contains?"":"^",f=l.contains?"":"$";let d=`${u}(?:${a})${f}`;return c.negated===!0&&(d=`(?:^(?!${d}).*$)`),d}})(Gt);const Ji=Gt,{CHAR_ASTERISK:dr,CHAR_AT:Td,CHAR_BACKWARD_SLASH:Dt,CHAR_COMMA:Pd,CHAR_DOT:hr,CHAR_EXCLAMATION_MARK:pr,CHAR_FORWARD_SLASH:Pa,CHAR_LEFT_CURLY_BRACE:gr,CHAR_LEFT_PARENTHESES:mr,CHAR_LEFT_SQUARE_BRACKET:Id,CHAR_PLUS:Od,CHAR_QUESTION_MARK:Qi,CHAR_RIGHT_CURLY_BRACE:Dd,CHAR_RIGHT_PARENTHESES:Xi,CHAR_RIGHT_SQUARE_BRACKET:Cd}=Un,Zi=e=>e===Pa||e===Dt,eo=e=>{e.isPrefix!==!0&&(e.depth=e.isGlobstar?1/0:1)},$d=(e,t)=>{const n=t||{},r=e.length-1,s=n.parts===!0||n.scanToEnd===!0,i=[],o=[],a=[];let c=e,l=-1,u=0,f=0,d=!1,p=!1,h=!1,g=!1,w=!1,_=!1,I=!1,$=!1,F=!1,B=!1,T=0,P,b,O={value:"",depth:0,isGlob:!1};const k=()=>l>=r,S=()=>c.charCodeAt(l+1),N=()=>(P=b,c.charCodeAt(++l));for(;l<r;){b=N();let ie;if(b===Dt){I=O.backslashes=!0,b=N(),b===gr&&(_=!0);continue}if(_===!0||b===gr){for(T++;k()!==!0&&(b=N());){if(b===Dt){I=O.backslashes=!0,N();continue}if(b===gr){T++;continue}if(_!==!0&&b===hr&&(b=N())===hr){if(d=O.isBrace=!0,h=O.isGlob=!0,B=!0,s===!0)continue;break}if(_!==!0&&b===Pd){if(d=O.isBrace=!0,h=O.isGlob=!0,B=!0,s===!0)continue;break}if(b===Dd&&(T--,T===0)){_=!1,d=O.isBrace=!0,B=!0;break}}if(s===!0)continue;break}if(b===Pa){if(i.push(l),o.push(O),O={value:"",depth:0,isGlob:!1},B===!0)continue;if(P===hr&&l===u+1){u+=2;continue}f=l+1;continue}if(n.noext!==!0&&(b===Od||b===Td||b===dr||b===Qi||b===pr)===!0&&S()===mr){if(h=O.isGlob=!0,g=O.isExtglob=!0,B=!0,b===pr&&l===u&&(F=!0),s===!0){for(;k()!==!0&&(b=N());){if(b===Dt){I=O.backslashes=!0,b=N();continue}if(b===Xi){h=O.isGlob=!0,B=!0;break}}continue}break}if(b===dr){if(P===dr&&(w=O.isGlobstar=!0),h=O.isGlob=!0,B=!0,s===!0)continue;break}if(b===Qi){if(h=O.isGlob=!0,B=!0,s===!0)continue;break}if(b===Id){for(;k()!==!0&&(ie=N());){if(ie===Dt){I=O.backslashes=!0,N();continue}if(ie===Cd){p=O.isBracket=!0,h=O.isGlob=!0,B=!0;break}}if(s===!0)continue;break}if(n.nonegate!==!0&&b===pr&&l===u){$=O.negated=!0,u++;continue}if(n.noparen!==!0&&b===mr){if(h=O.isGlob=!0,s===!0){for(;k()!==!0&&(b=N());){if(b===mr){I=O.backslashes=!0,b=N();continue}if(b===Xi){B=!0;break}}continue}break}if(h===!0){if(B=!0,s===!0)continue;break}}n.noext===!0&&(g=!1,h=!1);let U=c,Q="",m="";u>0&&(Q=c.slice(0,u),c=c.slice(u),f-=u),U&&h===!0&&f>0?(U=c.slice(0,f),m=c.slice(f)):h===!0?(U="",m=c):U=c,U&&U!==""&&U!=="/"&&U!==c&&Zi(U.charCodeAt(U.length-1))&&(U=U.slice(0,-1)),n.unescape===!0&&(m&&(m=Ji.removeBackslashes(m)),U&&I===!0&&(U=Ji.removeBackslashes(U)));const y={prefix:Q,input:e,start:u,base:U,glob:m,isBrace:d,isBracket:p,isGlob:h,isExtglob:g,isGlobstar:w,negated:$,negatedExtglob:F};if(n.tokens===!0&&(y.maxDepth=0,Zi(b)||o.push(O),y.tokens=o),n.parts===!0||n.tokens===!0){let ie;for(let j=0;j<i.length;j++){const Re=ie?ie+1:u,Te=i[j],ce=e.slice(Re,Te);n.tokens&&(j===0&&u!==0?(o[j].isPrefix=!0,o[j].value=Q):o[j].value=ce,eo(o[j]),y.maxDepth+=o[j].depth),(j!==0||ce!=="")&&a.push(ce),ie=Te}if(ie&&ie+1<e.length){const j=e.slice(ie+1);a.push(j),n.tokens&&(o[o.length-1].value=j,eo(o[o.length-1]),y.maxDepth+=o[o.length-1].depth)}y.slashes=i,y.parts=a}return y};var xd=$d;const bn=Un,ue=Gt,{MAX_LENGTH:wn,POSIX_REGEX_SOURCE:Md,REGEX_NON_SPECIAL_CHARS:Ld,REGEX_SPECIAL_CHARS_BACKREF:Fd,REPLACEMENTS:Ia}=bn,jd=(e,t)=>{if(typeof t.expandRange=="function")return t.expandRange(...e,t);e.sort();const n=`[${e.join("-")}]`;try{new RegExp(n)}catch{return e.map(s=>ue.escapeRegex(s)).join("..")}return n},ut=(e,t)=>`Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`,As=(e,t)=>{if(typeof e!="string")throw new TypeError("Expected a string");e=Ia[e]||e;const n={...t},r=typeof n.maxLength=="number"?Math.min(wn,n.maxLength):wn;let s=e.length;if(s>r)throw new SyntaxError(`Input length: ${s}, exceeds maximum allowed length: ${r}`);const i={type:"bos",value:"",output:n.prepend||""},o=[i],a=n.capture?"":"?:",c=ue.isWindows(t),l=bn.globChars(c),u=bn.extglobChars(l),{DOT_LITERAL:f,PLUS_LITERAL:d,SLASH_LITERAL:p,ONE_CHAR:h,DOTS_SLASH:g,NO_DOT:w,NO_DOT_SLASH:_,NO_DOTS_SLASH:I,QMARK:$,QMARK_NO_DOT:F,STAR:B,START_ANCHOR:T}=l,P=A=>`(${a}(?:(?!${T}${A.dot?g:f}).)*?)`,b=n.dot?"":w,O=n.dot?$:F;let k=n.bash===!0?P(n):B;n.capture&&(k=`(${k})`),typeof n.noext=="boolean"&&(n.noextglob=n.noext);const S={input:e,index:-1,start:0,dot:n.dot===!0,consumed:"",output:"",prefix:"",backtrack:!1,negated:!1,brackets:0,braces:0,parens:0,quotes:0,globstar:!1,tokens:o};e=ue.removePrefix(e,S),s=e.length;const N=[],U=[],Q=[];let m=i,y;const ie=()=>S.index===s-1,j=S.peek=(A=1)=>e[S.index+A],Re=S.advance=()=>e[++S.index]||"",Te=()=>e.slice(S.index+1),ce=(A="",H=0)=>{S.consumed+=A,S.index+=H},Zt=A=>{S.output+=A.output!=null?A.output:A.value,ce(A.value)},Hl=()=>{let A=1;for(;j()==="!"&&(j(2)!=="("||j(3)==="?");)Re(),S.start++,A++;return A%2===0?!1:(S.negated=!0,S.start++,!0)},en=A=>{S[A]++,Q.push(A)},Ye=A=>{S[A]--,Q.pop()},L=A=>{if(m.type==="globstar"){const H=S.braces>0&&(A.type==="comma"||A.type==="brace"),E=A.extglob===!0||N.length&&(A.type==="pipe"||A.type==="paren");A.type!=="slash"&&A.type!=="paren"&&!H&&!E&&(S.output=S.output.slice(0,-m.output.length),m.type="star",m.value="*",m.output=k,S.output+=m.output)}if(N.length&&A.type!=="paren"&&(N[N.length-1].inner+=A.value),(A.value||A.output)&&Zt(A),m&&m.type==="text"&&A.type==="text"){m.value+=A.value,m.output=(m.output||"")+A.value;return}A.prev=m,o.push(A),m=A},tn=(A,H)=>{const E={...u[H],conditions:1,inner:""};E.prev=m,E.parens=S.parens,E.output=S.output;const M=(n.capture?"(":"")+E.open;en("parens"),L({type:A,value:H,output:S.output?"":h}),L({type:"paren",extglob:!0,value:Re(),output:M}),N.push(E)},Gl=A=>{let H=A.close+(n.capture?")":""),E;if(A.type==="negate"){let M=k;if(A.inner&&A.inner.length>1&&A.inner.includes("/")&&(M=P(n)),(M!==k||ie()||/^\)+$/.test(Te()))&&(H=A.close=`)$))${M}`),A.inner.includes("*")&&(E=Te())&&/^\.[^\\/.]+$/.test(E)){const W=As(E,{...t,fastpaths:!1}).output;H=A.close=`)${W})${M})`}A.prev.type==="bos"&&(S.negatedExtglob=!0)}L({type:"paren",extglob:!0,value:y,output:H}),Ye("parens")};if(n.fastpaths!==!1&&!/(^[*!]|[/()[\]{}"])/.test(e)){let A=!1,H=e.replace(Fd,(E,M,W,oe,te,rr)=>oe==="\\"?(A=!0,E):oe==="?"?M?M+oe+(te?$.repeat(te.length):""):rr===0?O+(te?$.repeat(te.length):""):$.repeat(W.length):oe==="."?f.repeat(W.length):oe==="*"?M?M+oe+(te?k:""):k:M?E:`\\${E}`);return A===!0&&(n.unescape===!0?H=H.replace(/\\/g,""):H=H.replace(/\\+/g,E=>E.length%2===0?"\\\\":E?"\\":"")),H===e&&n.contains===!0?(S.output=e,S):(S.output=ue.wrapOutput(H,S,t),S)}for(;!ie();){if(y=Re(),y==="\0")continue;if(y==="\\"){const E=j();if(E==="/"&&n.bash!==!0||E==="."||E===";")continue;if(!E){y+="\\",L({type:"text",value:y});continue}const M=/^\\+/.exec(Te());let W=0;if(M&&M[0].length>2&&(W=M[0].length,S.index+=W,W%2!==0&&(y+="\\")),n.unescape===!0?y=Re():y+=Re(),S.brackets===0){L({type:"text",value:y});continue}}if(S.brackets>0&&(y!=="]"||m.value==="["||m.value==="[^")){if(n.posix!==!1&&y===":"){const E=m.value.slice(1);if(E.includes("[")&&(m.posix=!0,E.includes(":"))){const M=m.value.lastIndexOf("["),W=m.value.slice(0,M),oe=m.value.slice(M+2),te=Md[oe];if(te){m.value=W+te,S.backtrack=!0,Re(),!i.output&&o.indexOf(m)===1&&(i.output=h);continue}}}(y==="["&&j()!==":"||y==="-"&&j()==="]")&&(y=`\\${y}`),y==="]"&&(m.value==="["||m.value==="[^")&&(y=`\\${y}`),n.posix===!0&&y==="!"&&m.value==="["&&(y="^"),m.value+=y,Zt({value:y});continue}if(S.quotes===1&&y!=='"'){y=ue.escapeRegex(y),m.value+=y,Zt({value:y});continue}if(y==='"'){S.quotes=S.quotes===1?0:1,n.keepQuotes===!0&&L({type:"text",value:y});continue}if(y==="("){en("parens"),L({type:"paren",value:y});continue}if(y===")"){if(S.parens===0&&n.strictBrackets===!0)throw new SyntaxError(ut("opening","("));const E=N[N.length-1];if(E&&S.parens===E.parens+1){Gl(N.pop());continue}L({type:"paren",value:y,output:S.parens?")":"\\)"}),Ye("parens");continue}if(y==="["){if(n.nobracket===!0||!Te().includes("]")){if(n.nobracket!==!0&&n.strictBrackets===!0)throw new SyntaxError(ut("closing","]"));y=`\\${y}`}else en("brackets");L({type:"bracket",value:y});continue}if(y==="]"){if(n.nobracket===!0||m&&m.type==="bracket"&&m.value.length===1){L({type:"text",value:y,output:`\\${y}`});continue}if(S.brackets===0){if(n.strictBrackets===!0)throw new SyntaxError(ut("opening","["));L({type:"text",value:y,output:`\\${y}`});continue}Ye("brackets");const E=m.value.slice(1);if(m.posix!==!0&&E[0]==="^"&&!E.includes("/")&&(y=`/${y}`),m.value+=y,Zt({value:y}),n.literalBrackets===!1||ue.hasRegexChars(E))continue;const M=ue.escapeRegex(m.value);if(S.output=S.output.slice(0,-m.value.length),n.literalBrackets===!0){S.output+=M,m.value=M;continue}m.value=`(${a}${M}|${m.value})`,S.output+=m.value;continue}if(y==="{"&&n.nobrace!==!0){en("braces");const E={type:"brace",value:y,output:"(",outputIndex:S.output.length,tokensIndex:S.tokens.length};U.push(E),L(E);continue}if(y==="}"){const E=U[U.length-1];if(n.nobrace===!0||!E){L({type:"text",value:y,output:y});continue}let M=")";if(E.dots===!0){const W=o.slice(),oe=[];for(let te=W.length-1;te>=0&&(o.pop(),W[te].type!=="brace");te--)W[te].type!=="dots"&&oe.unshift(W[te].value);M=jd(oe,n),S.backtrack=!0}if(E.comma!==!0&&E.dots!==!0){const W=S.output.slice(0,E.outputIndex),oe=S.tokens.slice(E.tokensIndex);E.value=E.output="\\{",y=M="\\}",S.output=W;for(const te of oe)S.output+=te.output||te.value}L({type:"brace",value:y,output:M}),Ye("braces"),U.pop();continue}if(y==="|"){N.length>0&&N[N.length-1].conditions++,L({type:"text",value:y});continue}if(y===","){let E=y;const M=U[U.length-1];M&&Q[Q.length-1]==="braces"&&(M.comma=!0,E="|"),L({type:"comma",value:y,output:E});continue}if(y==="/"){if(m.type==="dot"&&S.index===S.start+1){S.start=S.index+1,S.consumed="",S.output="",o.pop(),m=i;continue}L({type:"slash",value:y,output:p});continue}if(y==="."){if(S.braces>0&&m.type==="dot"){m.value==="."&&(m.output=f);const E=U[U.length-1];m.type="dots",m.output+=y,m.value+=y,E.dots=!0;continue}if(S.braces+S.parens===0&&m.type!=="bos"&&m.type!=="slash"){L({type:"text",value:y,output:f});continue}L({type:"dot",value:y,output:f});continue}if(y==="?"){if(!(m&&m.value==="(")&&n.noextglob!==!0&&j()==="("&&j(2)!=="?"){tn("qmark",y);continue}if(m&&m.type==="paren"){const M=j();let W=y;if(M==="<"&&!ue.supportsLookbehinds())throw new Error("Node.js v10 or higher is required for regex lookbehinds");(m.value==="("&&!/[!=<:]/.test(M)||M==="<"&&!/<([!=]|\w+>)/.test(Te()))&&(W=`\\${y}`),L({type:"text",value:y,output:W});continue}if(n.dot!==!0&&(m.type==="slash"||m.type==="bos")){L({type:"qmark",value:y,output:F});continue}L({type:"qmark",value:y,output:$});continue}if(y==="!"){if(n.noextglob!==!0&&j()==="("&&(j(2)!=="?"||!/[!=<:]/.test(j(3)))){tn("negate",y);continue}if(n.nonegate!==!0&&S.index===0){Hl();continue}}if(y==="+"){if(n.noextglob!==!0&&j()==="("&&j(2)!=="?"){tn("plus",y);continue}if(m&&m.value==="("||n.regex===!1){L({type:"plus",value:y,output:d});continue}if(m&&(m.type==="bracket"||m.type==="paren"||m.type==="brace")||S.parens>0){L({type:"plus",value:y});continue}L({type:"plus",value:d});continue}if(y==="@"){if(n.noextglob!==!0&&j()==="("&&j(2)!=="?"){L({type:"at",extglob:!0,value:y,output:""});continue}L({type:"text",value:y});continue}if(y!=="*"){(y==="$"||y==="^")&&(y=`\\${y}`);const E=Ld.exec(Te());E&&(y+=E[0],S.index+=E[0].length),L({type:"text",value:y});continue}if(m&&(m.type==="globstar"||m.star===!0)){m.type="star",m.star=!0,m.value+=y,m.output=k,S.backtrack=!0,S.globstar=!0,ce(y);continue}let A=Te();if(n.noextglob!==!0&&/^\([^?]/.test(A)){tn("star",y);continue}if(m.type==="star"){if(n.noglobstar===!0){ce(y);continue}const E=m.prev,M=E.prev,W=E.type==="slash"||E.type==="bos",oe=M&&(M.type==="star"||M.type==="globstar");if(n.bash===!0&&(!W||A[0]&&A[0]!=="/")){L({type:"star",value:y,output:""});continue}const te=S.braces>0&&(E.type==="comma"||E.type==="brace"),rr=N.length&&(E.type==="pipe"||E.type==="paren");if(!W&&E.type!=="paren"&&!te&&!rr){L({type:"star",value:y,output:""});continue}for(;A.slice(0,3)==="/**";){const nn=e[S.index+4];if(nn&&nn!=="/")break;A=A.slice(3),ce("/**",3)}if(E.type==="bos"&&ie()){m.type="globstar",m.value+=y,m.output=P(n),S.output=m.output,S.globstar=!0,ce(y);continue}if(E.type==="slash"&&E.prev.type!=="bos"&&!oe&&ie()){S.output=S.output.slice(0,-(E.output+m.output).length),E.output=`(?:${E.output}`,m.type="globstar",m.output=P(n)+(n.strictSlashes?")":"|$)"),m.value+=y,S.globstar=!0,S.output+=E.output+m.output,ce(y);continue}if(E.type==="slash"&&E.prev.type!=="bos"&&A[0]==="/"){const nn=A[1]!==void 0?"|$":"";S.output=S.output.slice(0,-(E.output+m.output).length),E.output=`(?:${E.output}`,m.type="globstar",m.output=`${P(n)}${p}|${p}${nn})`,m.value+=y,S.output+=E.output+m.output,S.globstar=!0,ce(y+Re()),L({type:"slash",value:"/",output:""});continue}if(E.type==="bos"&&A[0]==="/"){m.type="globstar",m.value+=y,m.output=`(?:^|${p}|${P(n)}${p})`,S.output=m.output,S.globstar=!0,ce(y+Re()),L({type:"slash",value:"/",output:""});continue}S.output=S.output.slice(0,-m.output.length),m.type="globstar",m.output=P(n),m.value+=y,S.output+=m.output,S.globstar=!0,ce(y);continue}const H={type:"star",value:y,output:k};if(n.bash===!0){H.output=".*?",(m.type==="bos"||m.type==="slash")&&(H.output=b+H.output),L(H);continue}if(m&&(m.type==="bracket"||m.type==="paren")&&n.regex===!0){H.output=y,L(H);continue}(S.index===S.start||m.type==="slash"||m.type==="dot")&&(m.type==="dot"?(S.output+=_,m.output+=_):n.dot===!0?(S.output+=I,m.output+=I):(S.output+=b,m.output+=b),j()!=="*"&&(S.output+=h,m.output+=h)),L(H)}for(;S.brackets>0;){if(n.strictBrackets===!0)throw new SyntaxError(ut("closing","]"));S.output=ue.escapeLast(S.output,"["),Ye("brackets")}for(;S.parens>0;){if(n.strictBrackets===!0)throw new SyntaxError(ut("closing",")"));S.output=ue.escapeLast(S.output,"("),Ye("parens")}for(;S.braces>0;){if(n.strictBrackets===!0)throw new SyntaxError(ut("closing","}"));S.output=ue.escapeLast(S.output,"{"),Ye("braces")}if(n.strictSlashes!==!0&&(m.type==="star"||m.type==="bracket")&&L({type:"maybe_slash",value:"",output:`${p}?`}),S.backtrack===!0){S.output="";for(const A of S.tokens)S.output+=A.output!=null?A.output:A.value,A.suffix&&(S.output+=A.suffix)}return S};As.fastpaths=(e,t)=>{const n={...t},r=typeof n.maxLength=="number"?Math.min(wn,n.maxLength):wn,s=e.length;if(s>r)throw new SyntaxError(`Input length: ${s}, exceeds maximum allowed length: ${r}`);e=Ia[e]||e;const i=ue.isWindows(t),{DOT_LITERAL:o,SLASH_LITERAL:a,ONE_CHAR:c,DOTS_SLASH:l,NO_DOT:u,NO_DOTS:f,NO_DOTS_SLASH:d,STAR:p,START_ANCHOR:h}=bn.globChars(i),g=n.dot?f:u,w=n.dot?d:u,_=n.capture?"":"?:",I={negated:!1,prefix:""};let $=n.bash===!0?".*?":p;n.capture&&($=`(${$})`);const F=b=>b.noglobstar===!0?$:`(${_}(?:(?!${h}${b.dot?l:o}).)*?)`,B=b=>{switch(b){case"*":return`${g}${c}${$}`;case".*":return`${o}${c}${$}`;case"*.*":return`${g}${$}${o}${c}${$}`;case"*/*":return`${g}${$}${a}${c}${w}${$}`;case"**":return g+F(n);case"**/*":return`(?:${g}${F(n)}${a})?${w}${c}${$}`;case"**/*.*":return`(?:${g}${F(n)}${a})?${w}${$}${o}${c}${$}`;case"**/.*":return`(?:${g}${F(n)}${a})?${o}${c}${$}`;default:{const O=/^(.*?)\.(\w+)$/.exec(b);if(!O)return;const k=B(O[1]);return k?k+o+O[2]:void 0}}},T=ue.removePrefix(e,I);let P=B(T);return P&&n.strictSlashes!==!0&&(P+=`${a}?`),P};var Nd=As;const Bd=z,kd=xd,Dr=Nd,vs=Gt,Ud=Un,Hd=e=>e&&typeof e=="object"&&!Array.isArray(e),J=(e,t,n=!1)=>{if(Array.isArray(e)){const u=e.map(d=>J(d,t,n));return d=>{for(const p of u){const h=p(d);if(h)return h}return!1}}const r=Hd(e)&&e.tokens&&e.input;if(e===""||typeof e!="string"&&!r)throw new TypeError("Expected pattern to be a non-empty string");const s=t||{},i=vs.isWindows(t),o=r?J.compileRe(e,t):J.makeRe(e,t,!1,!0),a=o.state;delete o.state;let c=()=>!1;if(s.ignore){const u={...t,ignore:null,onMatch:null,onResult:null};c=J(s.ignore,u,n)}const l=(u,f=!1)=>{const{isMatch:d,match:p,output:h}=J.test(u,o,t,{glob:e,posix:i}),g={glob:e,state:a,regex:o,posix:i,input:u,output:h,match:p,isMatch:d};return typeof s.onResult=="function"&&s.onResult(g),d===!1?(g.isMatch=!1,f?g:!1):c(u)?(typeof s.onIgnore=="function"&&s.onIgnore(g),g.isMatch=!1,f?g:!1):(typeof s.onMatch=="function"&&s.onMatch(g),f?g:!0)};return n&&(l.state=a),l};J.test=(e,t,n,{glob:r,posix:s}={})=>{if(typeof e!="string")throw new TypeError("Expected input to be a string");if(e==="")return{isMatch:!1,output:""};const i=n||{},o=i.format||(s?vs.toPosixSlashes:null);let a=e===r,c=a&&o?o(e):e;return a===!1&&(c=o?o(e):e,a=c===r),(a===!1||i.capture===!0)&&(i.matchBase===!0||i.basename===!0?a=J.matchBase(e,t,n,s):a=t.exec(c)),{isMatch:!!a,match:a,output:c}};J.matchBase=(e,t,n,r=vs.isWindows(n))=>(t instanceof RegExp?t:J.makeRe(t,n)).test(Bd.basename(e));J.isMatch=(e,t,n)=>J(t,n)(e);J.parse=(e,t)=>Array.isArray(e)?e.map(n=>J.parse(n,t)):Dr(e,{...t,fastpaths:!1});J.scan=(e,t)=>kd(e,t);J.compileRe=(e,t,n=!1,r=!1)=>{if(n===!0)return e.output;const s=t||{},i=s.contains?"":"^",o=s.contains?"":"$";let a=`${i}(?:${e.output})${o}`;e&&e.negated===!0&&(a=`^(?!${a}).*$`);const c=J.toRegex(a,t);return r===!0&&(c.state=e),c};J.makeRe=(e,t={},n=!1,r=!1)=>{if(!e||typeof e!="string")throw new TypeError("Expected a non-empty string");let s={negated:!1,fastpaths:!0};return t.fastpaths!==!1&&(e[0]==="."||e[0]==="*")&&(s.output=Dr.fastpaths(e,t)),s.output||(s=Dr(e,t)),J.compileRe(s,t,n,r)};J.toRegex=(e,t)=>{try{const n=t||{};return new RegExp(e,n.flags||(n.nocase?"i":""))}catch(n){if(t&&t.debug===!0)throw n;return/$^/}};J.constants=Ud;var Gd=J,Wd=Gd;const Oa=ua,Da=hd,Le=Wd,Cr=Gt,to=e=>e===""||e==="./",Ca=e=>{const t=e.indexOf("{");return t>-1&&e.indexOf("}",t)>-1},G=(e,t,n)=>{t=[].concat(t),e=[].concat(e);let r=new Set,s=new Set,i=new Set,o=0,a=u=>{i.add(u.output),n&&n.onResult&&n.onResult(u)};for(let u=0;u<t.length;u++){let f=Le(String(t[u]),{...n,onResult:a},!0),d=f.state.negated||f.state.negatedExtglob;d&&o++;for(let p of e){let h=f(p,!0);(d?!h.isMatch:h.isMatch)&&(d?r.add(h.output):(r.delete(h.output),s.add(h.output)))}}let l=(o===t.length?[...i]:[...s]).filter(u=>!r.has(u));if(n&&l.length===0){if(n.failglob===!0)throw new Error(`No matches found for "${t.join(", ")}"`);if(n.nonull===!0||n.nullglob===!0)return n.unescape?t.map(u=>u.replace(/\\/g,"")):t}return l};G.match=G;G.matcher=(e,t)=>Le(e,t);G.isMatch=(e,t,n)=>Le(t,n)(e);G.any=G.isMatch;G.not=(e,t,n={})=>{t=[].concat(t).map(String);let r=new Set,s=[],i=a=>{n.onResult&&n.onResult(a),s.push(a.output)},o=new Set(G(e,t,{...n,onResult:i}));for(let a of s)o.has(a)||r.add(a);return[...r]};G.contains=(e,t,n)=>{if(typeof e!="string")throw new TypeError(`Expected a string: "${Oa.inspect(e)}"`);if(Array.isArray(t))return t.some(r=>G.contains(e,r,n));if(typeof t=="string"){if(to(e)||to(t))return!1;if(e.includes(t)||e.startsWith("./")&&e.slice(2).includes(t))return!0}return G.isMatch(e,t,{...n,contains:!0})};G.matchKeys=(e,t,n)=>{if(!Cr.isObject(e))throw new TypeError("Expected the first argument to be an object");let r=G(Object.keys(e),t,n),s={};for(let i of r)s[i]=e[i];return s};G.some=(e,t,n)=>{let r=[].concat(e);for(let s of[].concat(t)){let i=Le(String(s),n);if(r.some(o=>i(o)))return!0}return!1};G.every=(e,t,n)=>{let r=[].concat(e);for(let s of[].concat(t)){let i=Le(String(s),n);if(!r.every(o=>i(o)))return!1}return!0};G.all=(e,t,n)=>{if(typeof e!="string")throw new TypeError(`Expected a string: "${Oa.inspect(e)}"`);return[].concat(t).every(r=>Le(r,n)(e))};G.capture=(e,t,n)=>{let r=Cr.isWindows(n),i=Le.makeRe(String(e),{...n,capture:!0}).exec(r?Cr.toPosixSlashes(t):t);if(i)return i.slice(1).map(o=>o===void 0?"":o)};G.makeRe=(...e)=>Le.makeRe(...e);G.scan=(...e)=>Le.scan(...e);G.parse=(e,t)=>{let n=[];for(let r of[].concat(e||[]))for(let s of Da(String(r),t))n.push(Le.parse(s,t));return n};G.braces=(e,t)=>{if(typeof e!="string")throw new TypeError("Expected a string");return t&&t.nobrace===!0||!Ca(e)?[e]:Da(e,t)};G.braceExpand=(e,t)=>{if(typeof e!="string")throw new TypeError("Expected a string");return G.braces(e,{...t,expand:!0})};G.hasBraces=Ca;var qd=G;Object.defineProperty(D,"__esModule",{value:!0});D.isAbsolute=D.partitionAbsoluteAndRelative=D.removeDuplicateSlashes=D.matchAny=D.convertPatternsToRe=D.makeRe=D.getPatternParts=D.expandBraceExpansion=D.expandPatternsWithBraceExpansion=D.isAffectDepthOfReadingPattern=D.endsWithSlashGlobStar=D.hasGlobStar=D.getBaseDirectory=D.isPatternRelatedToParentDirectory=D.getPatternsOutsideCurrentDirectory=D.getPatternsInsideCurrentDirectory=D.getPositivePatterns=D.getNegativePatterns=D.isPositivePattern=D.isNegativePattern=D.convertToNegativePattern=D.convertToPositivePattern=D.isDynamicPattern=D.isStaticPattern=void 0;const $a=z,Vd=Rf,Rs=qd,xa="**",zd="\\",Kd=/[*?]|^!/,Yd=/\[[^[]*]/,Jd=/(?:^|[^!*+?@])\([^(]*\|[^|]*\)/,Qd=/[!*+?@]\([^(]*\)/,Xd=/,|\.\./,Zd=/(?!^)\/{2,}/g;function Ma(e,t={}){return!La(e,t)}D.isStaticPattern=Ma;function La(e,t={}){return e===""?!1:!!(t.caseSensitiveMatch===!1||e.includes(zd)||Kd.test(e)||Yd.test(e)||Jd.test(e)||t.extglob!==!1&&Qd.test(e)||t.braceExpansion!==!1&&eh(e))}D.isDynamicPattern=La;function eh(e){const t=e.indexOf("{");if(t===-1)return!1;const n=e.indexOf("}",t+1);if(n===-1)return!1;const r=e.slice(t,n);return Xd.test(r)}function th(e){return Hn(e)?e.slice(1):e}D.convertToPositivePattern=th;function nh(e){return"!"+e}D.convertToNegativePattern=nh;function Hn(e){return e.startsWith("!")&&e[1]!=="("}D.isNegativePattern=Hn;function Fa(e){return!Hn(e)}D.isPositivePattern=Fa;function rh(e){return e.filter(Hn)}D.getNegativePatterns=rh;function sh(e){return e.filter(Fa)}D.getPositivePatterns=sh;function ih(e){return e.filter(t=>!Ts(t))}D.getPatternsInsideCurrentDirectory=ih;function oh(e){return e.filter(Ts)}D.getPatternsOutsideCurrentDirectory=oh;function Ts(e){return e.startsWith("..")||e.startsWith("./..")}D.isPatternRelatedToParentDirectory=Ts;function ah(e){return Vd(e,{flipBackslashes:!1})}D.getBaseDirectory=ah;function ch(e){return e.includes(xa)}D.hasGlobStar=ch;function ja(e){return e.endsWith("/"+xa)}D.endsWithSlashGlobStar=ja;function uh(e){const t=$a.basename(e);return ja(e)||Ma(t)}D.isAffectDepthOfReadingPattern=uh;function lh(e){return e.reduce((t,n)=>t.concat(Na(n)),[])}D.expandPatternsWithBraceExpansion=lh;function Na(e){const t=Rs.braces(e,{expand:!0,nodupes:!0,keepEscaping:!0});return t.sort((n,r)=>n.length-r.length),t.filter(n=>n!=="")}D.expandBraceExpansion=Na;function fh(e,t){let{parts:n}=Rs.scan(e,Object.assign(Object.assign({},t),{parts:!0}));return n.length===0&&(n=[e]),n[0].startsWith("/")&&(n[0]=n[0].slice(1),n.unshift("")),n}D.getPatternParts=fh;function Ba(e,t){return Rs.makeRe(e,t)}D.makeRe=Ba;function dh(e,t){return e.map(n=>Ba(n,t))}D.convertPatternsToRe=dh;function hh(e,t){return t.some(n=>n.test(e))}D.matchAny=hh;function ph(e){return e.replace(Zd,"/")}D.removeDuplicateSlashes=ph;function gh(e){const t=[],n=[];for(const r of e)ka(r)?t.push(r):n.push(r);return[t,n]}D.partitionAbsoluteAndRelative=gh;function ka(e){return $a.isAbsolute(e)}D.isAbsolute=ka;var Gn={};const mh=Fn,Ua=mh.PassThrough,yh=Array.prototype.slice;var Sh=bh;function bh(){const e=[],t=yh.call(arguments);let n=!1,r=t[t.length-1];r&&!Array.isArray(r)&&r.pipe==null?t.pop():r={};const s=r.end!==!1,i=r.pipeError===!0;r.objectMode==null&&(r.objectMode=!0),r.highWaterMark==null&&(r.highWaterMark=64*1024);const o=Ua(r);function a(){for(let u=0,f=arguments.length;u<f;u++)e.push(Ha(arguments[u],r));return c(),this}function c(){if(n)return;n=!0;let u=e.shift();if(!u){process.nextTick(l);return}Array.isArray(u)||(u=[u]);let f=u.length+1;function d(){--f>0||(n=!1,c())}function p(h){function g(){h.removeListener("merge2UnpipeEnd",g),h.removeListener("end",g),i&&h.removeListener("error",w),d()}function w(_){o.emit("error",_)}if(h._readableState.endEmitted)return d();h.on("merge2UnpipeEnd",g),h.on("end",g),i&&h.on("error",w),h.pipe(o,{end:!1}),h.resume()}for(let h=0;h<u.length;h++)p(u[h]);d()}function l(){n=!1,o.emit("queueDrain"),s&&o.end()}return o.setMaxListeners(0),o.add=a,o.on("unpipe",function(u){u.emit("merge2UnpipeEnd")}),t.length&&a.apply(null,t),o}function Ha(e,t){if(Array.isArray(e))for(let n=0,r=e.length;n<r;n++)e[n]=Ha(e[n],t);else{if(!e._readableState&&e.pipe&&(e=e.pipe(Ua(t))),!e._readableState||!e.pause||!e.pipe)throw new Error("Only readable stream can be merged.");e.pause()}return e}Object.defineProperty(Gn,"__esModule",{value:!0});Gn.merge=void 0;const wh=Sh;function _h(e){const t=wh(e);return e.forEach(n=>{n.once("error",r=>t.emit("error",r))}),t.once("close",()=>no(e)),t.once("end",()=>no(e)),t}Gn.merge=_h;function no(e){e.forEach(t=>t.emit("close"))}var bt={};Object.defineProperty(bt,"__esModule",{value:!0});bt.isEmpty=bt.isString=void 0;function Eh(e){return typeof e=="string"}bt.isString=Eh;function Ah(e){return e===""}bt.isEmpty=Ah;Object.defineProperty(q,"__esModule",{value:!0});q.string=q.stream=q.pattern=q.path=q.fs=q.errno=q.array=void 0;const vh=St;q.array=vh;const Rh=jn;q.errno=Rh;const Th=Nn;q.fs=Th;const Ph=Z;q.path=Ph;const Ih=D;q.pattern=Ih;const Oh=Gn;q.stream=Oh;const Dh=bt;q.string=Dh;Object.defineProperty(re,"__esModule",{value:!0});re.convertPatternGroupToTask=re.convertPatternGroupsToTasks=re.groupPatternsByBaseDirectory=re.getNegativePatternsAsPositive=re.getPositivePatterns=re.convertPatternsToTasks=re.generate=void 0;const Ae=q;function Ch(e,t){const n=ro(e,t),r=ro(t.ignore,t),s=Ga(n),i=Wa(n,r),o=s.filter(u=>Ae.pattern.isStaticPattern(u,t)),a=s.filter(u=>Ae.pattern.isDynamicPattern(u,t)),c=$r(o,i,!1),l=$r(a,i,!0);return c.concat(l)}re.generate=Ch;function ro(e,t){let n=e;return t.braceExpansion&&(n=Ae.pattern.expandPatternsWithBraceExpansion(n)),t.baseNameMatch&&(n=n.map(r=>r.includes("/")?r:`**/${r}`)),n.map(r=>Ae.pattern.removeDuplicateSlashes(r))}function $r(e,t,n){const r=[],s=Ae.pattern.getPatternsOutsideCurrentDirectory(e),i=Ae.pattern.getPatternsInsideCurrentDirectory(e),o=xr(s),a=xr(i);return r.push(...Mr(o,t,n)),"."in a?r.push(Ps(".",i,t,n)):r.push(...Mr(a,t,n)),r}re.convertPatternsToTasks=$r;function Ga(e){return Ae.pattern.getPositivePatterns(e)}re.getPositivePatterns=Ga;function Wa(e,t){return Ae.pattern.getNegativePatterns(e).concat(t).map(Ae.pattern.convertToPositivePattern)}re.getNegativePatternsAsPositive=Wa;function xr(e){const t={};return e.reduce((n,r)=>{const s=Ae.pattern.getBaseDirectory(r);return s in n?n[s].push(r):n[s]=[r],n},t)}re.groupPatternsByBaseDirectory=xr;function Mr(e,t,n){return Object.keys(e).map(r=>Ps(r,e[r],t,n))}re.convertPatternGroupsToTasks=Mr;function Ps(e,t,n,r){return{dynamic:r,positive:t,negative:n,base:e,patterns:[].concat(t,n.map(Ae.pattern.convertToNegativePattern))}}re.convertPatternGroupToTask=Ps;var Is={},Os={},ye={},Ds={},Wn={},xe={},We={},he={},qn={};Object.defineProperty(qn,"__esModule",{value:!0});qn.read=void 0;function $h(e,t,n){t.fs.lstat(e,(r,s)=>{if(r!==null){so(n,r);return}if(!s.isSymbolicLink()||!t.followSymbolicLink){yr(n,s);return}t.fs.stat(e,(i,o)=>{if(i!==null){if(t.throwErrorOnBrokenSymbolicLink){so(n,i);return}yr(n,s);return}t.markSymbolicLink&&(o.isSymbolicLink=()=>!0),yr(n,o)})})}qn.read=$h;function so(e,t){e(t)}function yr(e,t){e(null,t)}var Vn={};Object.defineProperty(Vn,"__esModule",{value:!0});Vn.read=void 0;function xh(e,t){const n=t.fs.lstatSync(e);if(!n.isSymbolicLink()||!t.followSymbolicLink)return n;try{const r=t.fs.statSync(e);return t.markSymbolicLink&&(r.isSymbolicLink=()=>!0),r}catch(r){if(!t.throwErrorOnBrokenSymbolicLink)return n;throw r}}Vn.read=xh;var Cs={},qa={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.createFileSystemAdapter=e.FILE_SYSTEM_ADAPTER=void 0;const t=vt;e.FILE_SYSTEM_ADAPTER={lstat:t.lstat,stat:t.stat,lstatSync:t.lstatSync,statSync:t.statSync};function n(r){return r===void 0?e.FILE_SYSTEM_ADAPTER:Object.assign(Object.assign({},e.FILE_SYSTEM_ADAPTER),r)}e.createFileSystemAdapter=n})(qa);Object.defineProperty(Cs,"__esModule",{value:!0});const Mh=qa;let Lh=class{constructor(t={}){this._options=t,this.followSymbolicLink=this._getValue(this._options.followSymbolicLink,!0),this.fs=Mh.createFileSystemAdapter(this._options.fs),this.markSymbolicLink=this._getValue(this._options.markSymbolicLink,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!0)}_getValue(t,n){return t??n}};Cs.default=Lh;Object.defineProperty(he,"__esModule",{value:!0});he.statSync=he.stat=he.Settings=void 0;const io=qn,Fh=Vn,Lr=Cs;he.Settings=Lr.default;function jh(e,t,n){if(typeof t=="function"){io.read(e,Fr(),t);return}io.read(e,Fr(t),n)}he.stat=jh;function Nh(e,t){const n=Fr(t);return Fh.read(e,n)}he.statSync=Nh;function Fr(e={}){return e instanceof Lr.default?e:new Lr.default(e)}/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */let oo;var Bh=typeof queueMicrotask=="function"?queueMicrotask.bind(typeof window<"u"?window:ha):e=>(oo||(oo=Promise.resolve())).then(e).catch(t=>setTimeout(()=>{throw t},0));/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var kh=Hh;const Uh=Bh;function Hh(e,t){let n,r,s,i=!0;Array.isArray(e)?(n=[],r=e.length):(s=Object.keys(e),n={},r=s.length);function o(c){function l(){t&&t(c,n),t=null}i?Uh(l):l()}function a(c,l,u){n[c]=u,(--r===0||l)&&o(l)}r?s?s.forEach(function(c){e[c](function(l,u){a(c,l,u)})}):e.forEach(function(c,l){c(function(u,f){a(l,u,f)})}):o(null),i=!1}var Wt={};Object.defineProperty(Wt,"__esModule",{value:!0});Wt.IS_SUPPORT_READDIR_WITH_FILE_TYPES=void 0;const _n=process.versions.node.split(".");if(_n[0]===void 0||_n[1]===void 0)throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);const Va=Number.parseInt(_n[0],10),Gh=Number.parseInt(_n[1],10),za=10,Wh=10,qh=Va>za,Vh=Va===za&&Gh>=Wh;Wt.IS_SUPPORT_READDIR_WITH_FILE_TYPES=qh||Vh;var qt={},zn={};Object.defineProperty(zn,"__esModule",{value:!0});zn.createDirentFromStats=void 0;class zh{constructor(t,n){this.name=t,this.isBlockDevice=n.isBlockDevice.bind(n),this.isCharacterDevice=n.isCharacterDevice.bind(n),this.isDirectory=n.isDirectory.bind(n),this.isFIFO=n.isFIFO.bind(n),this.isFile=n.isFile.bind(n),this.isSocket=n.isSocket.bind(n),this.isSymbolicLink=n.isSymbolicLink.bind(n)}}function Kh(e,t){return new zh(e,t)}zn.createDirentFromStats=Kh;Object.defineProperty(qt,"__esModule",{value:!0});qt.fs=void 0;const Yh=zn;qt.fs=Yh;var Vt={};Object.defineProperty(Vt,"__esModule",{value:!0});Vt.joinPathSegments=void 0;function Jh(e,t,n){return e.endsWith(n)?e+t:e+n+t}Vt.joinPathSegments=Jh;Object.defineProperty(We,"__esModule",{value:!0});We.readdir=We.readdirWithFileTypes=We.read=void 0;const Qh=he,Ka=kh,Xh=Wt,Ya=qt,Ja=Vt;function Zh(e,t,n){if(!t.stats&&Xh.IS_SUPPORT_READDIR_WITH_FILE_TYPES){Qa(e,t,n);return}Xa(e,t,n)}We.read=Zh;function Qa(e,t,n){t.fs.readdir(e,{withFileTypes:!0},(r,s)=>{if(r!==null){En(n,r);return}const i=s.map(a=>({dirent:a,name:a.name,path:Ja.joinPathSegments(e,a.name,t.pathSegmentSeparator)}));if(!t.followSymbolicLinks){jr(n,i);return}const o=i.map(a=>ep(a,t));Ka(o,(a,c)=>{if(a!==null){En(n,a);return}jr(n,c)})})}We.readdirWithFileTypes=Qa;function ep(e,t){return n=>{if(!e.dirent.isSymbolicLink()){n(null,e);return}t.fs.stat(e.path,(r,s)=>{if(r!==null){if(t.throwErrorOnBrokenSymbolicLink){n(r);return}n(null,e);return}e.dirent=Ya.fs.createDirentFromStats(e.name,s),n(null,e)})}}function Xa(e,t,n){t.fs.readdir(e,(r,s)=>{if(r!==null){En(n,r);return}const i=s.map(o=>{const a=Ja.joinPathSegments(e,o,t.pathSegmentSeparator);return c=>{Qh.stat(a,t.fsStatSettings,(l,u)=>{if(l!==null){c(l);return}const f={name:o,path:a,dirent:Ya.fs.createDirentFromStats(o,u)};t.stats&&(f.stats=u),c(null,f)})}});Ka(i,(o,a)=>{if(o!==null){En(n,o);return}jr(n,a)})})}We.readdir=Xa;function En(e,t){e(t)}function jr(e,t){e(null,t)}var qe={};Object.defineProperty(qe,"__esModule",{value:!0});qe.readdir=qe.readdirWithFileTypes=qe.read=void 0;const tp=he,np=Wt,Za=qt,ec=Vt;function rp(e,t){return!t.stats&&np.IS_SUPPORT_READDIR_WITH_FILE_TYPES?tc(e,t):nc(e,t)}qe.read=rp;function tc(e,t){return t.fs.readdirSync(e,{withFileTypes:!0}).map(r=>{const s={dirent:r,name:r.name,path:ec.joinPathSegments(e,r.name,t.pathSegmentSeparator)};if(s.dirent.isSymbolicLink()&&t.followSymbolicLinks)try{const i=t.fs.statSync(s.path);s.dirent=Za.fs.createDirentFromStats(s.name,i)}catch(i){if(t.throwErrorOnBrokenSymbolicLink)throw i}return s})}qe.readdirWithFileTypes=tc;function nc(e,t){return t.fs.readdirSync(e).map(r=>{const s=ec.joinPathSegments(e,r,t.pathSegmentSeparator),i=tp.statSync(s,t.fsStatSettings),o={name:r,path:s,dirent:Za.fs.createDirentFromStats(r,i)};return t.stats&&(o.stats=i),o})}qe.readdir=nc;var $s={},rc={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.createFileSystemAdapter=e.FILE_SYSTEM_ADAPTER=void 0;const t=vt;e.FILE_SYSTEM_ADAPTER={lstat:t.lstat,stat:t.stat,lstatSync:t.lstatSync,statSync:t.statSync,readdir:t.readdir,readdirSync:t.readdirSync};function n(r){return r===void 0?e.FILE_SYSTEM_ADAPTER:Object.assign(Object.assign({},e.FILE_SYSTEM_ADAPTER),r)}e.createFileSystemAdapter=n})(rc);Object.defineProperty($s,"__esModule",{value:!0});const sp=z,ip=he,op=rc;let ap=class{constructor(t={}){this._options=t,this.followSymbolicLinks=this._getValue(this._options.followSymbolicLinks,!1),this.fs=op.createFileSystemAdapter(this._options.fs),this.pathSegmentSeparator=this._getValue(this._options.pathSegmentSeparator,sp.sep),this.stats=this._getValue(this._options.stats,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!0),this.fsStatSettings=new ip.Settings({followSymbolicLink:this.followSymbolicLinks,fs:this.fs,throwErrorOnBrokenSymbolicLink:this.throwErrorOnBrokenSymbolicLink})}_getValue(t,n){return t??n}};$s.default=ap;Object.defineProperty(xe,"__esModule",{value:!0});xe.Settings=xe.scandirSync=xe.scandir=void 0;const ao=We,cp=qe,Nr=$s;xe.Settings=Nr.default;function up(e,t,n){if(typeof t=="function"){ao.read(e,Br(),t);return}ao.read(e,Br(t),n)}xe.scandir=up;function lp(e,t){const n=Br(t);return cp.read(e,n)}xe.scandirSync=lp;function Br(e={}){return e instanceof Nr.default?e:new Nr.default(e)}var xs={exports:{}};function fp(e){var t=new e,n=t;function r(){var i=t;return i.next?t=i.next:(t=new e,n=t),i.next=null,i}function s(i){n.next=i,n=i}return{get:r,release:s}}var dp=fp,hp=dp;function sc(e,t,n){if(typeof e=="function"&&(n=t,t=e,e=null),!(n>=1))throw new Error("fastqueue concurrency must be equal to or greater than 1");var r=hp(pp),s=null,i=null,o=0,a=null,c={push:g,drain:ae,saturated:ae,pause:u,paused:!1,get concurrency(){return n},set concurrency(T){if(!(T>=1))throw new Error("fastqueue concurrency must be equal to or greater than 1");if(n=T,!c.paused)for(;s&&o<n;)o++,_()},running:l,resume:p,idle:h,length:f,getQueue:d,unshift:w,empty:ae,kill:I,killAndDrain:$,error:B,abort:F};return c;function l(){return o}function u(){c.paused=!0}function f(){for(var T=s,P=0;T;)T=T.next,P++;return P}function d(){for(var T=s,P=[];T;)P.push(T.value),T=T.next;return P}function p(){if(c.paused){if(c.paused=!1,s===null){o++,_();return}for(;s&&o<n;)o++,_()}}function h(){return o===0&&c.length()===0}function g(T,P){var b=r.get();b.context=e,b.release=_,b.value=T,b.callback=P||ae,b.errorHandler=a,o>=n||c.paused?i?(i.next=b,i=b):(s=b,i=b,c.saturated()):(o++,t.call(e,b.value,b.worked))}function w(T,P){var b=r.get();b.context=e,b.release=_,b.value=T,b.callback=P||ae,b.errorHandler=a,o>=n||c.paused?s?(b.next=s,s=b):(s=b,i=b,c.saturated()):(o++,t.call(e,b.value,b.worked))}function _(T){T&&r.release(T);var P=s;P&&o<=n?c.paused?o--:(i===s&&(i=null),s=P.next,P.next=null,t.call(e,P.value,P.worked),i===null&&c.empty()):--o===0&&c.drain()}function I(){s=null,i=null,c.drain=ae}function $(){s=null,i=null,c.drain(),c.drain=ae}function F(){var T=s;for(s=null,i=null;T;){var P=T.next,b=T.callback,O=T.errorHandler,k=T.value,S=T.context;T.value=null,T.callback=ae,T.errorHandler=null,O&&O(new Error("abort"),k),b.call(S,new Error("abort")),T.release(T),T=P}c.drain=ae}function B(T){a=T}}function ae(){}function pp(){this.value=null,this.callback=ae,this.next=null,this.release=ae,this.context=null,this.errorHandler=null;var e=this;this.worked=function(n,r){var s=e.callback,i=e.errorHandler,o=e.value;e.value=null,e.callback=ae,e.errorHandler&&i(n,o),s.call(e.context,n,r),e.release(e)}}function gp(e,t,n){typeof e=="function"&&(n=t,t=e,e=null);function r(u,f){t.call(this,u).then(function(d){f(null,d)},f)}var s=sc(e,r,n),i=s.push,o=s.unshift;return s.push=a,s.unshift=c,s.drained=l,s;function a(u){var f=new Promise(function(d,p){i(u,function(h,g){if(h){p(h);return}d(g)})});return f.catch(ae),f}function c(u){var f=new Promise(function(d,p){o(u,function(h,g){if(h){p(h);return}d(g)})});return f.catch(ae),f}function l(){var u=new Promise(function(f){process.nextTick(function(){if(s.idle())f();else{var d=s.drain;s.drain=function(){typeof d=="function"&&d(),f(),s.drain=d}}})});return u}}xs.exports=sc;xs.exports.promise=gp;var mp=xs.exports,Se={};Object.defineProperty(Se,"__esModule",{value:!0});Se.joinPathSegments=Se.replacePathSegmentSeparator=Se.isAppliedFilter=Se.isFatalError=void 0;function yp(e,t){return e.errorFilter===null?!0:!e.errorFilter(t)}Se.isFatalError=yp;function Sp(e,t){return e===null||e(t)}Se.isAppliedFilter=Sp;function bp(e,t){return e.split(/[/\\]/).join(t)}Se.replacePathSegmentSeparator=bp;function wp(e,t,n){return e===""?t:e.endsWith(n)?e+t:e+n+t}Se.joinPathSegments=wp;var Kn={};Object.defineProperty(Kn,"__esModule",{value:!0});const _p=Se;let Ep=class{constructor(t,n){this._root=t,this._settings=n,this._root=_p.replacePathSegmentSeparator(t,n.pathSegmentSeparator)}};Kn.default=Ep;Object.defineProperty(Wn,"__esModule",{value:!0});const Ap=Vl,vp=xe,Rp=mp,rn=Se,Tp=Kn;class Pp extends Tp.default{constructor(t,n){super(t,n),this._settings=n,this._scandir=vp.scandir,this._emitter=new Ap.EventEmitter,this._queue=Rp(this._worker.bind(this),this._settings.concurrency),this._isFatalError=!1,this._isDestroyed=!1,this._queue.drain=()=>{this._isFatalError||this._emitter.emit("end")}}read(){return this._isFatalError=!1,this._isDestroyed=!1,setImmediate(()=>{this._pushToQueue(this._root,this._settings.basePath)}),this._emitter}get isDestroyed(){return this._isDestroyed}destroy(){if(this._isDestroyed)throw new Error("The reader is already destroyed");this._isDestroyed=!0,this._queue.killAndDrain()}onEntry(t){this._emitter.on("entry",t)}onError(t){this._emitter.once("error",t)}onEnd(t){this._emitter.once("end",t)}_pushToQueue(t,n){const r={directory:t,base:n};this._queue.push(r,s=>{s!==null&&this._handleError(s)})}_worker(t,n){this._scandir(t.directory,this._settings.fsScandirSettings,(r,s)=>{if(r!==null){n(r,void 0);return}for(const i of s)this._handleEntry(i,t.base);n(null,void 0)})}_handleError(t){this._isDestroyed||!rn.isFatalError(this._settings,t)||(this._isFatalError=!0,this._isDestroyed=!0,this._emitter.emit("error",t))}_handleEntry(t,n){if(this._isDestroyed||this._isFatalError)return;const r=t.path;n!==void 0&&(t.path=rn.joinPathSegments(n,t.name,this._settings.pathSegmentSeparator)),rn.isAppliedFilter(this._settings.entryFilter,t)&&this._emitEntry(t),t.dirent.isDirectory()&&rn.isAppliedFilter(this._settings.deepFilter,t)&&this._pushToQueue(r,n===void 0?void 0:t.path)}_emitEntry(t){this._emitter.emit("entry",t)}}Wn.default=Pp;Object.defineProperty(Ds,"__esModule",{value:!0});const Ip=Wn;class Op{constructor(t,n){this._root=t,this._settings=n,this._reader=new Ip.default(this._root,this._settings),this._storage=[]}read(t){this._reader.onError(n=>{Dp(t,n)}),this._reader.onEntry(n=>{this._storage.push(n)}),this._reader.onEnd(()=>{Cp(t,this._storage)}),this._reader.read()}}Ds.default=Op;function Dp(e,t){e(t)}function Cp(e,t){e(null,t)}var Ms={};Object.defineProperty(Ms,"__esModule",{value:!0});const $p=Fn,xp=Wn;class Mp{constructor(t,n){this._root=t,this._settings=n,this._reader=new xp.default(this._root,this._settings),this._stream=new $p.Readable({objectMode:!0,read:()=>{},destroy:()=>{this._reader.isDestroyed||this._reader.destroy()}})}read(){return this._reader.onError(t=>{this._stream.emit("error",t)}),this._reader.onEntry(t=>{this._stream.push(t)}),this._reader.onEnd(()=>{this._stream.push(null)}),this._reader.read(),this._stream}}Ms.default=Mp;var Ls={},Fs={};Object.defineProperty(Fs,"__esModule",{value:!0});const Lp=xe,sn=Se,Fp=Kn;class jp extends Fp.default{constructor(){super(...arguments),this._scandir=Lp.scandirSync,this._storage=[],this._queue=new Set}read(){return this._pushToQueue(this._root,this._settings.basePath),this._handleQueue(),this._storage}_pushToQueue(t,n){this._queue.add({directory:t,base:n})}_handleQueue(){for(const t of this._queue.values())this._handleDirectory(t.directory,t.base)}_handleDirectory(t,n){try{const r=this._scandir(t,this._settings.fsScandirSettings);for(const s of r)this._handleEntry(s,n)}catch(r){this._handleError(r)}}_handleError(t){if(sn.isFatalError(this._settings,t))throw t}_handleEntry(t,n){const r=t.path;n!==void 0&&(t.path=sn.joinPathSegments(n,t.name,this._settings.pathSegmentSeparator)),sn.isAppliedFilter(this._settings.entryFilter,t)&&this._pushToStorage(t),t.dirent.isDirectory()&&sn.isAppliedFilter(this._settings.deepFilter,t)&&this._pushToQueue(r,n===void 0?void 0:t.path)}_pushToStorage(t){this._storage.push(t)}}Fs.default=jp;Object.defineProperty(Ls,"__esModule",{value:!0});const Np=Fs;class Bp{constructor(t,n){this._root=t,this._settings=n,this._reader=new Np.default(this._root,this._settings)}read(){return this._reader.read()}}Ls.default=Bp;var js={};Object.defineProperty(js,"__esModule",{value:!0});const kp=z,Up=xe;class Hp{constructor(t={}){this._options=t,this.basePath=this._getValue(this._options.basePath,void 0),this.concurrency=this._getValue(this._options.concurrency,Number.POSITIVE_INFINITY),this.deepFilter=this._getValue(this._options.deepFilter,null),this.entryFilter=this._getValue(this._options.entryFilter,null),this.errorFilter=this._getValue(this._options.errorFilter,null),this.pathSegmentSeparator=this._getValue(this._options.pathSegmentSeparator,kp.sep),this.fsScandirSettings=new Up.Settings({followSymbolicLinks:this._options.followSymbolicLinks,fs:this._options.fs,pathSegmentSeparator:this._options.pathSegmentSeparator,stats:this._options.stats,throwErrorOnBrokenSymbolicLink:this._options.throwErrorOnBrokenSymbolicLink})}_getValue(t,n){return t??n}}js.default=Hp;Object.defineProperty(ye,"__esModule",{value:!0});ye.Settings=ye.walkStream=ye.walkSync=ye.walk=void 0;const co=Ds,Gp=Ms,Wp=Ls,kr=js;ye.Settings=kr.default;function qp(e,t,n){if(typeof t=="function"){new co.default(e,An()).read(t);return}new co.default(e,An(t)).read(n)}ye.walk=qp;function Vp(e,t){const n=An(t);return new Wp.default(e,n).read()}ye.walkSync=Vp;function zp(e,t){const n=An(t);return new Gp.default(e,n).read()}ye.walkStream=zp;function An(e={}){return e instanceof kr.default?e:new kr.default(e)}var zt={};Object.defineProperty(zt,"__esModule",{value:!0});const Kp=z,Yp=he,uo=q;class Jp{constructor(t){this._settings=t,this._fsStatSettings=new Yp.Settings({followSymbolicLink:this._settings.followSymbolicLinks,fs:this._settings.fs,throwErrorOnBrokenSymbolicLink:this._settings.followSymbolicLinks})}_getFullEntryPath(t){return Kp.resolve(this._settings.cwd,t)}_makeEntry(t,n){const r={name:n,path:n,dirent:uo.fs.createDirentFromStats(n,t)};return this._settings.stats&&(r.stats=t),r}_isFatalError(t){return!uo.errno.isEnoentCodeError(t)&&!this._settings.suppressErrors}}zt.default=Jp;var Yn={};Object.defineProperty(Yn,"__esModule",{value:!0});const Qp=Fn,Xp=he,Zp=ye,eg=zt;class tg extends eg.default{constructor(){super(...arguments),this._walkStream=Zp.walkStream,this._stat=Xp.stat}dynamic(t,n){return this._walkStream(t,n)}static(t,n){const r=t.map(this._getFullEntryPath,this),s=new Qp.PassThrough({objectMode:!0});s._write=(i,o,a)=>this._getEntry(r[i],t[i],n).then(c=>{c!==null&&n.entryFilter(c)&&s.push(c),i===r.length-1&&s.end(),a()}).catch(a);for(let i=0;i<r.length;i++)s.write(i);return s}_getEntry(t,n,r){return this._getStat(t).then(s=>this._makeEntry(s,n)).catch(s=>{if(r.errorFilter(s))return null;throw s})}_getStat(t){return new Promise((n,r)=>{this._stat(t,this._fsStatSettings,(s,i)=>s===null?n(i):r(s))})}}Yn.default=tg;Object.defineProperty(Os,"__esModule",{value:!0});const ng=ye,rg=zt,sg=Yn;class ig extends rg.default{constructor(){super(...arguments),this._walkAsync=ng.walk,this._readerStream=new sg.default(this._settings)}dynamic(t,n){return new Promise((r,s)=>{this._walkAsync(t,n,(i,o)=>{i===null?r(o):s(i)})})}async static(t,n){const r=[],s=this._readerStream.static(t,n);return new Promise((i,o)=>{s.once("error",o),s.on("data",a=>r.push(a)),s.once("end",()=>i(r))})}}Os.default=ig;var Kt={},Ns={},Bs={},ks={};Object.defineProperty(ks,"__esModule",{value:!0});const It=q;class og{constructor(t,n,r){this._patterns=t,this._settings=n,this._micromatchOptions=r,this._storage=[],this._fillStorage()}_fillStorage(){for(const t of this._patterns){const n=this._getPatternSegments(t),r=this._splitSegmentsIntoSections(n);this._storage.push({complete:r.length<=1,pattern:t,segments:n,sections:r})}}_getPatternSegments(t){return It.pattern.getPatternParts(t,this._micromatchOptions).map(r=>It.pattern.isDynamicPattern(r,this._settings)?{dynamic:!0,pattern:r,patternRe:It.pattern.makeRe(r,this._micromatchOptions)}:{dynamic:!1,pattern:r})}_splitSegmentsIntoSections(t){return It.array.splitWhen(t,n=>n.dynamic&&It.pattern.hasGlobStar(n.pattern))}}ks.default=og;Object.defineProperty(Bs,"__esModule",{value:!0});const ag=ks;class cg extends ag.default{match(t){const n=t.split("/"),r=n.length,s=this._storage.filter(i=>!i.complete||i.segments.length>r);for(const i of s){const o=i.sections[0];if(!i.complete&&r>o.length||n.every((c,l)=>{const u=i.segments[l];return!!(u.dynamic&&u.patternRe.test(c)||!u.dynamic&&u.pattern===c)}))return!0}return!1}}Bs.default=cg;Object.defineProperty(Ns,"__esModule",{value:!0});const on=q,ug=Bs;class lg{constructor(t,n){this._settings=t,this._micromatchOptions=n}getFilter(t,n,r){const s=this._getMatcher(n),i=this._getNegativePatternsRe(r);return o=>this._filter(t,o,s,i)}_getMatcher(t){return new ug.default(t,this._settings,this._micromatchOptions)}_getNegativePatternsRe(t){const n=t.filter(on.pattern.isAffectDepthOfReadingPattern);return on.pattern.convertPatternsToRe(n,this._micromatchOptions)}_filter(t,n,r,s){if(this._isSkippedByDeep(t,n.path)||this._isSkippedSymbolicLink(n))return!1;const i=on.path.removeLeadingDotSegment(n.path);return this._isSkippedByPositivePatterns(i,r)?!1:this._isSkippedByNegativePatterns(i,s)}_isSkippedByDeep(t,n){return this._settings.deep===1/0?!1:this._getEntryLevel(t,n)>=this._settings.deep}_getEntryLevel(t,n){const r=n.split("/").length;if(t==="")return r;const s=t.split("/").length;return r-s}_isSkippedSymbolicLink(t){return!this._settings.followSymbolicLinks&&t.dirent.isSymbolicLink()}_isSkippedByPositivePatterns(t,n){return!this._settings.baseNameMatch&&!n.match(t)}_isSkippedByNegativePatterns(t,n){return!on.pattern.matchAny(t,n)}}Ns.default=lg;var Us={};Object.defineProperty(Us,"__esModule",{value:!0});const Be=q;class fg{constructor(t,n){this._settings=t,this._micromatchOptions=n,this.index=new Map}getFilter(t,n){const[r,s]=Be.pattern.partitionAbsoluteAndRelative(n),i={positive:{all:Be.pattern.convertPatternsToRe(t,this._micromatchOptions)},negative:{absolute:Be.pattern.convertPatternsToRe(r,Object.assign(Object.assign({},this._micromatchOptions),{dot:!0})),relative:Be.pattern.convertPatternsToRe(s,Object.assign(Object.assign({},this._micromatchOptions),{dot:!0}))}};return o=>this._filter(o,i)}_filter(t,n){const r=Be.path.removeLeadingDotSegment(t.path);if(this._settings.unique&&this._isDuplicateEntry(r)||this._onlyFileFilter(t)||this._onlyDirectoryFilter(t))return!1;const s=this._isMatchToPatternsSet(r,n,t.dirent.isDirectory());return this._settings.unique&&s&&this._createIndexRecord(r),s}_isDuplicateEntry(t){return this.index.has(t)}_createIndexRecord(t){this.index.set(t,void 0)}_onlyFileFilter(t){return this._settings.onlyFiles&&!t.dirent.isFile()}_onlyDirectoryFilter(t){return this._settings.onlyDirectories&&!t.dirent.isDirectory()}_isMatchToPatternsSet(t,n,r){return!(!this._isMatchToPatterns(t,n.positive.all,r)||this._isMatchToPatterns(t,n.negative.relative,r)||this._isMatchToAbsoluteNegative(t,n.negative.absolute,r))}_isMatchToAbsoluteNegative(t,n,r){if(n.length===0)return!1;const s=Be.path.makeAbsolute(this._settings.cwd,t);return this._isMatchToPatterns(s,n,r)}_isMatchToPatterns(t,n,r){if(n.length===0)return!1;const s=Be.pattern.matchAny(t,n);return!s&&r?Be.pattern.matchAny(t+"/",n):s}}Us.default=fg;var Hs={};Object.defineProperty(Hs,"__esModule",{value:!0});const dg=q;class hg{constructor(t){this._settings=t}getFilter(){return t=>this._isNonFatalError(t)}_isNonFatalError(t){return dg.errno.isEnoentCodeError(t)||this._settings.suppressErrors}}Hs.default=hg;var Gs={};Object.defineProperty(Gs,"__esModule",{value:!0});const lo=q;class pg{constructor(t){this._settings=t}getTransformer(){return t=>this._transform(t)}_transform(t){let n=t.path;return this._settings.absolute&&(n=lo.path.makeAbsolute(this._settings.cwd,n),n=lo.path.unixify(n)),this._settings.markDirectories&&t.dirent.isDirectory()&&(n+="/"),this._settings.objectMode?Object.assign(Object.assign({},t),{path:n}):n}}Gs.default=pg;Object.defineProperty(Kt,"__esModule",{value:!0});const gg=z,mg=Ns,yg=Us,Sg=Hs,bg=Gs;class wg{constructor(t){this._settings=t,this.errorFilter=new Sg.default(this._settings),this.entryFilter=new yg.default(this._settings,this._getMicromatchOptions()),this.deepFilter=new mg.default(this._settings,this._getMicromatchOptions()),this.entryTransformer=new bg.default(this._settings)}_getRootDirectory(t){return gg.resolve(this._settings.cwd,t.base)}_getReaderOptions(t){const n=t.base==="."?"":t.base;return{basePath:n,pathSegmentSeparator:"/",concurrency:this._settings.concurrency,deepFilter:this.deepFilter.getFilter(n,t.positive,t.negative),entryFilter:this.entryFilter.getFilter(t.positive,t.negative),errorFilter:this.errorFilter.getFilter(),followSymbolicLinks:this._settings.followSymbolicLinks,fs:this._settings.fs,stats:this._settings.stats,throwErrorOnBrokenSymbolicLink:this._settings.throwErrorOnBrokenSymbolicLink,transform:this.entryTransformer.getTransformer()}}_getMicromatchOptions(){return{dot:this._settings.dot,matchBase:this._settings.baseNameMatch,nobrace:!this._settings.braceExpansion,nocase:!this._settings.caseSensitiveMatch,noext:!this._settings.extglob,noglobstar:!this._settings.globstar,posix:!0,strictSlashes:!1}}}Kt.default=wg;Object.defineProperty(Is,"__esModule",{value:!0});const _g=Os,Eg=Kt;class Ag extends Eg.default{constructor(){super(...arguments),this._reader=new _g.default(this._settings)}async read(t){const n=this._getRootDirectory(t),r=this._getReaderOptions(t);return(await this.api(n,t,r)).map(i=>r.transform(i))}api(t,n,r){return n.dynamic?this._reader.dynamic(t,r):this._reader.static(n.patterns,r)}}Is.default=Ag;var Ws={};Object.defineProperty(Ws,"__esModule",{value:!0});const vg=Fn,Rg=Yn,Tg=Kt;class Pg extends Tg.default{constructor(){super(...arguments),this._reader=new Rg.default(this._settings)}read(t){const n=this._getRootDirectory(t),r=this._getReaderOptions(t),s=this.api(n,t,r),i=new vg.Readable({objectMode:!0,read:()=>{}});return s.once("error",o=>i.emit("error",o)).on("data",o=>i.emit("data",r.transform(o))).once("end",()=>i.emit("end")),i.once("close",()=>s.destroy()),i}api(t,n,r){return n.dynamic?this._reader.dynamic(t,r):this._reader.static(n.patterns,r)}}Ws.default=Pg;var qs={},Vs={};Object.defineProperty(Vs,"__esModule",{value:!0});const Ig=he,Og=ye,Dg=zt;class Cg extends Dg.default{constructor(){super(...arguments),this._walkSync=Og.walkSync,this._statSync=Ig.statSync}dynamic(t,n){return this._walkSync(t,n)}static(t,n){const r=[];for(const s of t){const i=this._getFullEntryPath(s),o=this._getEntry(i,s,n);o===null||!n.entryFilter(o)||r.push(o)}return r}_getEntry(t,n,r){try{const s=this._getStat(t);return this._makeEntry(s,n)}catch(s){if(r.errorFilter(s))return null;throw s}}_getStat(t){return this._statSync(t,this._fsStatSettings)}}Vs.default=Cg;Object.defineProperty(qs,"__esModule",{value:!0});const $g=Vs,xg=Kt;class Mg extends xg.default{constructor(){super(...arguments),this._reader=new $g.default(this._settings)}read(t){const n=this._getRootDirectory(t),r=this._getReaderOptions(t);return this.api(n,t,r).map(r.transform)}api(t,n,r){return n.dynamic?this._reader.dynamic(t,r):this._reader.static(n.patterns,r)}}qs.default=Mg;var ic={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.DEFAULT_FILE_SYSTEM_ADAPTER=void 0;const t=vt,r=Math.max(ms.cpus().length,1);e.DEFAULT_FILE_SYSTEM_ADAPTER={lstat:t.lstat,lstatSync:t.lstatSync,stat:t.stat,statSync:t.statSync,readdir:t.readdir,readdirSync:t.readdirSync};class s{constructor(o={}){this._options=o,this.absolute=this._getValue(this._options.absolute,!1),this.baseNameMatch=this._getValue(this._options.baseNameMatch,!1),this.braceExpansion=this._getValue(this._options.braceExpansion,!0),this.caseSensitiveMatch=this._getValue(this._options.caseSensitiveMatch,!0),this.concurrency=this._getValue(this._options.concurrency,r),this.cwd=this._getValue(this._options.cwd,process.cwd()),this.deep=this._getValue(this._options.deep,1/0),this.dot=this._getValue(this._options.dot,!1),this.extglob=this._getValue(this._options.extglob,!0),this.followSymbolicLinks=this._getValue(this._options.followSymbolicLinks,!0),this.fs=this._getFileSystemMethods(this._options.fs),this.globstar=this._getValue(this._options.globstar,!0),this.ignore=this._getValue(this._options.ignore,[]),this.markDirectories=this._getValue(this._options.markDirectories,!1),this.objectMode=this._getValue(this._options.objectMode,!1),this.onlyDirectories=this._getValue(this._options.onlyDirectories,!1),this.onlyFiles=this._getValue(this._options.onlyFiles,!0),this.stats=this._getValue(this._options.stats,!1),this.suppressErrors=this._getValue(this._options.suppressErrors,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!1),this.unique=this._getValue(this._options.unique,!0),this.onlyDirectories&&(this.onlyFiles=!1),this.stats&&(this.objectMode=!0),this.ignore=[].concat(this.ignore)}_getValue(o,a){return o===void 0?a:o}_getFileSystemMethods(o={}){return Object.assign(Object.assign({},e.DEFAULT_FILE_SYSTEM_ADAPTER),o)}}e.default=s})(ic);const oc=re,Lg=Is,Fg=Ws,jg=qs,Ur=ic,ge=q;async function Hr(e,t){we(e);const n=Gr(e,Lg.default,t),r=await Promise.all(n);return ge.array.flatten(r)}(function(e){e.glob=e,e.globSync=t,e.globStream=n,e.async=e;function t(a,c){we(a);const l=Gr(a,jg.default,c);return ge.array.flatten(l)}e.sync=t;function n(a,c){we(a);const l=Gr(a,Fg.default,c);return ge.stream.merge(l)}e.stream=n;function r(a,c){we(a);const l=[].concat(a),u=new Ur.default(c);return oc.generate(l,u)}e.generateTasks=r;function s(a,c){we(a);const l=new Ur.default(c);return ge.pattern.isDynamicPattern(a,l)}e.isDynamicPattern=s;function i(a){return we(a),ge.path.escape(a)}e.escapePath=i;function o(a){return we(a),ge.path.convertPathToPattern(a)}e.convertPathToPattern=o,function(a){function c(u){return we(u),ge.path.escapePosixPath(u)}a.escapePath=c;function l(u){return we(u),ge.path.convertPosixPathToPattern(u)}a.convertPathToPattern=l}(e.posix||(e.posix={})),function(a){function c(u){return we(u),ge.path.escapeWindowsPath(u)}a.escapePath=c;function l(u){return we(u),ge.path.convertWindowsPathToPattern(u)}a.convertPathToPattern=l}(e.win32||(e.win32={}))})(Hr||(Hr={}));function Gr(e,t,n){const r=[].concat(e),s=new Ur.default(n),i=oc.generate(r,s),o=new t(s);return i.map(o.read,o)}function we(e){if(![].concat(e).every(r=>ge.string.isString(r)&&!ge.string.isEmpty(r)))throw new TypeError("Patterns must be a string (non empty) or an array of strings")}var ft=Hr;function be(e){if(typeof e!="object"||e===null)return!1;const t=Object.getPrototypeOf(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)}const zs=(e,t)=>{const n=cc(Ng(e));if(typeof n!="string")throw new TypeError(`${t} must be a string or a file URL: ${n}.`);return n},Ng=e=>ac(e)?e.toString():e,ac=e=>typeof e!="string"&&e&&Object.getPrototypeOf(e)===String.prototype,cc=e=>e instanceof URL?gs.fileURLToPath(e):e,uc=(e,t=[],n={})=>{const r=zs(e,"First argument"),[s,i]=be(t)?[[],t]:[t,n];if(!Array.isArray(s))throw new TypeError(`Second argument must be either an array of arguments or an options object: ${s}`);if(s.some(c=>typeof c=="object"&&c!==null))throw new TypeError(`Second argument must be an array of strings: ${s}`);const o=s.map(String),a=o.find(c=>c.includes("\0"));if(a!==void 0)throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${a}`);if(!be(i))throw new TypeError(`Last argument must be an options object: ${i}`);return[r,o,i]},{toString:lc}=Object.prototype,Bg=e=>lc.call(e)==="[object ArrayBuffer]",ve=e=>lc.call(e)==="[object Uint8Array]",Ft=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),kg=new TextEncoder,fc=e=>kg.encode(e),Ug=new TextDecoder,dc=e=>Ug.decode(e),Hg=(e,t)=>Gg(e,t).join(""),Gg=(e,t)=>{if(t==="utf8"&&e.every(i=>typeof i=="string"))return e;const n=new fa.StringDecoder(t),r=e.map(i=>typeof i=="string"?fc(i):i).map(i=>n.write(i)),s=n.end();return s===""?r:[...r,s]},Ks=e=>e.length===1&&ve(e[0])?e[0]:hc(Wg(e)),Wg=e=>e.map(t=>typeof t=="string"?fc(t):t),hc=e=>{const t=new Uint8Array(qg(e));let n=0;for(const r of e)t.set(r,n),n+=r.length;return t},qg=e=>{let t=0;for(const n of e)t+=n.length;return t},Vg=e=>Array.isArray(e)&&Array.isArray(e.raw),zg=(e,t)=>{let n=[];for(const[i,o]of e.entries())n=Kg({templates:e,expressions:t,tokens:n,index:i,template:o});if(n.length===0)throw new TypeError("Template script must not be empty");const[r,...s]=n;return[r,s,{}]},Kg=({templates:e,expressions:t,tokens:n,index:r,template:s})=>{if(s===void 0)throw new TypeError(`Invalid backslash sequence: ${e.raw[r]}`);const{nextTokens:i,leadingWhitespaces:o,trailingWhitespaces:a}=Yg(s,e.raw[r]),c=ho(n,i,o);if(r===t.length)return c;const l=t[r],u=Array.isArray(l)?l.map(f=>po(f)):[po(l)];return ho(c,u,a)},Yg=(e,t)=>{if(t.length===0)return{nextTokens:[],leadingWhitespaces:!1,trailingWhitespaces:!1};const n=[];let r=0;const s=fo.has(t[0]);for(let o=0,a=0;o<e.length;o+=1,a+=1){const c=t[a];if(fo.has(c))r!==o&&n.push(e.slice(r,o)),r=o+1;else if(c==="\\"){const l=t[a+1];l===`
`?(o-=1,a+=1):l==="u"&&t[a+2]==="{"?a=t.indexOf("}",a+3):a+=Jg[l]??1}}const i=r===e.length;return i||n.push(e.slice(r)),{nextTokens:n,leadingWhitespaces:s,trailingWhitespaces:i}},fo=new Set([" ","	","\r",`
`]),Jg={x:3,u:5},ho=(e,t,n)=>n||e.length===0||t.length===0?[...e,...t]:[...e.slice(0,-1),`${e.at(-1)}${t[0]}`,...t.slice(1)],po=e=>{const t=typeof e;if(t==="string")return e;if(t==="number")return String(e);if(be(e)&&("stdout"in e||"isMaxBuffer"in e))return Qg(e);throw e instanceof Ut.ChildProcess||Object.prototype.toString.call(e)==="[object Promise]"?new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}."):new TypeError(`Unexpected "${t}" in template expression`)},Qg=({stdout:e})=>{if(typeof e=="string")return e;if(ve(e))return dc(e);throw e===void 0?new TypeError(`Missing result.stdout in template expression. This is probably due to the previous subprocess' "stdout" option.`):new TypeError(`Unexpected "${typeof e}" stdout in template expression`)},nt=e=>Ys.includes(e),Ys=[K.stdin,K.stdout,K.stderr],Me=["stdin","stdout","stderr"],pc=e=>Me[e]??`stdio[${e}]`,Xg=e=>{const t={...e};for(const n of yc)t[n]=gc(e,n);return t},gc=(e,t)=>{const n=Array.from({length:Zg(e)+1}),r=em(e[t],n,t);return im(r,t)},Zg=({stdio:e})=>Array.isArray(e)?Math.max(e.length,Me.length):Me.length,em=(e,t,n)=>be(e)?tm(e,t,n):t.fill(e),tm=(e,t,n)=>{for(const r of Object.keys(e).sort(nm))for(const s of rm(r,n,t))t[s]=e[r];return t},nm=(e,t)=>go(e)<go(t)?1:-1,go=e=>e==="stdout"||e==="stderr"?0:e==="all"?2:1,rm=(e,t,n)=>{if(e==="ipc")return[n.length-1];const r=mc(e);if(r===void 0||r===0)throw new TypeError(`"${t}.${e}" is invalid.
It must be "${t}.stdout", "${t}.stderr", "${t}.all", "${t}.ipc", or "${t}.fd3", "${t}.fd4" (and so on).`);if(r>=n.length)throw new TypeError(`"${t}.${e}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);return r==="all"?[1,2]:[r]},mc=e=>{if(e==="all")return e;if(Me.includes(e))return Me.indexOf(e);const t=sm.exec(e);if(t!==null)return Number(t[1])},sm=/^fd(\d+)$/,im=(e,t)=>e.map(n=>n===void 0?am[t]:n),om=pe.debuglog("execa").enabled?"full":"none",am={lines:!1,buffer:!0,maxBuffer:1e3*1e3*100,verbose:om,stripFinalNewline:!0},yc=["lines","buffer","maxBuffer","verbose","stripFinalNewline"],jt=(e,t)=>t==="ipc"?e.at(-1):e[t],Js=({verbose:e},t)=>Xs(e,t)!=="none",Qs=({verbose:e},t)=>!["none","short"].includes(Xs(e,t)),cm=({verbose:e},t)=>{const n=Xs(e,t);return Zs(n)?n:void 0},Xs=(e,t)=>t===void 0?um(e):jt(e,t),um=e=>e.find(t=>Zs(t))??Wr.findLast(t=>e.includes(t)),Zs=e=>typeof e=="function",Wr=["none","short","full"],lm=(e,t)=>{const n=[e,...t],r=n.join(" "),s=n.map(i=>mm(Sc(i))).join(" ");return{command:r,escapedCommand:s}},ei=e=>pe.stripVTControlCharacters(e).split(`
`).map(t=>Sc(t)).join(`
`),Sc=e=>e.replaceAll(hm,t=>fm(t)),fm=e=>{const t=pm[e];if(t!==void 0)return t;const n=e.codePointAt(0),r=n.toString(16);return n<=gm?`\\u${r.padStart(4,"0")}`:`\\U${r}`},dm=()=>{try{return new RegExp("\\p{Separator}|\\p{Other}","gu")}catch{return/[\s\u0000-\u001F\u007F-\u009F\u00AD]/g}},hm=dm(),pm={" ":" ","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","	":"\\t"},gm=65535,mm=e=>ym.test(e)?e:K.platform==="win32"?`"${e.replaceAll('"','""')}"`:`'${e.replaceAll("'","'\\''")}'`,ym=/^[\w./-]+$/;function Sm(){const{env:e}=K,{TERM:t,TERM_PROGRAM:n}=e;return K.platform!=="win32"?t!=="linux":!!e.WT_SESSION||!!e.TERMINUS_SUBLIME||e.ConEmuTask==="{cmd::Cmder}"||n==="Terminus-Sublime"||n==="vscode"||t==="xterm-256color"||t==="alacritty"||t==="rxvt-unicode"||t==="rxvt-unicode-256color"||e.TERMINAL_EMULATOR==="JetBrains-JediTerm"}const bc={circleQuestionMark:"(?)",questionMarkPrefix:"(?)",square:"â",squareDarkShade:"â",squareMediumShade:"â",squareLightShade:"â",squareTop:"â",squareBottom:"â",squareLeft:"â",squareRight:"â",squareCenter:"â ",bullet:"â",dot:"â¤",ellipsis:"â¦",pointerSmall:"âº",triangleUp:"â²",triangleUpSmall:"â´",triangleDown:"â¼",triangleDownSmall:"â¾",triangleLeftSmall:"â",triangleRightSmall:"â¸",home:"â",heart:"â¥",musicNote:"âª",musicNoteBeamed:"â«",arrowUp:"â",arrowDown:"â",arrowLeft:"â",arrowRight:"â",arrowLeftRight:"â",arrowUpDown:"â",almostEqual:"â",notEqual:"â ",lessOrEqual:"â¤",greaterOrEqual:"â¥",identical:"â¡",infinity:"â",subscriptZero:"â",subscriptOne:"â",subscriptTwo:"â",subscriptThree:"â",subscriptFour:"â",subscriptFive:"â",subscriptSix:"â",subscriptSeven:"â",subscriptEight:"â",subscriptNine:"â",oneHalf:"Â½",oneThird:"â",oneQuarter:"Â¼",oneFifth:"â",oneSixth:"â",oneEighth:"â",twoThirds:"â",twoFifths:"â",threeQuarters:"Â¾",threeFifths:"â",threeEighths:"â",fourFifths:"â",fiveSixths:"â",fiveEighths:"â",sevenEighths:"â",line:"â",lineBold:"â",lineDouble:"â",lineDashed0:"â",lineDashed1:"â",lineDashed2:"â",lineDashed3:"â",lineDashed4:"â",lineDashed5:"â",lineDashed6:"â´",lineDashed7:"â¶",lineDashed8:"â¸",lineDashed9:"âº",lineDashed10:"â¼",lineDashed11:"â¾",lineDashed12:"â",lineDashed13:"â",lineDashed14:"â",lineDashed15:"â",lineVertical:"â",lineVerticalBold:"â",lineVerticalDouble:"â",lineVerticalDashed0:"â",lineVerticalDashed1:"â",lineVerticalDashed2:"â",lineVerticalDashed3:"â",lineVerticalDashed4:"â",lineVerticalDashed5:"â",lineVerticalDashed6:"âµ",lineVerticalDashed7:"â·",lineVerticalDashed8:"â¹",lineVerticalDashed9:"â»",lineVerticalDashed10:"â½",lineVerticalDashed11:"â¿",lineDownLeft:"â",lineDownLeftArc:"â®",lineDownBoldLeftBold:"â",lineDownBoldLeft:"â",lineDownLeftBold:"â",lineDownDoubleLeftDouble:"â",lineDownDoubleLeft:"â",lineDownLeftDouble:"â",lineDownRight:"â",lineDownRightArc:"â­",lineDownBoldRightBold:"â",lineDownBoldRight:"â",lineDownRightBold:"â",lineDownDoubleRightDouble:"â",lineDownDoubleRight:"â",lineDownRightDouble:"â",lineUpLeft:"â",lineUpLeftArc:"â¯",lineUpBoldLeftBold:"â",lineUpBoldLeft:"â",lineUpLeftBold:"â",lineUpDoubleLeftDouble:"â",lineUpDoubleLeft:"â",lineUpLeftDouble:"â",lineUpRight:"â",lineUpRightArc:"â°",lineUpBoldRightBold:"â",lineUpBoldRight:"â",lineUpRightBold:"â",lineUpDoubleRightDouble:"â",lineUpDoubleRight:"â",lineUpRightDouble:"â",lineUpDownLeft:"â¤",lineUpBoldDownBoldLeftBold:"â«",lineUpBoldDownBoldLeft:"â¨",lineUpDownLeftBold:"â¥",lineUpBoldDownLeftBold:"â©",lineUpDownBoldLeftBold:"âª",lineUpDownBoldLeft:"â§",lineUpBoldDownLeft:"â¦",lineUpDoubleDownDoubleLeftDouble:"â£",lineUpDoubleDownDoubleLeft:"â¢",lineUpDownLeftDouble:"â¡",lineUpDownRight:"â",lineUpBoldDownBoldRightBold:"â£",lineUpBoldDownBoldRight:"â ",lineUpDownRightBold:"â",lineUpBoldDownRightBold:"â¡",lineUpDownBoldRightBold:"â¢",lineUpDownBoldRight:"â",lineUpBoldDownRight:"â",lineUpDoubleDownDoubleRightDouble:"â ",lineUpDoubleDownDoubleRight:"â",lineUpDownRightDouble:"â",lineDownLeftRight:"â¬",lineDownBoldLeftBoldRightBold:"â³",lineDownLeftBoldRightBold:"â¯",lineDownBoldLeftRight:"â°",lineDownBoldLeftBoldRight:"â±",lineDownBoldLeftRightBold:"â²",lineDownLeftRightBold:"â®",lineDownLeftBoldRight:"â­",lineDownDoubleLeftDoubleRightDouble:"â¦",lineDownDoubleLeftRight:"â¥",lineDownLeftDoubleRightDouble:"â¤",lineUpLeftRight:"â´",lineUpBoldLeftBoldRightBold:"â»",lineUpLeftBoldRightBold:"â·",lineUpBoldLeftRight:"â¸",lineUpBoldLeftBoldRight:"â¹",lineUpBoldLeftRightBold:"âº",lineUpLeftRightBold:"â¶",lineUpLeftBoldRight:"âµ",lineUpDoubleLeftDoubleRightDouble:"â©",lineUpDoubleLeftRight:"â¨",lineUpLeftDoubleRightDouble:"â§",lineUpDownLeftRight:"â¼",lineUpBoldDownBoldLeftBoldRightBold:"â",lineUpDownBoldLeftBoldRightBold:"â",lineUpBoldDownLeftBoldRightBold:"â",lineUpBoldDownBoldLeftRightBold:"â",lineUpBoldDownBoldLeftBoldRight:"â",lineUpBoldDownLeftRight:"â",lineUpDownBoldLeftRight:"â",lineUpDownLeftBoldRight:"â½",lineUpDownLeftRightBold:"â¾",lineUpBoldDownBoldLeftRight:"â",lineUpDownLeftBoldRightBold:"â¿",lineUpBoldDownLeftBoldRight:"â",lineUpBoldDownLeftRightBold:"â",lineUpDownBoldLeftBoldRight:"â",lineUpDownBoldLeftRightBold:"â",lineUpDoubleDownDoubleLeftDoubleRightDouble:"â¬",lineUpDoubleDownDoubleLeftRight:"â«",lineUpDownLeftDoubleRightDouble:"âª",lineCross:"â³",lineBackslash:"â²",lineSlash:"â±"},bm={tick:"â",info:"â¹",warning:"â ",cross:"â",squareSmall:"â»",squareSmallFilled:"â¼",circle:"â¯",circleFilled:"â",circleDotted:"â",circleDouble:"â",circleCircle:"â",circleCross:"â§",circlePipe:"â¾",radioOn:"â",radioOff:"â¯",checkboxOn:"â",checkboxOff:"â",checkboxCircleOn:"â§",checkboxCircleOff:"â¾",pointer:"â¯",triangleUpOutline:"â³",triangleLeft:"â",triangleRight:"â¶",lozenge:"â",lozengeOutline:"â",hamburger:"â°",smiley:"ã¡",mustache:"à·´",star:"â",play:"â¶",nodejs:"â¬¢",oneSeventh:"â",oneNinth:"â",oneTenth:"â"},wm={tick:"â",info:"i",warning:"â¼",cross:"Ã",squareSmall:"â¡",squareSmallFilled:"â ",circle:"( )",circleFilled:"(*)",circleDotted:"( )",circleDouble:"( )",circleCircle:"(â)",circleCross:"(Ã)",circlePipe:"(â)",radioOn:"(*)",radioOff:"( )",checkboxOn:"[Ã]",checkboxOff:"[ ]",checkboxCircleOn:"(Ã)",checkboxCircleOff:"( )",pointer:">",triangleUpOutline:"â",triangleLeft:"â",triangleRight:"âº",lozenge:"â¦",lozengeOutline:"â",hamburger:"â¡",smiley:"âº",mustache:"âââ",star:"â¶",play:"âº",nodejs:"â¦",oneSeventh:"1/7",oneNinth:"1/9",oneTenth:"1/10"},_m={...bc,...bm},Em={...bc,...wm},Am=Sm(),Sr=Am?_m:Em;var aa,dn,ca;const vm=((ca=(dn=(aa=hn==null?void 0:hn.WriteStream)==null?void 0:aa.prototype)==null?void 0:dn.hasColors)==null?void 0:ca.call(dn))??!1,Jn=(e,t)=>{if(!vm)return s=>s;const n=`\x1B[${e}m`,r=`\x1B[${t}m`;return s=>{const i=s+"";let o=i.indexOf(r);if(o===-1)return n+i+r;let a=n,c=0;const u=(t===22?r:"")+n;for(;o!==-1;)a+=i.slice(c,o)+u,c=o+r.length,o=i.indexOf(r,c);return a+=i.slice(c)+r,a}},Rm=Jn(1,22),qr=Jn(90,39),Tm=Jn(91,39),Pm=Jn(93,39),Im=({type:e,message:t,timestamp:n,piped:r,commandId:s,result:{failed:i=!1}={},options:{reject:o=!0}})=>{const a=Om(n),c=Dm[e]({failed:i,reject:o,piped:r}),l=Cm[e]({reject:o});return`${qr(`[${a}]`)} ${qr(`[${s}]`)} ${l(c)} ${l(t)}`},Om=e=>`${an(e.getHours(),2)}:${an(e.getMinutes(),2)}:${an(e.getSeconds(),2)}.${an(e.getMilliseconds(),3)}`,an=(e,t)=>String(e).padStart(t,"0"),mo=({failed:e,reject:t})=>e?t?Sr.cross:Sr.warning:Sr.tick,Dm={command:({piped:e})=>e?"|":"$",output:()=>" ",ipc:()=>"*",error:mo,duration:mo},yo=e=>e,Cm={command:()=>Rm,output:()=>yo,ipc:()=>yo,error:({reject:e})=>e?Tm:Pm,duration:()=>qr},$m=(e,t,n)=>{const r=cm(t,n);return e.map(({verboseLine:s,verboseObject:i})=>xm(s,i,r)).filter(s=>s!==void 0).map(s=>Mm(s)).join("")},xm=(e,t,n)=>{if(n===void 0)return e;const r=n(e,t);if(typeof r=="string")return r},Mm=e=>e.endsWith(`
`)?e:`${e}
`,Yt=({type:e,verboseMessage:t,fdNumber:n,verboseInfo:r,result:s})=>{const i=Lm({type:e,result:s,verboseInfo:r}),o=Fm(t,i),a=$m(o,r,n);a!==""&&console.warn(a.slice(0,-1))},Lm=({type:e,result:t,verboseInfo:{escapedCommand:n,commandId:r,rawOptions:{piped:s=!1,...i}}})=>({type:e,escapedCommand:n,commandId:`${r}`,timestamp:new Date,piped:s,result:t,options:i}),Fm=(e,t)=>e.split(`
`).map(n=>jm({...t,message:n})),jm=e=>({verboseLine:Im(e),verboseObject:e}),wc=e=>{const t=typeof e=="string"?e:pe.inspect(e);return ei(t).replaceAll("	"," ".repeat(Nm))},Nm=2,Bm=(e,t)=>{Js(t)&&Yt({type:"command",verboseMessage:e,verboseInfo:t})},km=(e,t,n)=>{Gm(e);const r=Um(e);return{verbose:e,escapedCommand:t,commandId:r,rawOptions:n}},Um=e=>Js({verbose:e})?Hm++:void 0;let Hm=0n;const Gm=e=>{for(const t of e){if(t===!1)throw new TypeError(`The "verbose: false" option was renamed to "verbose: 'none'".`);if(t===!0)throw new TypeError(`The "verbose: true" option was renamed to "verbose: 'short'".`);if(!Wr.includes(t)&&!Zs(t)){const n=Wr.map(r=>`'${r}'`).join(", ");throw new TypeError(`The "verbose" option must not be ${t}. Allowed values are: ${n} or a function.`)}}},_c=()=>K.hrtime.bigint(),Ec=e=>Number(K.hrtime.bigint()-e)/1e6,Ac=(e,t,n)=>{const r=_c(),{command:s,escapedCommand:i}=lm(e,t),o=gc(n,"verbose"),a=km(o,i,{...n});return Bm(i,a),{command:s,escapedCommand:i,startTime:r,verboseInfo:a}};var Rt={exports:{}},br,So;function Wm(){if(So)return br;So=1,br=r,r.sync=s;var e=vt;function t(i,o){var a=o.pathExt!==void 0?o.pathExt:process.env.PATHEXT;if(!a||(a=a.split(";"),a.indexOf("")!==-1))return!0;for(var c=0;c<a.length;c++){var l=a[c].toLowerCase();if(l&&i.substr(-l.length).toLowerCase()===l)return!0}return!1}function n(i,o,a){return!i.isSymbolicLink()&&!i.isFile()?!1:t(o,a)}function r(i,o,a){e.stat(i,function(c,l){a(c,c?!1:n(l,i,o))})}function s(i,o){return n(e.statSync(i),i,o)}return br}var wr,bo;function qm(){if(bo)return wr;bo=1,wr=t,t.sync=n;var e=vt;function t(i,o,a){e.stat(i,function(c,l){a(c,c?!1:r(l,o))})}function n(i,o){return r(e.statSync(i),o)}function r(i,o){return i.isFile()&&s(i,o)}function s(i,o){var a=i.mode,c=i.uid,l=i.gid,u=o.uid!==void 0?o.uid:process.getuid&&process.getuid(),f=o.gid!==void 0?o.gid:process.getgid&&process.getgid(),d=parseInt("100",8),p=parseInt("010",8),h=parseInt("001",8),g=d|p,w=a&h||a&p&&l===f||a&d&&c===u||a&g&&u===0;return w}return wr}var vn;process.platform==="win32"||ha.TESTING_WINDOWS?vn=Wm():vn=qm();var Vm=ti;ti.sync=zm;function ti(e,t,n){if(typeof t=="function"&&(n=t,t={}),!n){if(typeof Promise!="function")throw new TypeError("callback not provided");return new Promise(function(r,s){ti(e,t||{},function(i,o){i?s(i):r(o)})})}vn(e,t||{},function(r,s){r&&(r.code==="EACCES"||t&&t.ignoreErrors)&&(r=null,s=!1),n(r,s)})}function zm(e,t){try{return vn.sync(e,t||{})}catch(n){if(t&&t.ignoreErrors||n.code==="EACCES")return!1;throw n}}const dt=process.platform==="win32"||process.env.OSTYPE==="cygwin"||process.env.OSTYPE==="msys",vc=z,Km=dt?";":":",Rc=Vm,Tc=e=>Object.assign(new Error(`not found: ${e}`),{code:"ENOENT"}),Pc=(e,t)=>{const n=t.colon||Km,r=e.match(/\//)||dt&&e.match(/\\/)?[""]:[...dt?[process.cwd()]:[],...(t.path||process.env.PATH||"").split(n)],s=dt?t.pathExt||process.env.PATHEXT||".EXE;.CMD;.BAT;.COM":"",i=dt?s.split(n):[""];return dt&&e.indexOf(".")!==-1&&i[0]!==""&&i.unshift(""),{pathEnv:r,pathExt:i,pathExtExe:s}},Ic=(e,t,n)=>{typeof t=="function"&&(n=t,t={}),t||(t={});const{pathEnv:r,pathExt:s,pathExtExe:i}=Pc(e,t),o=[],a=l=>new Promise((u,f)=>{if(l===r.length)return t.all&&o.length?u(o):f(Tc(e));const d=r[l],p=/^".*"$/.test(d)?d.slice(1,-1):d,h=vc.join(p,e),g=!p&&/^\.[\\\/]/.test(e)?e.slice(0,2)+h:h;u(c(g,l,0))}),c=(l,u,f)=>new Promise((d,p)=>{if(f===s.length)return d(a(u+1));const h=s[f];Rc(l+h,{pathExt:i},(g,w)=>{if(!g&&w)if(t.all)o.push(l+h);else return d(l+h);return d(c(l,u,f+1))})});return n?a(0).then(l=>n(null,l),n):a(0)},Ym=(e,t)=>{t=t||{};const{pathEnv:n,pathExt:r,pathExtExe:s}=Pc(e,t),i=[];for(let o=0;o<n.length;o++){const a=n[o],c=/^".*"$/.test(a)?a.slice(1,-1):a,l=vc.join(c,e),u=!c&&/^\.[\\\/]/.test(e)?e.slice(0,2)+l:l;for(let f=0;f<r.length;f++){const d=u+r[f];try{if(Rc.sync(d,{pathExt:s}))if(t.all)i.push(d);else return d}catch{}}}if(t.all&&i.length)return i;if(t.nothrow)return null;throw Tc(e)};var Jm=Ic;Ic.sync=Ym;var ni={exports:{}};const Oc=(e={})=>{const t=e.env||process.env;return(e.platform||process.platform)!=="win32"?"PATH":Object.keys(t).reverse().find(r=>r.toUpperCase()==="PATH")||"Path"};ni.exports=Oc;ni.exports.default=Oc;var Qm=ni.exports;const wo=z,Xm=Jm,Zm=Qm;function _o(e,t){const n=e.options.env||process.env,r=process.cwd(),s=e.options.cwd!=null,i=s&&process.chdir!==void 0&&!process.chdir.disabled;if(i)try{process.chdir(e.options.cwd)}catch{}let o;try{o=Xm.sync(e.command,{path:n[Zm({env:n})],pathExt:t?wo.delimiter:void 0})}catch{}finally{i&&process.chdir(r)}return o&&(o=wo.resolve(s?e.options.cwd:"",o)),o}function ey(e){return _o(e)||_o(e,!0)}var ty=ey,ri={};const Vr=/([()\][%!^"`<>&|;, *?])/g;function ny(e){return e=e.replace(Vr,"^$1"),e}function ry(e,t){return e=`${e}`,e=e.replace(/(?=(\\+?)?)\1"/g,'$1$1\\"'),e=e.replace(/(?=(\\+?)?)\1$/,"$1$1"),e=`"${e}"`,e=e.replace(Vr,"^$1"),t&&(e=e.replace(Vr,"^$1")),e}ri.command=ny;ri.argument=ry;var sy=/^#!(.*)/;const iy=sy;var oy=(e="")=>{const t=e.match(iy);if(!t)return null;const[n,r]=t[0].replace(/#! ?/,"").split(" "),s=n.split("/").pop();return s==="env"?r:r?`${s} ${r}`:s};const _r=vt,ay=oy;function cy(e){const n=Buffer.alloc(150);let r;try{r=_r.openSync(e,"r"),_r.readSync(r,n,0,150,0),_r.closeSync(r)}catch{}return ay(n.toString())}var uy=cy;const ly=z,Eo=ty,Ao=ri,fy=uy,dy=process.platform==="win32",hy=/\.(?:com|exe)$/i,py=/node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;function gy(e){e.file=Eo(e);const t=e.file&&fy(e.file);return t?(e.args.unshift(e.file),e.command=t,Eo(e)):e.file}function my(e){if(!dy)return e;const t=gy(e),n=!hy.test(t);if(e.options.forceShell||n){const r=py.test(t);e.command=ly.normalize(e.command),e.command=Ao.command(e.command),e.args=e.args.map(i=>Ao.argument(i,r));const s=[e.command].concat(e.args).join(" ");e.args=["/d","/s","/c",`"${s}"`],e.command=process.env.comspec||"cmd.exe",e.options.windowsVerbatimArguments=!0}return e}function yy(e,t,n){t&&!Array.isArray(t)&&(n=t,t=null),t=t?t.slice(0):[],n=Object.assign({},n);const r={command:e,args:t,options:n,file:void 0,original:{command:e,args:t}};return n.shell?r:my(r)}var Sy=yy;const si=process.platform==="win32";function ii(e,t){return Object.assign(new Error(`${t} ${e.command} ENOENT`),{code:"ENOENT",errno:"ENOENT",syscall:`${t} ${e.command}`,path:e.command,spawnargs:e.args})}function by(e,t){if(!si)return;const n=e.emit;e.emit=function(r,s){if(r==="exit"){const i=Dc(s,t);if(i)return n.call(e,"error",i)}return n.apply(e,arguments)}}function Dc(e,t){return si&&e===1&&!t.file?ii(t.original,"spawn"):null}function wy(e,t){return si&&e===1&&!t.file?ii(t.original,"spawnSync"):null}var _y={hookChildProcess:by,verifyENOENT:Dc,verifyENOENTSync:wy,notFoundError:ii};const Cc=zl,oi=Sy,ai=_y;function $c(e,t,n){const r=oi(e,t,n),s=Cc.spawn(r.command,r.args,r.options);return ai.hookChildProcess(s,r),s}function Ey(e,t,n){const r=oi(e,t,n),s=Cc.spawnSync(r.command,r.args,r.options);return s.error=s.error||ai.verifyENOENTSync(s.status,r),s}Rt.exports=$c;Rt.exports.spawn=$c;Rt.exports.sync=Ey;Rt.exports._parse=oi;Rt.exports._enoent=ai;var Ay=Rt.exports;const vy=Jl(Ay);function xc(e={}){const{env:t=process.env,platform:n=process.platform}=e;return n!=="win32"?"PATH":Object.keys(t).reverse().find(r=>r.toUpperCase()==="PATH")||"Path"}pe.promisify(Ut.execFile);function ci(e){return e instanceof URL?gs.fileURLToPath(e):e}function Ry(e){return{*[Symbol.iterator](){let t=se.resolve(ci(e)),n;for(;n!==t;)yield t,n=t,t=se.resolve(t,"..")}}}const Ty=({cwd:e=K.cwd(),path:t=K.env[xc()],preferLocal:n=!0,execPath:r=K.execPath,addExecPath:s=!0}={})=>{const i=se.resolve(ci(e)),o=[],a=t.split(se.delimiter);return n&&Py(o,a,i),s&&Iy(o,a,r,i),t===""||t===se.delimiter?`${o.join(se.delimiter)}${t}`:[...o,t].join(se.delimiter)},Py=(e,t,n)=>{for(const r of Ry(n)){const s=se.join(r,"node_modules/.bin");t.includes(s)||e.push(s)}},Iy=(e,t,n,r)=>{const s=se.resolve(r,ci(n),"..");t.includes(s)||e.push(s)},Oy=({env:e=K.env,...t}={})=>{e={...e};const n=xc({env:e});return t.path=e[n],e[n]=Ty(t),e},Dy=(e,t,n)=>{const r=n?Yr:Kr,s=e instanceof Jt?{}:{cause:e};return new r(t,s)};class Jt extends Error{}const Mc=(e,t)=>{Object.defineProperty(e.prototype,"name",{value:t,writable:!0,enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,Lc,{value:!0,writable:!1,enumerable:!1,configurable:!1})},Cy=e=>zr(e)&&Lc in e,Lc=Symbol("isExecaError"),zr=e=>Object.prototype.toString.call(e)==="[object Error]";class Kr extends Error{}Mc(Kr,Kr.name);class Yr extends Error{}Mc(Yr,Yr.name);const $y=()=>{const e=jc-Fc+1;return Array.from({length:e},xy)},xy=(e,t)=>({name:`SIGRT${t+1}`,number:Fc+t,action:"terminate",description:"Application-specific signal (realtime)",standard:"posix"}),Fc=34,jc=64,My=[{name:"SIGHUP",number:1,action:"terminate",description:"Terminal closed",standard:"posix"},{name:"SIGINT",number:2,action:"terminate",description:"User interruption with CTRL-C",standard:"ansi"},{name:"SIGQUIT",number:3,action:"core",description:"User interruption with CTRL-\\",standard:"posix"},{name:"SIGILL",number:4,action:"core",description:"Invalid machine instruction",standard:"ansi"},{name:"SIGTRAP",number:5,action:"core",description:"Debugger breakpoint",standard:"posix"},{name:"SIGABRT",number:6,action:"core",description:"Aborted",standard:"ansi"},{name:"SIGIOT",number:6,action:"core",description:"Aborted",standard:"bsd"},{name:"SIGBUS",number:7,action:"core",description:"Bus error due to misaligned, non-existing address or paging error",standard:"bsd"},{name:"SIGEMT",number:7,action:"terminate",description:"Command should be emulated but is not implemented",standard:"other"},{name:"SIGFPE",number:8,action:"core",description:"Floating point arithmetic error",standard:"ansi"},{name:"SIGKILL",number:9,action:"terminate",description:"Forced termination",standard:"posix",forced:!0},{name:"SIGUSR1",number:10,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGSEGV",number:11,action:"core",description:"Segmentation fault",standard:"ansi"},{name:"SIGUSR2",number:12,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGPIPE",number:13,action:"terminate",description:"Broken pipe or socket",standard:"posix"},{name:"SIGALRM",number:14,action:"terminate",description:"Timeout or timer",standard:"posix"},{name:"SIGTERM",number:15,action:"terminate",description:"Termination",standard:"ansi"},{name:"SIGSTKFLT",number:16,action:"terminate",description:"Stack is empty or overflowed",standard:"other"},{name:"SIGCHLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"posix"},{name:"SIGCLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"other"},{name:"SIGCONT",number:18,action:"unpause",description:"Unpaused",standard:"posix",forced:!0},{name:"SIGSTOP",number:19,action:"pause",description:"Paused",standard:"posix",forced:!0},{name:"SIGTSTP",number:20,action:"pause",description:'Paused using CTRL-Z or "suspend"',standard:"posix"},{name:"SIGTTIN",number:21,action:"pause",description:"Background process cannot read terminal input",standard:"posix"},{name:"SIGBREAK",number:21,action:"terminate",description:"User interruption with CTRL-BREAK",standard:"other"},{name:"SIGTTOU",number:22,action:"pause",description:"Background process cannot write to terminal output",standard:"posix"},{name:"SIGURG",number:23,action:"ignore",description:"Socket received out-of-band data",standard:"bsd"},{name:"SIGXCPU",number:24,action:"core",description:"Process timed out",standard:"bsd"},{name:"SIGXFSZ",number:25,action:"core",description:"File too big",standard:"bsd"},{name:"SIGVTALRM",number:26,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGPROF",number:27,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGWINCH",number:28,action:"ignore",description:"Terminal window size changed",standard:"bsd"},{name:"SIGIO",number:29,action:"terminate",description:"I/O is available",standard:"other"},{name:"SIGPOLL",number:29,action:"terminate",description:"Watched event",standard:"other"},{name:"SIGINFO",number:29,action:"ignore",description:"Request for process information",standard:"other"},{name:"SIGPWR",number:30,action:"terminate",description:"Device running out of power",standard:"systemv"},{name:"SIGSYS",number:31,action:"core",description:"Invalid system call",standard:"other"},{name:"SIGUNUSED",number:31,action:"terminate",description:"Invalid system call",standard:"other"}],Nc=()=>{const e=$y();return[...My,...e].map(Ly)},Ly=({name:e,number:t,description:n,action:r,forced:s=!1,standard:i})=>{const{signals:{[e]:o}}=tt.constants,a=o!==void 0;return{name:e,number:a?o:t,description:n,supported:a,action:r,forced:s,standard:i}},Fy=()=>{const e=Nc();return Object.fromEntries(e.map(jy))},jy=({name:e,number:t,description:n,supported:r,action:s,forced:i,standard:o})=>[e,{name:e,number:t,description:n,supported:r,action:s,forced:i,standard:o}],Ny=Fy(),By=()=>{const e=Nc(),t=jc+1,n=Array.from({length:t},(r,s)=>ky(s,e));return Object.assign({},...n)},ky=(e,t)=>{const n=Uy(e,t);if(n===void 0)return{};const{name:r,description:s,supported:i,action:o,forced:a,standard:c}=n;return{[e]:{name:r,number:e,description:s,supported:i,action:o,forced:a,standard:c}}},Uy=(e,t)=>{const n=t.find(({name:r})=>tt.constants.signals[r]===e);return n!==void 0?n:t.find(r=>r.number===e)};By();const Hy=e=>{const t="option `killSignal`";if(e===0)throw new TypeError(`Invalid ${t}: 0 cannot be used.`);return Bc(e,t)},Gy=e=>e===0?e:Bc(e,"`subprocess.kill()`'s argument"),Bc=(e,t)=>{if(Number.isInteger(e))return Wy(e,t);if(typeof e=="string")return Vy(e,t);throw new TypeError(`Invalid ${t} ${String(e)}: it must be a string or an integer.
${ui()}`)},Wy=(e,t)=>{if(vo.has(e))return vo.get(e);throw new TypeError(`Invalid ${t} ${e}: this signal integer does not exist.
${ui()}`)},qy=()=>new Map(Object.entries(tt.constants.signals).reverse().map(([e,t])=>[t,e])),vo=qy(),Vy=(e,t)=>{if(e in tt.constants.signals)return e;throw e.toUpperCase()in tt.constants.signals?new TypeError(`Invalid ${t} '${e}': please rename it to '${e.toUpperCase()}'.`):new TypeError(`Invalid ${t} '${e}': this signal name does not exist.
${ui()}`)},ui=()=>`Available signal names: ${zy()}.
Available signal numbers: ${Ky()}.`,zy=()=>Object.keys(tt.constants.signals).sort().map(e=>`'${e}'`).join(", "),Ky=()=>[...new Set(Object.values(tt.constants.signals).sort((e,t)=>e-t))].join(", "),kc=e=>Ny[e].description,Yy=e=>{if(e===!1)return e;if(e===!0)return Jy;if(!Number.isFinite(e)||e<0)throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);return e},Jy=1e3*5,Qy=({kill:e,options:{forceKillAfterDelay:t,killSignal:n},onInternalError:r,context:s,controller:i},o,a)=>{const{signal:c,error:l}=Xy(o,a,n);Zy(l,r);const u=e(c);return eS({kill:e,signal:c,forceKillAfterDelay:t,killSignal:n,killResult:u,context:s,controller:i}),u},Xy=(e,t,n)=>{const[r=n,s]=zr(e)?[void 0,e]:[e,t];if(typeof r!="string"&&!Number.isInteger(r))throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(r)}`);if(s!==void 0&&!zr(s))throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${s}`);return{signal:Gy(r),error:s}},Zy=(e,t)=>{e!==void 0&&t.reject(e)},eS=async({kill:e,signal:t,forceKillAfterDelay:n,killSignal:r,killResult:s,context:i,controller:o})=>{t===r&&s&&Uc({kill:e,forceKillAfterDelay:n,context:i,controllerSignal:o.signal})},Uc=async({kill:e,forceKillAfterDelay:t,context:n,controllerSignal:r})=>{if(t!==!1)try{await Ht.setTimeout(t,void 0,{signal:r}),e("SIGKILL")&&(n.isForcefullyTerminated??(n.isForcefullyTerminated=!0))}catch{}},Hc=async(e,t)=>{e.aborted||await Y.once(e,"abort",{signal:t})},tS=({cancelSignal:e})=>{if(e!==void 0&&Object.prototype.toString.call(e)!=="[object AbortSignal]")throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(e)}`)},nS=({subprocess:e,cancelSignal:t,gracefulCancel:n,context:r,controller:s})=>t===void 0||n?[]:[rS(e,t,r,s)],rS=async(e,t,n,{signal:r})=>{throw await Hc(t,r),n.terminationReason??(n.terminationReason="cancel"),e.kill(),t.reason},li=({methodName:e,isSubprocess:t,ipc:n,isConnected:r})=>{sS(e,t,n),Gc(e,t,r)},sS=(e,t,n)=>{if(!n)throw new Error(`${Ee(e,t)} can only be used if the \`ipc\` option is \`true\`.`)},Gc=(e,t,n)=>{if(!n)throw new Error(`${Ee(e,t)} cannot be used: the ${ze(t)} has already exited or disconnected.`)},iS=e=>{throw new Error(`${Ee("getOneMessage",e)} could not complete: the ${ze(e)} exited or disconnected.`)},oS=e=>{throw new Error(`${Ee("sendMessage",e)} failed: the ${ze(e)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${Ee("getOneMessage",e)},
	${Ee("sendMessage",e,"message, {strict: true}")},
]);`)},Wc=(e,t)=>new Error(`${Ee("sendMessage",t)} failed when sending an acknowledgment response to the ${ze(t)}.`,{cause:e}),aS=e=>{throw new Error(`${Ee("sendMessage",e)} failed: the ${ze(e)} is not listening to incoming messages.`)},cS=e=>{throw new Error(`${Ee("sendMessage",e)} failed: the ${ze(e)} exited without listening to incoming messages.`)},uS=()=>new Error(`\`cancelSignal\` aborted: the ${ze(!0)} disconnected.`),lS=()=>{throw new Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.")},fS=({error:e,methodName:t,isSubprocess:n})=>{if(e.code==="EPIPE")throw new Error(`${Ee(t,n)} cannot be used: the ${ze(n)} is disconnecting.`,{cause:e})},dS=({error:e,methodName:t,isSubprocess:n,message:r})=>{if(hS(e))throw new Error(`${Ee(t,n)}'s argument type is invalid: the message cannot be serialized: ${String(r)}.`,{cause:e})},hS=({code:e,message:t})=>pS.has(e)||gS.some(n=>t.includes(n)),pS=new Set(["ERR_MISSING_ARGS","ERR_INVALID_ARG_TYPE"]),gS=["could not be cloned","circular structure","call stack size exceeded"],Ee=(e,t,n="")=>e==="cancelSignal"?"`cancelSignal`'s `controller.abort()`":`${mS(t)}${e}(${n})`,mS=e=>e?"":"subprocess.",ze=e=>e?"parent process":"subprocess",fi=e=>{e.connected&&e.disconnect()},Qt=()=>{const e={},t=new Promise((n,r)=>{Object.assign(e,{resolve:n,reject:r})});return Object.assign(t,e)},qc=(e,t="stdin")=>{const{options:r,fileDescriptors:s}=rt.get(e),i=Vc(s,t,!0),o=e.stdio[i];if(o===null)throw new TypeError(zc(i,t,r,!0));return o},di=(e,t="stdout")=>{const{options:r,fileDescriptors:s}=rt.get(e),i=Vc(s,t,!1),o=i==="all"?e.all:e.stdio[i];if(o==null)throw new TypeError(zc(i,t,r,!1));return o},rt=new WeakMap,Vc=(e,t,n)=>{const r=yS(t,n);return SS(r,t,n,e),r},yS=(e,t)=>{const n=mc(e);if(n!==void 0)return n;const{validOptions:r,defaultValue:s}=t?{validOptions:'"stdin"',defaultValue:"stdin"}:{validOptions:'"stdout", "stderr", "all"',defaultValue:"stdout"};throw new TypeError(`"${Mt(t)}" must not be "${e}".
It must be ${r} or "fd3", "fd4" (and so on).
It is optional and defaults to "${s}".`)},SS=(e,t,n,r)=>{const s=r[Kc(e)];if(s===void 0)throw new TypeError(`"${Mt(n)}" must not be ${t}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);if(s.direction==="input"&&!n)throw new TypeError(`"${Mt(n)}" must not be ${t}. It must be a readable stream, not writable.`);if(s.direction!=="input"&&n)throw new TypeError(`"${Mt(n)}" must not be ${t}. It must be a writable stream, not readable.`)},zc=(e,t,n,r)=>{if(e==="all"&&!n.all)return`The "all" option must be true to use "from: 'all'".`;const{optionName:s,optionValue:i}=bS(e,n);return`The "${s}: ${Jr(i)}" option is incompatible with using "${Mt(r)}: ${Jr(t)}".
Please set this option with "pipe" instead.`},bS=(e,{stdin:t,stdout:n,stderr:r,stdio:s})=>{const i=Kc(e);return i===0&&t!==void 0?{optionName:"stdin",optionValue:t}:i===1&&n!==void 0?{optionName:"stdout",optionValue:n}:i===2&&r!==void 0?{optionName:"stderr",optionValue:r}:{optionName:`stdio[${i}]`,optionValue:s[i]}},Kc=e=>e==="all"?1:e,Mt=e=>e?"to":"from",Jr=e=>typeof e=="string"?`'${e}'`:typeof e=="number"?`${e}`:"Stream",Rn=(e,t,n)=>{const r=e.getMaxListeners();r===0||r===Number.POSITIVE_INFINITY||(e.setMaxListeners(r+t),Y.addAbortListener(n,()=>{e.setMaxListeners(e.getMaxListeners()-t)}))},Yc=(e,t)=>{t&&Qr(e)},Qr=e=>{e.refCounted()},Jc=(e,t)=>{t&&Xr(e)},Xr=e=>{e.unrefCounted()},wS=(e,t)=>{t&&(Xr(e),Xr(e))},_S=(e,t)=>{t&&(Qr(e),Qr(e))},ES=async({anyProcess:e,channel:t,isSubprocess:n,ipcEmitter:r},s)=>{if(OS(s)||US(s))return;gn.has(e)||gn.set(e,[]);const i=gn.get(e);if(i.push(s),!(i.length>1))for(;i.length>0;){await MS(e,r,s),await Ht.scheduler.yield();const o=await IS({wrappedMessage:i[0],anyProcess:e,channel:t,isSubprocess:n,ipcEmitter:r});i.shift(),r.emit("message",o),r.emit("message:done")}},AS=async({anyProcess:e,channel:t,isSubprocess:n,ipcEmitter:r,boundOnMessage:s})=>{nu();const i=gn.get(e);for(;(i==null?void 0:i.length)>0;)await Y.once(r,"message:done");e.removeListener("message",s),_S(t,n),r.connected=!1,r.emit("disconnect")},gn=new WeakMap,Qn=(e,t,n)=>{if(mn.has(e))return mn.get(e);const r=new Y.EventEmitter;return r.connected=!0,mn.set(e,r),vS({ipcEmitter:r,anyProcess:e,channel:t,isSubprocess:n}),r},mn=new WeakMap,vS=({ipcEmitter:e,anyProcess:t,channel:n,isSubprocess:r})=>{const s=ES.bind(void 0,{anyProcess:t,channel:n,isSubprocess:r,ipcEmitter:e});t.on("message",s),t.once("disconnect",AS.bind(void 0,{anyProcess:t,channel:n,isSubprocess:r,ipcEmitter:e,boundOnMessage:s})),wS(n,r)},Qc=e=>{const t=mn.get(e);return t===void 0?e.channel!==null:t.connected},RS=({anyProcess:e,channel:t,isSubprocess:n,message:r,strict:s})=>{if(!s)return r;const i=Qn(e,t,n),o=hi(e,i);return{id:TS++,type:Xn,message:r,hasListeners:o}};let TS=0n;const PS=(e,t)=>{if(!((t==null?void 0:t.type)!==Xn||t.hasListeners))for(const{id:n}of e)n!==void 0&&Tn[n].resolve({isDeadlock:!0,hasListeners:!1})},IS=async({wrappedMessage:e,anyProcess:t,channel:n,isSubprocess:r,ipcEmitter:s})=>{if((e==null?void 0:e.type)!==Xn||!t.connected)return e;const{id:i,message:o}=e,a={id:i,type:Xc,message:hi(t,s)};try{await Zc({anyProcess:t,channel:n,isSubprocess:r,ipc:!0},a)}catch(c){s.emit("strict:error",c)}return o},OS=e=>{var r;if((e==null?void 0:e.type)!==Xc)return!1;const{id:t,message:n}=e;return(r=Tn[t])==null||r.resolve({isDeadlock:!1,hasListeners:n}),!0},DS=async(e,t,n)=>{if((e==null?void 0:e.type)!==Xn)return;const r=Qt();Tn[e.id]=r;const s=new AbortController;try{const{isDeadlock:i,hasListeners:o}=await Promise.race([r,CS(t,n,s)]);i&&oS(n),o||aS(n)}finally{s.abort(),delete Tn[e.id]}},Tn={},CS=async(e,t,{signal:n})=>{Rn(e,1,n),await Y.once(e,"disconnect",{signal:n}),cS(t)},Xn="execa:ipc:request",Xc="execa:ipc:response",$S=(e,t,n)=>{Lt.has(e)||Lt.set(e,new Set);const r=Lt.get(e),s=Qt(),i=n?t.id:void 0,o={onMessageSent:s,id:i};return r.add(o),{outgoingMessages:r,outgoingMessage:o}},xS=({outgoingMessages:e,outgoingMessage:t})=>{e.delete(t),t.onMessageSent.resolve()},MS=async(e,t,n)=>{var r;for(;!hi(e,t)&&((r=Lt.get(e))==null?void 0:r.size)>0;){const s=[...Lt.get(e)];PS(s,n),await Promise.all(s.map(({onMessageSent:i})=>i))}},Lt=new WeakMap,hi=(e,t)=>t.listenerCount("message")>LS(e),LS=e=>rt.has(e)&&!jt(rt.get(e).options.buffer,"ipc")?1:0,Zc=({anyProcess:e,channel:t,isSubprocess:n,ipc:r},s,{strict:i=!1}={})=>{const o="sendMessage";return li({methodName:o,isSubprocess:n,ipc:r,isConnected:e.connected}),FS({anyProcess:e,channel:t,methodName:o,isSubprocess:n,message:s,strict:i})},FS=async({anyProcess:e,channel:t,methodName:n,isSubprocess:r,message:s,strict:i})=>{const o=RS({anyProcess:e,channel:t,isSubprocess:r,message:s,strict:i}),a=$S(e,o,i);try{await eu({anyProcess:e,methodName:n,isSubprocess:r,wrappedMessage:o,message:s})}catch(c){throw fi(e),c}finally{xS(a)}},eu=async({anyProcess:e,methodName:t,isSubprocess:n,wrappedMessage:r,message:s})=>{const i=jS(e);try{await Promise.all([DS(r,e,n),i(r)])}catch(o){throw fS({error:o,methodName:t,isSubprocess:n}),dS({error:o,methodName:t,isSubprocess:n,message:s}),o}},jS=e=>{if(Er.has(e))return Er.get(e);const t=pe.promisify(e.send.bind(e));return Er.set(e,t),t},Er=new WeakMap,NS=(e,t)=>{const n="cancelSignal";return Gc(n,!1,e.connected),eu({anyProcess:e,methodName:n,isSubprocess:!1,wrappedMessage:{type:tu,message:t},message:t})},BS=async({anyProcess:e,channel:t,isSubprocess:n,ipc:r})=>(await kS({anyProcess:e,channel:t,isSubprocess:n,ipc:r}),pi.signal),kS=async({anyProcess:e,channel:t,isSubprocess:n,ipc:r})=>{if(!Ro){if(Ro=!0,!r){lS();return}if(t===null){nu();return}Qn(e,t,n),await Ht.scheduler.yield()}};let Ro=!1;const US=e=>(e==null?void 0:e.type)!==tu?!1:(pi.abort(e.message),!0),tu="execa:ipc:cancel",nu=()=>{pi.abort(uS())},pi=new AbortController,HS=({gracefulCancel:e,cancelSignal:t,ipc:n,serialization:r})=>{if(e){if(t===void 0)throw new Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");if(!n)throw new Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");if(r==="json")throw new Error("The `serialization` option cannot be 'json' when setting the `gracefulCancel` option.")}},GS=({subprocess:e,cancelSignal:t,gracefulCancel:n,forceKillAfterDelay:r,context:s,controller:i})=>n?[WS({subprocess:e,cancelSignal:t,forceKillAfterDelay:r,context:s,controller:i})]:[],WS=async({subprocess:e,cancelSignal:t,forceKillAfterDelay:n,context:r,controller:{signal:s}})=>{await Hc(t,s);const i=qS(t);throw await NS(e,i),Uc({kill:e.kill,forceKillAfterDelay:n,context:r,controllerSignal:s}),r.terminationReason??(r.terminationReason="gracefulCancel"),t.reason},qS=({reason:e})=>{if(!(e instanceof DOMException))return e;const t=new Error(e.message);return Object.defineProperty(t,"stack",{value:e.stack,enumerable:!1,configurable:!0,writable:!0}),t},VS=({timeout:e})=>{if(e!==void 0&&(!Number.isFinite(e)||e<0))throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`)},zS=(e,t,n,r)=>t===0||t===void 0?[]:[KS(e,t,n,r)],KS=async(e,t,n,{signal:r})=>{throw await Ht.setTimeout(t,void 0,{signal:r}),n.terminationReason??(n.terminationReason="timeout"),e.kill(),new Jt},YS=({options:e})=>{if(e.node===!1)throw new TypeError('The "node" option cannot be false with `execaNode()`.');return{options:{...e,node:!0}}},JS=(e,t,{node:n=!1,nodePath:r=K.execPath,nodeOptions:s=K.execArgv.filter(c=>!c.startsWith("--inspect")),cwd:i,execPath:o,...a})=>{if(o!==void 0)throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');const c=zs(r,'The "nodePath" option'),l=se.resolve(i,c),u={...a,nodePath:l,node:n,cwd:i};if(!n)return[e,t,u];if(se.basename(e,".exe")==="node")throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');return[l,[...s,e,...t],{ipc:!0,...u,shell:!1}]},QS=({ipcInput:e,ipc:t,serialization:n})=>{if(e!==void 0){if(!t)throw new Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");eb[n](e)}},XS=e=>{try{Kl.serialize(e)}catch(t){throw new Error("The `ipcInput` option is not serializable with a structured clone.",{cause:t})}},ZS=e=>{try{JSON.stringify(e)}catch(t){throw new Error("The `ipcInput` option is not serializable with JSON.",{cause:t})}},eb={advanced:XS,json:ZS},tb=async(e,t)=>{t!==void 0&&await e.sendMessage(t)},nb=({encoding:e})=>{if(Zr.has(e))return;const t=sb(e);if(t!==void 0)throw new TypeError(`Invalid option \`encoding: ${cn(e)}\`.
Please rename it to ${cn(t)}.`);const n=[...Zr].map(r=>cn(r)).join(", ");throw new TypeError(`Invalid option \`encoding: ${cn(e)}\`.
Please rename it to one of: ${n}.`)},rb=new Set(["utf8","utf16le"]),it=new Set(["buffer","hex","base64","base64url","latin1","ascii"]),Zr=new Set([...rb,...it]),sb=e=>{if(e===null)return"buffer";if(typeof e!="string")return;const t=e.toLowerCase();if(t in To)return To[t];if(Zr.has(t))return t},To={"utf-8":"utf8","utf-16le":"utf16le","ucs-2":"utf16le",ucs2:"utf16le",binary:"latin1"},cn=e=>typeof e=="string"?`"${e}"`:String(e),ib=(e=ru())=>{const t=zs(e,'The "cwd" option');return se.resolve(t)},ru=()=>{try{return K.cwd()}catch(e){throw e.message=`The current directory does not exist.
${e.message}`,e}},ob=(e,t)=>{if(t===ru())return e;let n;try{n=Ce.statSync(t)}catch(r){return`The "cwd" option is invalid: ${t}.
${r.message}
${e}`}return n.isDirectory()?e:`The "cwd" option is not a directory: ${t}.
${e}`},su=(e,t,n)=>{n.cwd=ib(n.cwd);const[r,s,i]=JS(e,t,n),{command:o,args:a,options:c}=vy._parse(r,s,i),l=Xg(c),u=ab(l);return VS(u),nb(u),QS(u),tS(u),HS(u),u.shell=cc(u.shell),u.env=cb(u),u.killSignal=Hy(u.killSignal),u.forceKillAfterDelay=Yy(u.forceKillAfterDelay),u.lines=u.lines.map((f,d)=>f&&!it.has(u.encoding)&&u.buffer[d]),K.platform==="win32"&&se.basename(o,".exe")==="cmd"&&a.unshift("/q"),{file:o,commandArguments:a,options:u}},ab=({extendEnv:e=!0,preferLocal:t=!1,cwd:n,localDir:r=n,encoding:s="utf8",reject:i=!0,cleanup:o=!0,all:a=!1,windowsHide:c=!0,killSignal:l="SIGTERM",forceKillAfterDelay:u=!0,gracefulCancel:f=!1,ipcInput:d,ipc:p=d!==void 0||f,serialization:h="advanced",...g})=>({...g,extendEnv:e,preferLocal:t,cwd:n,localDirectory:r,encoding:s,reject:i,cleanup:o,all:a,windowsHide:c,killSignal:l,forceKillAfterDelay:u,gracefulCancel:f,ipcInput:d,ipc:p,serialization:h}),cb=({env:e,extendEnv:t,preferLocal:n,node:r,localDirectory:s,nodePath:i})=>{const o=t?{...K.env,...e}:e;return n||r?Oy({env:o,cwd:s,execPath:i,preferLocal:n,addExecPath:r}):o},iu=(e,t,n)=>n.shell&&t.length>0?[[e,...t].join(" "),[],n]:[e,t,n];function gi(e){if(typeof e=="string")return ub(e);if(!(ArrayBuffer.isView(e)&&e.BYTES_PER_ELEMENT===1))throw new Error("Input must be a string or a Uint8Array");return lb(e)}const ub=e=>e.at(-1)===ou?e.slice(0,e.at(-2)===au?-2:-1):e,lb=e=>e.at(-1)===fb?e.subarray(0,e.at(-2)===db?-2:-1):e,ou=`
`,fb=ou.codePointAt(0),au="\r",db=au.codePointAt(0);function ot(e,{checkOpen:t=!0}={}){return e!==null&&typeof e=="object"&&(e.writable||e.readable||!t||e.writable===void 0&&e.readable===void 0)&&typeof e.pipe=="function"}function cu(e,{checkOpen:t=!0}={}){return ot(e,{checkOpen:t})&&(e.writable||!t)&&typeof e.write=="function"&&typeof e.end=="function"&&typeof e.writable=="boolean"&&typeof e.writableObjectMode=="boolean"&&typeof e.destroy=="function"&&typeof e.destroyed=="boolean"}function Zn(e,{checkOpen:t=!0}={}){return ot(e,{checkOpen:t})&&(e.readable||!t)&&typeof e.read=="function"&&typeof e.readable=="boolean"&&typeof e.readableObjectMode=="boolean"&&typeof e.destroy=="function"&&typeof e.destroyed=="boolean"}function uu(e,t){return cu(e,t)&&Zn(e,t)}const hb=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);var Ie,Nt,Ue,_e,Et,lu,fu;class pb{constructor(t,n){X(this,Et);X(this,Ie);X(this,Nt);X(this,Ue,!1);X(this,_e);ne(this,Ie,t),ne(this,Nt,n)}next(){const t=()=>Pt(this,Et,lu).call(this);return ne(this,_e,v(this,_e)?v(this,_e).then(t,t):t()),v(this,_e)}return(t){const n=()=>Pt(this,Et,fu).call(this,t);return v(this,_e)?v(this,_e).then(n,n):n()}}Ie=new WeakMap,Nt=new WeakMap,Ue=new WeakMap,_e=new WeakMap,Et=new WeakSet,lu=async function(){if(v(this,Ue))return{done:!0,value:void 0};let t;try{t=await v(this,Ie).read()}catch(n){throw ne(this,_e,void 0),ne(this,Ue,!0),v(this,Ie).releaseLock(),n}return t.done&&(ne(this,_e,void 0),ne(this,Ue,!0),v(this,Ie).releaseLock()),t},fu=async function(t){if(v(this,Ue))return{done:!0,value:t};if(ne(this,Ue,!0),!v(this,Nt)){const n=v(this,Ie).cancel(t);return v(this,Ie).releaseLock(),await n,{done:!0,value:t}}return v(this,Ie).releaseLock(),{done:!0,value:t}};const mi=Symbol();function du(){return this[mi].next()}Object.defineProperty(du,"name",{value:"next"});function hu(e){return this[mi].return(e)}Object.defineProperty(hu,"name",{value:"return"});const gb=Object.create(hb,{next:{enumerable:!0,configurable:!0,writable:!0,value:du},return:{enumerable:!0,configurable:!0,writable:!0,value:hu}});function mb({preventCancel:e=!1}={}){const t=this.getReader(),n=new pb(t,e),r=Object.create(gb);return r[mi]=n,r}const yb=e=>{if(Zn(e,{checkOpen:!1})&&yi.on!==void 0)return bb(e);if(typeof(e==null?void 0:e[Symbol.asyncIterator])=="function")return e;if(Sb.call(e)==="[object ReadableStream]")return mb.call(e);throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.")},{toString:Sb}=Object.prototype,bb=async function*(e){const t=new AbortController,n={};wb(e,t,n);try{for await(const[r]of yi.on(e,"data",{signal:t.signal}))yield r}catch(r){if(n.error!==void 0)throw n.error;if(!t.signal.aborted)throw r}finally{e.destroy()}},wb=async(e,t,n)=>{try{await yi.finished(e,{cleanup:!0,readable:!0,writable:!1,error:!1})}catch(r){n.error=r}finally{t.abort()}},yi={},Si=async(e,{init:t,convertChunk:n,getSize:r,truncateChunk:s,addChunk:i,getFinalChunk:o,finalize:a},{maxBuffer:c=Number.POSITIVE_INFINITY}={})=>{const l=yb(e),u=t();u.length=0;try{for await(const f of l){const d=Eb(f),p=n[d](f,u);pu({convertedChunk:p,state:u,getSize:r,truncateChunk:s,addChunk:i,maxBuffer:c})}return _b({state:u,convertChunk:n,getSize:r,truncateChunk:s,addChunk:i,getFinalChunk:o,maxBuffer:c}),a(u)}catch(f){const d=typeof f=="object"&&f!==null?f:new Error(f);throw d.bufferedData=a(u),d}},_b=({state:e,getSize:t,truncateChunk:n,addChunk:r,getFinalChunk:s,maxBuffer:i})=>{const o=s(e);o!==void 0&&pu({convertedChunk:o,state:e,getSize:t,truncateChunk:n,addChunk:r,maxBuffer:i})},pu=({convertedChunk:e,state:t,getSize:n,truncateChunk:r,addChunk:s,maxBuffer:i})=>{const o=n(e),a=t.length+o;if(a<=i){Po(e,t,s,a);return}const c=r(e,i-t.length);throw c!==void 0&&Po(c,t,s,i),new er},Po=(e,t,n,r)=>{t.contents=n(e,t,r),t.length=r},Eb=e=>{var r;const t=typeof e;if(t==="string")return"string";if(t!=="object"||e===null)return"others";if((r=globalThis.Buffer)!=null&&r.isBuffer(e))return"buffer";const n=Io.call(e);return n==="[object ArrayBuffer]"?"arrayBuffer":n==="[object DataView]"?"dataView":Number.isInteger(e.byteLength)&&Number.isInteger(e.byteOffset)&&Io.call(e.buffer)==="[object ArrayBuffer]"?"typedArray":"others"},{toString:Io}=Object.prototype;class er extends Error{constructor(){super("maxBuffer exceeded");ct(this,"name","MaxBufferError")}}const Je=e=>e,es=()=>{},gu=({contents:e})=>e,mu=e=>{throw new Error(`Streams in object mode are not supported: ${String(e)}`)},yu=e=>e.length;async function Ab(e,t){return Si(e,Pb,t)}const vb=()=>({contents:[]}),Rb=()=>1,Tb=(e,{contents:t})=>(t.push(e),t),Pb={init:vb,convertChunk:{string:Je,buffer:Je,arrayBuffer:Je,dataView:Je,typedArray:Je,others:Je},getSize:Rb,truncateChunk:es,addChunk:Tb,getFinalChunk:es,finalize:gu};async function Ib(e,t){return Si(e,jb,t)}const Ob=()=>({contents:new ArrayBuffer(0)}),Db=e=>Cb.encode(e),Cb=new TextEncoder,Oo=e=>new Uint8Array(e),Do=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),$b=(e,t)=>e.slice(0,t),xb=(e,{contents:t,length:n},r)=>{const s=bu()?Lb(t,r):Mb(t,r);return new Uint8Array(s).set(e,n),s},Mb=(e,t)=>{if(t<=e.byteLength)return e;const n=new ArrayBuffer(Su(t));return new Uint8Array(n).set(new Uint8Array(e),0),n},Lb=(e,t)=>{if(t<=e.maxByteLength)return e.resize(t),e;const n=new ArrayBuffer(t,{maxByteLength:Su(t)});return new Uint8Array(n).set(new Uint8Array(e),0),n},Su=e=>Co**Math.ceil(Math.log(e)/Math.log(Co)),Co=2,Fb=({contents:e,length:t})=>bu()?e:e.slice(0,t),bu=()=>"resize"in ArrayBuffer.prototype,jb={init:Ob,convertChunk:{string:Db,buffer:Oo,arrayBuffer:Oo,dataView:Do,typedArray:Do,others:mu},getSize:yu,truncateChunk:$b,addChunk:xb,getFinalChunk:es,finalize:Fb};async function Nb(e,t){return Si(e,Gb,t)}const Bb=()=>({contents:"",textDecoder:new TextDecoder}),un=(e,{textDecoder:t})=>t.decode(e,{stream:!0}),kb=(e,{contents:t})=>t+e,Ub=(e,t)=>e.slice(0,t),Hb=({textDecoder:e})=>{const t=e.decode();return t===""?void 0:t},Gb={init:Bb,convertChunk:{string:Je,buffer:un,arrayBuffer:un,dataView:un,typedArray:un,others:mu},getSize:yu,truncateChunk:Ub,addChunk:kb,getFinalChunk:Hb,finalize:gu},Wb=({error:e,stream:t,readableObjectMode:n,lines:r,encoding:s,fdNumber:i})=>{if(!(e instanceof er))throw e;if(i==="all")return e;const o=qb(n,r,s);throw e.maxBufferInfo={fdNumber:i,unit:o},t.destroy(),e},qb=(e,t,n)=>e?"objects":t?"lines":n==="buffer"?"bytes":"characters",Vb=(e,t,n)=>{if(t.length!==n)return;const r=new er;throw r.maxBufferInfo={fdNumber:"ipc"},r},zb=(e,t)=>{const{streamName:n,threshold:r,unit:s}=Kb(e,t);return`Command's ${n} was larger than ${r} ${s}`},Kb=(e,t)=>{if((e==null?void 0:e.maxBufferInfo)===void 0)return{streamName:"output",threshold:t[1],unit:"bytes"};const{maxBufferInfo:{fdNumber:n,unit:r}}=e;delete e.maxBufferInfo;const s=jt(t,n);return n==="ipc"?{streamName:"IPC output",threshold:s,unit:"messages"}:{streamName:pc(n),threshold:s,unit:r}},Yb=(e,t,n)=>(e==null?void 0:e.code)==="ENOBUFS"&&t!==null&&t.some(r=>r!==null&&r.length>bi(n)),Jb=(e,t,n)=>{if(!t)return e;const r=bi(n);return e.length>r?e.slice(0,r):e},bi=([,e])=>e,Qb=({stdio:e,all:t,ipcOutput:n,originalError:r,signal:s,signalDescription:i,exitCode:o,escapedCommand:a,timedOut:c,isCanceled:l,isGracefullyCanceled:u,isMaxBuffer:f,isForcefullyTerminated:d,forceKillAfterDelay:p,killSignal:h,maxBuffer:g,timeout:w,cwd:_})=>{const I=r==null?void 0:r.code,$=Xb({originalError:r,timedOut:c,timeout:w,isMaxBuffer:f,maxBuffer:g,errorCode:I,signal:s,signalDescription:i,exitCode:o,isCanceled:l,isGracefullyCanceled:u,isForcefullyTerminated:d,forceKillAfterDelay:p,killSignal:h}),F=ew(r,_),B=F===void 0?"":`
${F}`,T=`${$}: ${a}${B}`,P=t===void 0?[e[2],e[1]]:[t],b=[T,...P,...e.slice(3),n.map(O=>tw(O)).join(`
`)].map(O=>ei(gi(nw(O)))).filter(Boolean).join(`

`);return{originalMessage:F,shortMessage:T,message:b}},Xb=({originalError:e,timedOut:t,timeout:n,isMaxBuffer:r,maxBuffer:s,errorCode:i,signal:o,signalDescription:a,exitCode:c,isCanceled:l,isGracefullyCanceled:u,isForcefullyTerminated:f,forceKillAfterDelay:d,killSignal:p})=>{const h=Zb(f,d);return t?`Command timed out after ${n} milliseconds${h}`:u?o===void 0?`Command was gracefully canceled with exit code ${c}`:f?`Command was gracefully canceled${h}`:`Command was gracefully canceled with ${o} (${a})`:l?`Command was canceled${h}`:r?`${zb(e,s)}${h}`:i!==void 0?`Command failed with ${i}${h}`:f?`Command was killed with ${p} (${kc(p)})${h}`:o!==void 0?`Command was killed with ${o} (${a})`:c!==void 0?`Command failed with exit code ${c}`:"Command failed"},Zb=(e,t)=>e?` and was forcefully terminated after ${t} milliseconds`:"",ew=(e,t)=>{if(e instanceof Jt)return;const n=Cy(e)?e.originalMessage:String((e==null?void 0:e.message)??e),r=ei(ob(n,t));return r===""?void 0:r},tw=e=>typeof e=="string"?e:pe.inspect(e),nw=e=>Array.isArray(e)?e.map(t=>gi($o(t))).filter(Boolean).join(`
`):$o(e),$o=e=>typeof e=="string"?e:ve(e)?dc(e):"",wu=({command:e,escapedCommand:t,stdio:n,all:r,ipcOutput:s,options:{cwd:i},startTime:o})=>_u({command:e,escapedCommand:t,cwd:i,durationMs:Ec(o),failed:!1,timedOut:!1,isCanceled:!1,isGracefullyCanceled:!1,isTerminated:!1,isMaxBuffer:!1,isForcefullyTerminated:!1,exitCode:0,stdout:n[1],stderr:n[2],all:r,stdio:n,ipcOutput:s,pipedFrom:[]}),wi=({error:e,command:t,escapedCommand:n,fileDescriptors:r,options:s,startTime:i,isSync:o})=>_i({error:e,command:t,escapedCommand:n,startTime:i,timedOut:!1,isCanceled:!1,isGracefullyCanceled:!1,isMaxBuffer:!1,isForcefullyTerminated:!1,stdio:Array.from({length:r.length}),ipcOutput:[],options:s,isSync:o}),_i=({error:e,command:t,escapedCommand:n,startTime:r,timedOut:s,isCanceled:i,isGracefullyCanceled:o,isMaxBuffer:a,isForcefullyTerminated:c,exitCode:l,signal:u,stdio:f,all:d,ipcOutput:p,options:{timeoutDuration:h,timeout:g=h,forceKillAfterDelay:w,killSignal:_,cwd:I,maxBuffer:$},isSync:F})=>{const{exitCode:B,signal:T,signalDescription:P}=sw(l,u),{originalMessage:b,shortMessage:O,message:k}=Qb({stdio:f,all:d,ipcOutput:p,originalError:e,signal:T,signalDescription:P,exitCode:B,escapedCommand:n,timedOut:s,isCanceled:i,isGracefullyCanceled:o,isMaxBuffer:a,isForcefullyTerminated:c,forceKillAfterDelay:w,killSignal:_,maxBuffer:$,timeout:g,cwd:I}),S=Dy(e,k,F);return Object.assign(S,rw({error:S,command:t,escapedCommand:n,startTime:r,timedOut:s,isCanceled:i,isGracefullyCanceled:o,isMaxBuffer:a,isForcefullyTerminated:c,exitCode:B,signal:T,signalDescription:P,stdio:f,all:d,ipcOutput:p,cwd:I,originalMessage:b,shortMessage:O})),S},rw=({error:e,command:t,escapedCommand:n,startTime:r,timedOut:s,isCanceled:i,isGracefullyCanceled:o,isMaxBuffer:a,isForcefullyTerminated:c,exitCode:l,signal:u,signalDescription:f,stdio:d,all:p,ipcOutput:h,cwd:g,originalMessage:w,shortMessage:_})=>{var I;return _u({shortMessage:_,originalMessage:w,command:t,escapedCommand:n,cwd:g,durationMs:Ec(r),failed:!0,timedOut:s,isCanceled:i,isGracefullyCanceled:o,isTerminated:u!==void 0,isMaxBuffer:a,isForcefullyTerminated:c,exitCode:l,signal:u,signalDescription:f,code:(I=e.cause)==null?void 0:I.code,stdout:d[1],stderr:d[2],all:p,stdio:d,ipcOutput:h,pipedFrom:[]})},_u=e=>Object.fromEntries(Object.entries(e).filter(([,t])=>t!==void 0)),sw=(e,t)=>{const n=e===null?void 0:e,r=t===null?void 0:t,s=r===void 0?void 0:kc(t);return{exitCode:n,signal:r,signalDescription:s}},xo=e=>Number.isFinite(e)?e:0;function iw(e){return{days:Math.trunc(e/864e5),hours:Math.trunc(e/36e5%24),minutes:Math.trunc(e/6e4%60),seconds:Math.trunc(e/1e3%60),milliseconds:Math.trunc(e%1e3),microseconds:Math.trunc(xo(e*1e3)%1e3),nanoseconds:Math.trunc(xo(e*1e6)%1e3)}}function ow(e){return{days:e/86400000n,hours:e/3600000n%24n,minutes:e/60000n%60n,seconds:e/1000n%60n,milliseconds:e%1000n,microseconds:0n,nanoseconds:0n}}function aw(e){switch(typeof e){case"number":{if(Number.isFinite(e))return iw(e);break}case"bigint":return ow(e)}throw new TypeError("Expected a finite number or bigint")}const cw=e=>e===0||e===0n,uw=(e,t)=>t===1||t===1n?e:`${e}s`,lw=1e-7,fw=24n*60n*60n*1000n;function dw(e,t){const n=typeof e=="bigint";if(!n&&!Number.isFinite(e))throw new TypeError("Expected a finite number or bigint");t={...t};const r=e<0?"-":"";e=e<0?-e:e,t.colonNotation&&(t.compact=!1,t.formatSubMilliseconds=!1,t.separateMilliseconds=!1,t.verbose=!1),t.compact&&(t.unitCount=1,t.secondsDecimalDigits=0,t.millisecondsDecimalDigits=0);let s=[];const i=(u,f)=>{const d=Math.floor(u*10**f+lw);return(Math.round(d)/10**f).toFixed(f)},o=(u,f,d,p)=>{if(!((s.length===0||!t.colonNotation)&&cw(u)&&!(t.colonNotation&&d==="m"))){if(p??(p=String(u)),t.colonNotation){const h=p.includes(".")?p.split(".")[0].length:p.length,g=s.length>0?2:1;p="0".repeat(Math.max(0,g-h))+p}else p+=t.verbose?" "+uw(f,u):d;s.push(p)}},a=aw(e),c=BigInt(a.days);if(t.hideYearAndDays?o(BigInt(c)*24n+BigInt(a.hours),"hour","h"):(t.hideYear?o(c,"day","d"):(o(c/365n,"year","y"),o(c%365n,"day","d")),o(Number(a.hours),"hour","h")),o(Number(a.minutes),"minute","m"),!t.hideSeconds)if(t.separateMilliseconds||t.formatSubMilliseconds||!t.colonNotation&&e<1e3&&!t.subSecondsAsDecimals){const u=Number(a.seconds),f=Number(a.milliseconds),d=Number(a.microseconds),p=Number(a.nanoseconds);if(o(u,"second","s"),t.formatSubMilliseconds)o(f,"millisecond","ms"),o(d,"microsecond","Âµs"),o(p,"nanosecond","ns");else{const h=f+d/1e3+p/1e6,g=typeof t.millisecondsDecimalDigits=="number"?t.millisecondsDecimalDigits:0,w=h>=1?Math.round(h):Math.ceil(h),_=g?h.toFixed(g):w;o(Number.parseFloat(_),"millisecond","ms",_)}}else{const u=(n?Number(e%fw):e)/1e3%60,f=typeof t.secondsDecimalDigits=="number"?t.secondsDecimalDigits:1,d=i(u,f),p=t.keepDecimalsOnWholeSeconds?d:d.replace(/\.0+$/,"");o(Number.parseFloat(p),"second","s",p)}if(s.length===0)return r+"0"+(t.verbose?" milliseconds":"ms");const l=t.colonNotation?":":" ";return typeof t.unitCount=="number"&&(s=s.slice(0,Math.max(t.unitCount,1))),r+s.join(l)}const hw=(e,t)=>{e.failed&&Yt({type:"error",verboseMessage:e.shortMessage,verboseInfo:t,result:e})},pw=(e,t)=>{Js(t)&&(hw(e,t),gw(e,t))},gw=(e,t)=>{const n=`(done in ${dw(e.durationMs)})`;Yt({type:"duration",verboseMessage:n,verboseInfo:t,result:e})},Ei=(e,t,{reject:n})=>{if(pw(e,t),e.failed&&n)throw e;return e},mw=(e,t)=>wt(e)?"asyncGenerator":vu(e)?"generator":Ai(e)?"fileUrl":Ew(e)?"filePath":Tw(e)?"webStream":ot(e,{checkOpen:!1})?"native":ve(e)?"uint8Array":Pw(e)?"asyncIterable":Iw(e)?"iterable":Ri(e)?Eu({},t):ww(e)?yw(e,t):"native",yw=(e,t)=>uu(e.transform,{checkOpen:!1})?Sw(e,t):Ri(e.transform)?Eu(e,t):bw(e,t),Sw=(e,t)=>(Au(e,t,"Duplex stream"),"duplex"),Eu=(e,t)=>(Au(e,t,"web TransformStream"),"webTransform"),Au=({final:e,binary:t,objectMode:n},r,s)=>{Mo(e,`${r}.final`,s),Mo(t,`${r}.binary`,s),ts(n,`${r}.objectMode`)},Mo=(e,t,n)=>{if(e!==void 0)throw new TypeError(`The \`${t}\` option can only be defined when using a generator, not a ${n}.`)},bw=({transform:e,final:t,binary:n,objectMode:r},s)=>{if(e!==void 0&&!Lo(e))throw new TypeError(`The \`${s}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);if(uu(t,{checkOpen:!1}))throw new TypeError(`The \`${s}.final\` option must not be a Duplex stream.`);if(Ri(t))throw new TypeError(`The \`${s}.final\` option must not be a web TransformStream.`);if(t!==void 0&&!Lo(t))throw new TypeError(`The \`${s}.final\` option must be a generator.`);return ts(n,`${s}.binary`),ts(r,`${s}.objectMode`),wt(e)||wt(t)?"asyncGenerator":"generator"},ts=(e,t)=>{if(e!==void 0&&typeof e!="boolean")throw new TypeError(`The \`${t}\` option must use a boolean.`)},Lo=e=>wt(e)||vu(e),wt=e=>Object.prototype.toString.call(e)==="[object AsyncGeneratorFunction]",vu=e=>Object.prototype.toString.call(e)==="[object GeneratorFunction]",ww=e=>be(e)&&(e.transform!==void 0||e.final!==void 0),Ai=e=>Object.prototype.toString.call(e)==="[object URL]",_w=e=>Ai(e)&&e.protocol!=="file:",Ew=e=>be(e)&&Object.keys(e).length>0&&Object.keys(e).every(t=>Aw.has(t))&&Ru(e.file),Aw=new Set(["file","append"]),Ru=e=>typeof e=="string",vw=(e,t)=>e==="native"&&typeof t=="string"&&!Rw.has(t),Rw=new Set(["ipc","ignore","inherit","overlapped","pipe"]),Tu=e=>Object.prototype.toString.call(e)==="[object ReadableStream]",vi=e=>Object.prototype.toString.call(e)==="[object WritableStream]",Tw=e=>Tu(e)||vi(e),Ri=e=>Tu(e==null?void 0:e.readable)&&vi(e==null?void 0:e.writable),Pw=e=>Pu(e)&&typeof e[Symbol.asyncIterator]=="function",Iw=e=>Pu(e)&&typeof e[Symbol.iterator]=="function",Pu=e=>typeof e=="object"&&e!==null,st=new Set(["generator","asyncGenerator","duplex","webTransform"]),Iu=new Set(["fileUrl","filePath","fileNumber"]),Ou=new Set(["fileUrl","filePath"]),Ow=new Set([...Ou,"webStream","nodeStream"]),Dw=new Set(["webTransform","duplex"]),tr={generator:"a generator",asyncGenerator:"an async generator",fileUrl:"a file URL",filePath:"a file path string",fileNumber:"a file descriptor number",webStream:"a web stream",nodeStream:"a Node.js stream",webTransform:"a web TransformStream",duplex:"a Duplex stream",native:"any value",iterable:"an iterable",asyncIterable:"an async iterable",string:"a string",uint8Array:"a Uint8Array"},Du=(e,t,n,r)=>r==="output"?Cw(e,t,n):$w(e,t,n),Cw=(e,t,n)=>{const r=t!==0&&n[t-1].value.readableObjectMode;return{writableObjectMode:r,readableObjectMode:e??r}},$w=(e,t,n)=>{const r=t===0?e===!0:n[t-1].value.readableObjectMode,s=t!==n.length-1&&(e??r);return{writableObjectMode:r,readableObjectMode:s}},xw=(e,t)=>{const n=e.findLast(({type:r})=>st.has(r));return n===void 0?!1:t==="input"?n.value.writableObjectMode:n.value.readableObjectMode},Mw=(e,t,n,r)=>[...e.filter(({type:s})=>!st.has(s)),...Lw(e,t,n,r)],Lw=(e,t,n,{encoding:r})=>{const s=e.filter(({type:o})=>st.has(o)),i=Array.from({length:s.length});for(const[o,a]of Object.entries(s))i[o]=Fw({stdioItem:a,index:Number(o),newTransforms:i,optionName:t,direction:n,encoding:r});return kw(i,n)},Fw=({stdioItem:e,stdioItem:{type:t},index:n,newTransforms:r,optionName:s,direction:i,encoding:o})=>t==="duplex"?jw({stdioItem:e,optionName:s}):t==="webTransform"?Nw({stdioItem:e,index:n,newTransforms:r,direction:i}):Bw({stdioItem:e,index:n,newTransforms:r,direction:i,encoding:o}),jw=({stdioItem:e,stdioItem:{value:{transform:t,transform:{writableObjectMode:n,readableObjectMode:r},objectMode:s=r}},optionName:i})=>{if(s&&!r)throw new TypeError(`The \`${i}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);if(!s&&r)throw new TypeError(`The \`${i}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);return{...e,value:{transform:t,writableObjectMode:n,readableObjectMode:r}}},Nw=({stdioItem:e,stdioItem:{value:t},index:n,newTransforms:r,direction:s})=>{const{transform:i,objectMode:o}=be(t)?t:{transform:t},{writableObjectMode:a,readableObjectMode:c}=Du(o,n,r,s);return{...e,value:{transform:i,writableObjectMode:a,readableObjectMode:c}}},Bw=({stdioItem:e,stdioItem:{value:t},index:n,newTransforms:r,direction:s,encoding:i})=>{const{transform:o,final:a,binary:c=!1,preserveNewlines:l=!1,objectMode:u}=be(t)?t:{transform:t},f=c||it.has(i),{writableObjectMode:d,readableObjectMode:p}=Du(u,n,r,s);return{...e,value:{transform:o,final:a,binary:f,preserveNewlines:l,writableObjectMode:d,readableObjectMode:p}}},kw=(e,t)=>t==="input"?e.reverse():e,Uw=(e,t,n)=>{const r=e.map(s=>Hw(s,t));if(r.includes("input")&&r.includes("output"))throw new TypeError(`The \`${n}\` option must not be an array of both readable and writable values.`);return r.find(Boolean)??qw},Hw=({type:e,value:t},n)=>Gw[n]??Cu[e](t),Gw=["input","output","output"],lt=()=>{},Ar=()=>"input",Cu={generator:lt,asyncGenerator:lt,fileUrl:lt,filePath:lt,iterable:Ar,asyncIterable:Ar,uint8Array:Ar,webStream:e=>vi(e)?"output":"input",nodeStream(e){return Zn(e,{checkOpen:!1})?cu(e,{checkOpen:!1})?void 0:"input":"output"},webTransform:lt,duplex:lt,native(e){const t=Ww(e);if(t!==void 0)return t;if(ot(e,{checkOpen:!1}))return Cu.nodeStream(e)}},Ww=e=>{if([0,K.stdin].includes(e))return"input";if([1,2,K.stdout,K.stderr].includes(e))return"output"},qw="output",Vw=(e,t)=>t&&!e.includes("ipc")?[...e,"ipc"]:e,zw=({stdio:e,ipc:t,buffer:n,...r},s,i)=>{const o=Kw(e,r).map((a,c)=>$u(a,c));return i?Jw(o,n,s):Vw(o,t)},Kw=(e,t)=>{if(e===void 0)return Me.map(r=>t[r]);if(Yw(t))throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${Me.map(r=>`\`${r}\``).join(", ")}`);if(typeof e=="string")return[e,e,e];if(!Array.isArray(e))throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof e}\``);const n=Math.max(e.length,Me.length);return Array.from({length:n},(r,s)=>e[s])},Yw=e=>Me.some(t=>e[t]!==void 0),$u=(e,t)=>Array.isArray(e)?e.map(n=>$u(n,t)):e??(t>=Me.length?"ignore":"pipe"),Jw=(e,t,n)=>e.map((r,s)=>!t[s]&&s!==0&&!Qs(n,s)&&Qw(r)?"ignore":r),Qw=e=>e==="pipe"||Array.isArray(e)&&e.every(t=>t==="pipe"),Xw=({stdioItem:e,stdioItem:{type:t},isStdioArray:n,fdNumber:r,direction:s,isSync:i})=>!n||t!=="native"?e:i?Zw({stdioItem:e,fdNumber:r,direction:s}):n_({stdioItem:e,fdNumber:r}),Zw=({stdioItem:e,stdioItem:{value:t,optionName:n},fdNumber:r,direction:s})=>{const i=e_({value:t,optionName:n,fdNumber:r,direction:s});if(i!==void 0)return i;if(ot(t,{checkOpen:!1}))throw new TypeError(`The \`${n}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);return e},e_=({value:e,optionName:t,fdNumber:n,direction:r})=>{const s=t_(e,n);if(s!==void 0){if(r==="output")return{type:"fileNumber",value:s,optionName:t};if(hn.isatty(s))throw new TypeError(`The \`${t}: ${Jr(e)}\` option is invalid: it cannot be a TTY with synchronous methods.`);return{type:"uint8Array",value:Ft(Ce.readFileSync(s)),optionName:t}}},t_=(e,t)=>{if(e==="inherit")return t;if(typeof e=="number")return e;const n=Ys.indexOf(e);if(n!==-1)return n},n_=({stdioItem:e,stdioItem:{value:t,optionName:n},fdNumber:r})=>t==="inherit"?{type:"nodeStream",value:Fo(r,t,n),optionName:n}:typeof t=="number"?{type:"nodeStream",value:Fo(t,t,n),optionName:n}:ot(t,{checkOpen:!1})?{type:"nodeStream",value:t,optionName:n}:e,Fo=(e,t,n)=>{const r=Ys[e];if(r===void 0)throw new TypeError(`The \`${n}: ${t}\` option is invalid: no such standard stream.`);return r},r_=({input:e,inputFile:t},n)=>n===0?[...s_(e),...o_(t)]:[],s_=e=>e===void 0?[]:[{type:i_(e),value:e,optionName:"input"}],i_=e=>{if(Zn(e,{checkOpen:!1}))return"nodeStream";if(typeof e=="string")return"string";if(ve(e))return"uint8Array";throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.")},o_=e=>e===void 0?[]:[{...a_(e),optionName:"inputFile"}],a_=e=>{if(Ai(e))return{type:"fileUrl",value:e};if(Ru(e))return{type:"filePath",value:{file:e}};throw new Error("The `inputFile` option must be a file path string or a file URL.")},c_=e=>e.filter((t,n)=>e.every((r,s)=>t.value!==r.value||n>=s||t.type==="generator"||t.type==="asyncGenerator")),u_=({stdioItem:{type:e,value:t,optionName:n},direction:r,fileDescriptors:s,isSync:i})=>{const o=l_(s,e);if(o.length!==0){if(i){f_({otherStdioItems:o,type:e,value:t,optionName:n,direction:r});return}if(Ow.has(e))return xu({otherStdioItems:o,type:e,value:t,optionName:n,direction:r});Dw.has(e)&&h_({otherStdioItems:o,type:e,value:t,optionName:n})}},l_=(e,t)=>e.flatMap(({direction:n,stdioItems:r})=>r.filter(s=>s.type===t).map(s=>({...s,direction:n}))),f_=({otherStdioItems:e,type:t,value:n,optionName:r,direction:s})=>{Ou.has(t)&&xu({otherStdioItems:e,type:t,value:n,optionName:r,direction:s})},xu=({otherStdioItems:e,type:t,value:n,optionName:r,direction:s})=>{const i=e.filter(a=>d_(a,n));if(i.length===0)return;const o=i.find(a=>a.direction!==s);return Mu(o,r,t),s==="output"?i[0].stream:void 0},d_=({type:e,value:t},n)=>e==="filePath"?t.file===n.file:e==="fileUrl"?t.href===n.href:t===n,h_=({otherStdioItems:e,type:t,value:n,optionName:r})=>{const s=e.find(({value:{transform:i}})=>i===n.transform);Mu(s,r,t)},Mu=(e,t,n)=>{if(e!==void 0)throw new TypeError(`The \`${e.optionName}\` and \`${t}\` options must not target ${tr[n]} that is the same.`)},Lu=(e,t,n,r)=>{const i=zw(t,n,r).map((a,c)=>p_({stdioOption:a,fdNumber:c,options:t,isSync:r})),o=E_({initialFileDescriptors:i,addProperties:e,options:t,isSync:r});return t.stdio=o.map(({stdioItems:a})=>R_(a)),o},p_=({stdioOption:e,fdNumber:t,options:n,isSync:r})=>{const s=pc(t),{stdioItems:i,isStdioArray:o}=g_({stdioOption:e,fdNumber:t,options:n,optionName:s}),a=Uw(i,t,s),c=i.map(f=>Xw({stdioItem:f,isStdioArray:o,fdNumber:t,direction:a,isSync:r})),l=Mw(c,s,a,n),u=xw(l,a);return __(l,u),{direction:a,objectMode:u,stdioItems:l}},g_=({stdioOption:e,fdNumber:t,options:n,optionName:r})=>{const i=[...(Array.isArray(e)?e:[e]).map(c=>m_(c,r)),...r_(n,t)],o=c_(i),a=o.length>1;return y_(o,a,r),b_(o),{stdioItems:o,isStdioArray:a}},m_=(e,t)=>({type:mw(e,t),value:e,optionName:t}),y_=(e,t,n)=>{if(e.length===0)throw new TypeError(`The \`${n}\` option must not be an empty array.`);if(t){for(const{value:r,optionName:s}of e)if(S_.has(r))throw new Error(`The \`${s}\` option must not include \`${r}\`.`)}},S_=new Set(["ignore","ipc"]),b_=e=>{for(const t of e)w_(t)},w_=({type:e,value:t,optionName:n})=>{if(_w(t))throw new TypeError(`The \`${n}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);if(vw(e,t))throw new TypeError(`The \`${n}: { file: '...' }\` option must be used instead of \`${n}: '...'\`.`)},__=(e,t)=>{if(!t)return;const n=e.find(({type:r})=>Iu.has(r));if(n!==void 0)throw new TypeError(`The \`${n.optionName}\` option cannot use both files and transforms in objectMode.`)},E_=({initialFileDescriptors:e,addProperties:t,options:n,isSync:r})=>{const s=[];try{for(const i of e)s.push(A_({fileDescriptor:i,fileDescriptors:s,addProperties:t,options:n,isSync:r}));return s}catch(i){throw Fu(s),i}},A_=({fileDescriptor:{direction:e,objectMode:t,stdioItems:n},fileDescriptors:r,addProperties:s,options:i,isSync:o})=>{const a=n.map(c=>v_({stdioItem:c,addProperties:s,direction:e,options:i,fileDescriptors:r,isSync:o}));return{direction:e,objectMode:t,stdioItems:a}},v_=({stdioItem:e,addProperties:t,direction:n,options:r,fileDescriptors:s,isSync:i})=>{const o=u_({stdioItem:e,direction:n,fileDescriptors:s,isSync:i});return o!==void 0?{...e,stream:o}:{...e,...t[n][e.type](e,r)}},Fu=e=>{for(const{stdioItems:t}of e)for(const{stream:n}of t)n!==void 0&&!nt(n)&&n.destroy()},R_=e=>{if(e.length>1)return e.some(({value:r})=>r==="overlapped")?"overlapped":"pipe";const[{type:t,value:n}]=e;return t==="native"?n:"pipe"},T_=(e,t)=>Lu(I_,e,t,!0),Oe=({type:e,optionName:t})=>{ju(t,tr[e])},P_=({optionName:e,value:t})=>((t==="ipc"||t==="overlapped")&&ju(e,`"${t}"`),{}),ju=(e,t)=>{throw new TypeError(`The \`${e}\` option cannot be ${t} with synchronous methods.`)},jo={generator(){},asyncGenerator:Oe,webStream:Oe,nodeStream:Oe,webTransform:Oe,duplex:Oe,asyncIterable:Oe,native:P_},I_={input:{...jo,fileUrl:({value:e})=>({contents:[Ft(Ce.readFileSync(e))]}),filePath:({value:{file:e}})=>({contents:[Ft(Ce.readFileSync(e))]}),fileNumber:Oe,iterable:({value:e})=>({contents:[...e]}),string:({value:e})=>({contents:[e]}),uint8Array:({value:e})=>({contents:[e]})},output:{...jo,fileUrl:({value:e})=>({path:e}),filePath:({value:{file:e,append:t}})=>({path:e,append:t}),fileNumber:({value:e})=>({path:e}),iterable:Oe,string:Oe,uint8Array:Oe}},_t=(e,{stripFinalNewline:t},n)=>Nu(t,n)&&e!==void 0&&!Array.isArray(e)?gi(e):e,Nu=(e,t)=>t==="all"?e[1]||e[2]:e[t],Bu=(e,t,n,r)=>e||n?void 0:Uu(t,r),ku=(e,t,n)=>n?e.flatMap(r=>No(r,t)):No(e,t),No=(e,t)=>{const{transform:n,final:r}=Uu(t,{});return[...n(e),...r()]},Uu=(e,t)=>(t.previousChunks="",{transform:O_.bind(void 0,t,e),final:C_.bind(void 0,t)}),O_=function*(e,t,n){if(typeof n!="string"){yield n;return}let{previousChunks:r}=e,s=-1;for(let i=0;i<n.length;i+=1)if(n[i]===`
`){const o=D_(n,i,t,e);let a=n.slice(s+1,i+1-o);r.length>0&&(a=ns(r,a),r=""),yield a,s=i}s!==n.length-1&&(r=ns(r,n.slice(s+1))),e.previousChunks=r},D_=(e,t,n,r)=>n?0:(r.isWindowsNewline=t!==0&&e[t-1]==="\r",r.isWindowsNewline?2:1),C_=function*({previousChunks:e}){e.length>0&&(yield e)},$_=({binary:e,preserveNewlines:t,readableObjectMode:n,state:r})=>e||t||n?void 0:{transform:x_.bind(void 0,r)},x_=function*({isWindowsNewline:e=!1},t){const{unixNewline:n,windowsNewline:r,LF:s,concatBytes:i}=typeof t=="string"?M_:F_;if(t.at(-1)===s){yield t;return}yield i(t,e?r:n)},ns=(e,t)=>`${e}${t}`,M_={windowsNewline:`\r
`,unixNewline:`
`,LF:`
`,concatBytes:ns},L_=(e,t)=>{const n=new Uint8Array(e.length+t.length);return n.set(e,0),n.set(t,e.length),n},F_={windowsNewline:new Uint8Array([13,10]),unixNewline:new Uint8Array([10]),LF:10,concatBytes:L_},j_=(e,t)=>e?void 0:N_.bind(void 0,t),N_=function*(e,t){if(typeof t!="string"&&!ve(t)&&!ys.Buffer.isBuffer(t))throw new TypeError(`The \`${e}\` option's transform must use "objectMode: true" to receive as input: ${typeof t}.`);yield t},B_=(e,t)=>e?k_.bind(void 0,t):U_.bind(void 0,t),k_=function*(e,t){Hu(e,t),yield t},U_=function*(e,t){if(Hu(e,t),typeof t!="string"&&!ve(t))throw new TypeError(`The \`${e}\` option's function must yield a string or an Uint8Array, not ${typeof t}.`);yield t},Hu=(e,t)=>{if(t==null)throw new TypeError(`The \`${e}\` option's function must not call \`yield ${t}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`)},Gu=(e,t,n)=>{if(n)return;if(e)return{transform:H_.bind(void 0,new TextEncoder)};const r=new fa.StringDecoder(t);return{transform:G_.bind(void 0,r),final:W_.bind(void 0,r)}},H_=function*(e,t){ys.Buffer.isBuffer(t)?yield Ft(t):typeof t=="string"?yield e.encode(t):yield t},G_=function*(e,t){yield ve(t)?e.write(t):t},W_=function*(e){const t=e.end();t!==""&&(yield t)},Bo=pe.callbackify(async(e,t,n,r)=>{t.currentIterable=e(...n);try{for await(const s of t.currentIterable)r.push(s)}finally{delete t.currentIterable}}),Ti=async function*(e,t,n){if(n===t.length){yield e;return}const{transform:r=K_}=t[n];for await(const s of r(e))yield*Ti(s,t,n+1)},q_=async function*(e){for(const[t,{final:n}]of Object.entries(e))yield*V_(n,Number(t),e)},V_=async function*(e,t,n){if(e!==void 0)for await(const r of e())yield*Ti(r,n,t+1)},z_=pe.callbackify(async({currentIterable:e},t)=>{if(e!==void 0){await(t?e.throw(t):e.return());return}if(t)throw t}),K_=function*(e){yield e},ko=(e,t,n,r)=>{try{for(const s of e(...t))n.push(s);r()}catch(s){r(s)}},Y_=(e,t)=>[...t.flatMap(n=>[...Xt(n,e,0)]),...Pi(e)],Xt=function*(e,t,n){if(n===t.length){yield e;return}const{transform:r=Q_}=t[n];for(const s of r(e))yield*Xt(s,t,n+1)},Pi=function*(e){for(const[t,{final:n}]of Object.entries(e))yield*J_(n,Number(t),e)},J_=function*(e,t,n){if(e!==void 0)for(const r of e())yield*Xt(r,n,t+1)},Q_=function*(e){yield e},Uo=({value:e,value:{transform:t,final:n,writableObjectMode:r,readableObjectMode:s},optionName:i},{encoding:o})=>{const a={},c=qu(e,o,i),l=wt(t),u=wt(n),f=l?Bo.bind(void 0,Ti,a):ko.bind(void 0,Xt),d=l||u?Bo.bind(void 0,q_,a):ko.bind(void 0,Pi),p=l||u?z_.bind(void 0,a):void 0;return{stream:new ee.Transform({writableObjectMode:r,writableHighWaterMark:ee.getDefaultHighWaterMark(r),readableObjectMode:s,readableHighWaterMark:ee.getDefaultHighWaterMark(s),transform(g,w,_){f([g,c,0],this,_)},flush(g){d([c],this,g)},destroy:p})}},Wu=(e,t,n,r)=>{const s=t.filter(({type:o})=>o==="generator"),i=r?s.reverse():s;for(const{value:o,optionName:a}of i){const c=qu(o,n,a);e=Y_(c,e)}return e},qu=({transform:e,final:t,binary:n,writableObjectMode:r,readableObjectMode:s,preserveNewlines:i},o,a)=>{const c={};return[{transform:j_(r,a)},Gu(n,o,r),Bu(n,i,r,c),{transform:e,final:t},{transform:B_(s,a)},$_({binary:n,preserveNewlines:i,readableObjectMode:s,state:c})].filter(Boolean)},X_=(e,t)=>{for(const n of Z_(e))eE(e,n,t)},Z_=e=>new Set(Object.entries(e).filter(([,{direction:t}])=>t==="input").map(([t])=>Number(t))),eE=(e,t,n)=>{const{stdioItems:r}=e[t],s=r.filter(({contents:a})=>a!==void 0);if(s.length===0)return;if(t!==0){const[{type:a,optionName:c}]=s;throw new TypeError(`Only the \`stdin\` option, not \`${c}\`, can be ${tr[a]} with synchronous methods.`)}const o=s.map(({contents:a})=>a).map(a=>tE(a,r));n.input=Ks(o)},tE=(e,t)=>{const n=Wu(e,t,"utf8",!0);return nE(n),Ks(n)},nE=e=>{const t=e.find(n=>typeof n!="string"&&!ve(n));if(t!==void 0)throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${t}.`)},Vu=({stdioItems:e,encoding:t,verboseInfo:n,fdNumber:r})=>r!=="all"&&Qs(n,r)&&!it.has(t)&&rE(r)&&(e.some(({type:s,value:i})=>s==="native"&&sE.has(i))||e.every(({type:s})=>st.has(s))),rE=e=>e===1||e===2,sE=new Set(["pipe","overlapped"]),iE=async(e,t,n,r)=>{for await(const s of e)aE(t)||zu(s,n,r)},oE=(e,t,n)=>{for(const r of e)zu(r,t,n)},aE=e=>e._readableState.pipes.length>0,zu=(e,t,n)=>{const r=wc(e);Yt({type:"output",verboseMessage:r,fdNumber:t,verboseInfo:n})},cE=({fileDescriptors:e,syncResult:{output:t},options:n,isMaxBuffer:r,verboseInfo:s})=>{if(t===null)return{output:Array.from({length:3})};const i={},o=new Set([]);return{output:t.map((c,l)=>uE({result:c,fileDescriptors:e,fdNumber:l,state:i,outputFiles:o,isMaxBuffer:r,verboseInfo:s},n)),...i}},uE=({result:e,fileDescriptors:t,fdNumber:n,state:r,outputFiles:s,isMaxBuffer:i,verboseInfo:o},{buffer:a,encoding:c,lines:l,stripFinalNewline:u,maxBuffer:f})=>{if(e===null)return;const d=Jb(e,i,f),p=Ft(d),{stdioItems:h,objectMode:g}=t[n],w=lE([p],h,c,r),{serializedResult:_,finalResult:I=_}=fE({chunks:w,objectMode:g,encoding:c,lines:l,stripFinalNewline:u,fdNumber:n});dE({serializedResult:_,fdNumber:n,state:r,verboseInfo:o,encoding:c,stdioItems:h,objectMode:g});const $=a[n]?I:void 0;try{return r.error===void 0&&hE(_,h,s),$}catch(F){return r.error=F,$}},lE=(e,t,n,r)=>{try{return Wu(e,t,n,!1)}catch(s){return r.error=s,e}},fE=({chunks:e,objectMode:t,encoding:n,lines:r,stripFinalNewline:s,fdNumber:i})=>{if(t)return{serializedResult:e};if(n==="buffer")return{serializedResult:Ks(e)};const o=Hg(e,n);return r[i]?{serializedResult:o,finalResult:ku(o,!s[i],t)}:{serializedResult:o}},dE=({serializedResult:e,fdNumber:t,state:n,verboseInfo:r,encoding:s,stdioItems:i,objectMode:o})=>{if(!Vu({stdioItems:i,encoding:s,verboseInfo:r,fdNumber:t}))return;const a=ku(e,!1,o);try{oE(a,t,r)}catch(c){n.error??(n.error=c)}},hE=(e,t,n)=>{for(const{path:r,append:s}of t.filter(({type:i})=>Iu.has(i))){const i=typeof r=="string"?r:r.toString();s||n.has(i)?Ce.appendFileSync(r,e):(n.add(i),Ce.writeFileSync(r,e))}},pE=([,e,t],n)=>{if(n.all)return e===void 0?t:t===void 0?e:Array.isArray(e)?Array.isArray(t)?[...e,...t]:[...e,_t(t,n,"all")]:Array.isArray(t)?[_t(e,n,"all"),...t]:ve(e)&&ve(t)?hc([e,t]):`${e}${t}`},gE=async(e,t)=>{const[n,r]=await mE(e);return t.isForcefullyTerminated??(t.isForcefullyTerminated=!1),[n,r]},mE=async e=>{const[t,n]=await Promise.allSettled([Y.once(e,"spawn"),Y.once(e,"exit")]);return t.status==="rejected"?[]:n.status==="rejected"?Ku(e):n.value},Ku=async e=>{try{return await Y.once(e,"exit")}catch{return Ku(e)}},yE=async e=>{const[t,n]=await e;if(!SE(t,n)&&Yu(t,n))throw new Jt;return[t,n]},SE=(e,t)=>e===void 0&&t===void 0,Yu=(e,t)=>e!==0||t!==null,bE=({error:e,status:t,signal:n,output:r},{maxBuffer:s})=>{const i=wE(e,t,n),o=(i==null?void 0:i.code)==="ETIMEDOUT",a=Yb(i,r,s);return{resultError:i,exitCode:t,signal:n,timedOut:o,isMaxBuffer:a}},wE=(e,t,n)=>e!==void 0?e:Yu(t,n)?new Jt:void 0,_E=(e,t,n)=>{const{file:r,commandArguments:s,command:i,escapedCommand:o,startTime:a,verboseInfo:c,options:l,fileDescriptors:u}=EE(e,t,n),f=RE({file:r,commandArguments:s,options:l,command:i,escapedCommand:o,verboseInfo:c,fileDescriptors:u,startTime:a});return Ei(f,c,l)},EE=(e,t,n)=>{const{command:r,escapedCommand:s,startTime:i,verboseInfo:o}=Ac(e,t,n),a=AE(n),{file:c,commandArguments:l,options:u}=su(e,t,a);vE(u);const f=T_(u,o);return{file:c,commandArguments:l,command:r,escapedCommand:s,startTime:i,verboseInfo:o,options:u,fileDescriptors:f}},AE=e=>e.node&&!e.ipc?{...e,ipc:!1}:e,vE=({ipc:e,ipcInput:t,detached:n,cancelSignal:r})=>{t&&ln("ipcInput"),e&&ln("ipc: true"),n&&ln("detached: true"),r&&ln("cancelSignal")},ln=e=>{throw new TypeError(`The "${e}" option cannot be used with synchronous methods.`)},RE=({file:e,commandArguments:t,options:n,command:r,escapedCommand:s,verboseInfo:i,fileDescriptors:o,startTime:a})=>{const c=TE({file:e,commandArguments:t,options:n,command:r,escapedCommand:s,fileDescriptors:o,startTime:a});if(c.failed)return c;const{resultError:l,exitCode:u,signal:f,timedOut:d,isMaxBuffer:p}=bE(c,n),{output:h,error:g=l}=cE({fileDescriptors:o,syncResult:c,options:n,isMaxBuffer:p,verboseInfo:i}),w=h.map((I,$)=>_t(I,n,$)),_=_t(pE(h,n),n,"all");return IE({error:g,exitCode:u,signal:f,timedOut:d,isMaxBuffer:p,stdio:w,all:_,options:n,command:r,escapedCommand:s,startTime:a})},TE=({file:e,commandArguments:t,options:n,command:r,escapedCommand:s,fileDescriptors:i,startTime:o})=>{try{X_(i,n);const a=PE(n);return Ut.spawnSync(...iu(e,t,a))}catch(a){return wi({error:a,command:r,escapedCommand:s,fileDescriptors:i,options:n,startTime:o,isSync:!0})}},PE=({encoding:e,maxBuffer:t,...n})=>({...n,encoding:"buffer",maxBuffer:bi(t)}),IE=({error:e,exitCode:t,signal:n,timedOut:r,isMaxBuffer:s,stdio:i,all:o,options:a,command:c,escapedCommand:l,startTime:u})=>e===void 0?wu({command:c,escapedCommand:l,stdio:i,all:o,ipcOutput:[],options:a,startTime:u}):_i({error:e,command:c,escapedCommand:l,timedOut:r,isCanceled:!1,isGracefullyCanceled:!1,isMaxBuffer:s,isForcefullyTerminated:!1,exitCode:t,signal:n,stdio:i,all:o,ipcOutput:[],options:a,startTime:u,isSync:!0}),OE=({anyProcess:e,channel:t,isSubprocess:n,ipc:r},{reference:s=!0,filter:i}={})=>(li({methodName:"getOneMessage",isSubprocess:n,ipc:r,isConnected:Qc(e)}),DE({anyProcess:e,channel:t,isSubprocess:n,filter:i,reference:s})),DE=async({anyProcess:e,channel:t,isSubprocess:n,filter:r,reference:s})=>{Yc(t,s);const i=Qn(e,t,n),o=new AbortController;try{return await Promise.race([CE(i,r,o),$E(i,n,o),xE(i,n,o)])}catch(a){throw fi(e),a}finally{o.abort(),Jc(t,s)}},CE=async(e,t,{signal:n})=>{if(t===void 0){const[r]=await Y.once(e,"message",{signal:n});return r}for await(const[r]of Y.on(e,"message",{signal:n}))if(t(r))return r},$E=async(e,t,{signal:n})=>{await Y.once(e,"disconnect",{signal:n}),iS(t)},xE=async(e,t,{signal:n})=>{const[r]=await Y.once(e,"strict:error",{signal:n});throw Wc(r,t)},ME=({anyProcess:e,channel:t,isSubprocess:n,ipc:r},{reference:s=!0}={})=>Ju({anyProcess:e,channel:t,isSubprocess:n,ipc:r,shouldAwait:!n,reference:s}),Ju=({anyProcess:e,channel:t,isSubprocess:n,ipc:r,shouldAwait:s,reference:i})=>{li({methodName:"getEachMessage",isSubprocess:n,ipc:r,isConnected:Qc(e)}),Yc(t,i);const o=Qn(e,t,n),a=new AbortController,c={};return LE(e,o,a),FE({ipcEmitter:o,isSubprocess:n,controller:a,state:c}),jE({anyProcess:e,channel:t,ipcEmitter:o,isSubprocess:n,shouldAwait:s,controller:a,state:c,reference:i})},LE=async(e,t,n)=>{try{await Y.once(t,"disconnect",{signal:n.signal}),n.abort()}catch{}},FE=async({ipcEmitter:e,isSubprocess:t,controller:n,state:r})=>{try{const[s]=await Y.once(e,"strict:error",{signal:n.signal});r.error=Wc(s,t),n.abort()}catch{}},jE=async function*({anyProcess:e,channel:t,ipcEmitter:n,isSubprocess:r,shouldAwait:s,controller:i,state:o,reference:a}){try{for await(const[c]of Y.on(n,"message",{signal:i.signal}))Ho(o),yield c}catch{Ho(o)}finally{i.abort(),Jc(t,a),r||fi(e),s&&await e}},Ho=({error:e})=>{if(e)throw e},NE=(e,{ipc:t})=>{Object.assign(e,Qu(e,!1,t))},BE=()=>{const e=K,t=!0,n=K.channel!==void 0;return{...Qu(e,t,n),getCancelSignal:BS.bind(void 0,{anyProcess:e,channel:e.channel,isSubprocess:t,ipc:n})}},Qu=(e,t,n)=>({sendMessage:Zc.bind(void 0,{anyProcess:e,channel:e.channel,isSubprocess:t,ipc:n}),getOneMessage:OE.bind(void 0,{anyProcess:e,channel:e.channel,isSubprocess:t,ipc:n}),getEachMessage:ME.bind(void 0,{anyProcess:e,channel:e.channel,isSubprocess:t,ipc:n})}),kE=({error:e,command:t,escapedCommand:n,fileDescriptors:r,options:s,startTime:i,verboseInfo:o})=>{Fu(r);const a=new Ut.ChildProcess;UE(a,r),Object.assign(a,{readable:HE,writable:GE,duplex:WE});const c=wi({error:e,command:t,escapedCommand:n,fileDescriptors:r,options:s,startTime:i,isSync:!1}),l=qE(c,o,s);return{subprocess:a,promise:l}},UE=(e,t)=>{const n=Ot(),r=Ot(),s=Ot(),i=Array.from({length:t.length-3},Ot),o=Ot(),a=[n,r,s,...i];Object.assign(e,{stdin:n,stdout:r,stderr:s,all:o,stdio:a})},Ot=()=>{const e=new ee.PassThrough;return e.end(),e},HE=()=>new ee.Readable({read(){}}),GE=()=>new ee.Writable({write(){}}),WE=()=>new ee.Duplex({read(){},write(){}}),qE=async(e,t,n)=>Ei(e,t,n),VE=(e,t)=>Lu(zE,e,t,!1),Ct=({type:e,optionName:t})=>{throw new TypeError(`The \`${t}\` option cannot be ${tr[e]}.`)},Go={fileNumber:Ct,generator:Uo,asyncGenerator:Uo,nodeStream:({value:e})=>({stream:e}),webTransform({value:{transform:e,writableObjectMode:t,readableObjectMode:n}}){const r=t||n;return{stream:ee.Duplex.fromWeb(e,{objectMode:r})}},duplex:({value:{transform:e}})=>({stream:e}),native(){}},zE={input:{...Go,fileUrl:({value:e})=>({stream:Ce.createReadStream(e)}),filePath:({value:{file:e}})=>({stream:Ce.createReadStream(e)}),webStream:({value:e})=>({stream:ee.Readable.fromWeb(e)}),iterable:({value:e})=>({stream:ee.Readable.from(e)}),asyncIterable:({value:e})=>({stream:ee.Readable.from(e)}),string:({value:e})=>({stream:ee.Readable.from(e)}),uint8Array:({value:e})=>({stream:ee.Readable.from(ys.Buffer.from(e))})},output:{...Go,fileUrl:({value:e})=>({stream:Ce.createWriteStream(e)}),filePath:({value:{file:e,append:t}})=>({stream:Ce.createWriteStream(e,t?{flags:"a"}:{})}),webStream:({value:e})=>({stream:ee.Writable.fromWeb(e)}),iterable:Ct,asyncIterable:Ct,string:Ct,uint8Array:Ct}};function Ii(e){if(!Array.isArray(e))throw new TypeError(`Expected an array, got \`${typeof e}\`.`);for(const s of e)rs(s);const t=e.some(({readableObjectMode:s})=>s),n=KE(e,t),r=new YE({objectMode:t,writableHighWaterMark:n,readableHighWaterMark:n});for(const s of e)r.add(s);return r}const KE=(e,t)=>{if(e.length===0)return ee.getDefaultHighWaterMark(t);const n=e.filter(({readableObjectMode:r})=>r===t).map(({readableHighWaterMark:r})=>r);return Math.max(...n)};var He,xn,Mn,Bt,kt,gt;class YE extends ee.PassThrough{constructor(){super(...arguments);X(this,He,new Set([]));X(this,xn,new Set([]));X(this,Mn,new Set([]));X(this,Bt);X(this,kt,Symbol("unpipe"));X(this,gt,new WeakMap)}add(n){if(rs(n),v(this,He).has(n))return;v(this,He).add(n),v(this,Bt)??ne(this,Bt,JE(this,v(this,He),v(this,kt)));const r=ZE({passThroughStream:this,stream:n,streams:v(this,He),ended:v(this,xn),aborted:v(this,Mn),onFinished:v(this,Bt),unpipeEvent:v(this,kt)});v(this,gt).set(n,r),n.pipe(this,{end:!1})}async remove(n){if(rs(n),!v(this,He).has(n))return!1;const r=v(this,gt).get(n);return r===void 0?!1:(v(this,gt).delete(n),n.unpipe(this),await r,!0)}}He=new WeakMap,xn=new WeakMap,Mn=new WeakMap,Bt=new WeakMap,kt=new WeakMap,gt=new WeakMap;const JE=async(e,t,n)=>{Pn(e,Wo);const r=new AbortController;try{await Promise.race([QE(e,r),XE(e,t,n,r)])}finally{r.abort(),Pn(e,-Wo)}},QE=async(e,{signal:t})=>{try{await Ve.finished(e,{signal:t,cleanup:!0})}catch(n){throw Xu(e,n),n}},XE=async(e,t,n,{signal:r})=>{for await(const[s]of Y.on(e,"unpipe",{signal:r}))t.has(s)&&s.emit(n)},rs=e=>{if(typeof(e==null?void 0:e.pipe)!="function")throw new TypeError(`Expected a readable stream, got: \`${typeof e}\`.`)},ZE=async({passThroughStream:e,stream:t,streams:n,ended:r,aborted:s,onFinished:i,unpipeEvent:o})=>{Pn(e,qo);const a=new AbortController;try{await Promise.race([eA(i,t,a),tA({passThroughStream:e,stream:t,streams:n,ended:r,aborted:s,controller:a}),nA({stream:t,streams:n,ended:r,aborted:s,unpipeEvent:o,controller:a})])}finally{a.abort(),Pn(e,-qo)}n.size>0&&n.size===r.size+s.size&&(r.size===0&&s.size>0?Oi(e):rA(e))},eA=async(e,t,{signal:n})=>{try{await e,n.aborted||Oi(t)}catch(r){n.aborted||Xu(t,r)}},tA=async({passThroughStream:e,stream:t,streams:n,ended:r,aborted:s,controller:{signal:i}})=>{try{await Ve.finished(t,{signal:i,cleanup:!0,readable:!0,writable:!1}),n.has(t)&&r.add(t)}catch(o){if(i.aborted||!n.has(t))return;Zu(o)?s.add(t):el(e,o)}},nA=async({stream:e,streams:t,ended:n,aborted:r,unpipeEvent:s,controller:{signal:i}})=>{if(await Y.once(e,s,{signal:i}),!e.readable)return Y.once(i,"abort",{signal:i});t.delete(e),n.delete(e),r.delete(e)},rA=e=>{e.writable&&e.end()},Xu=(e,t)=>{Zu(t)?Oi(e):el(e,t)},Zu=e=>(e==null?void 0:e.code)==="ERR_STREAM_PREMATURE_CLOSE",Oi=e=>{(e.readable||e.writable)&&e.destroy()},el=(e,t)=>{e.destroyed||(e.once("error",sA),e.destroy(t))},sA=()=>{},Pn=(e,t)=>{const n=e.getMaxListeners();n!==0&&n!==Number.POSITIVE_INFINITY&&e.setMaxListeners(n+t)},Wo=2,qo=1,In=(e,t)=>{e.pipe(t),iA(e,t),oA(e,t)},iA=async(e,t)=>{if(!(nt(e)||nt(t))){try{await Ve.finished(e,{cleanup:!0,readable:!0,writable:!1})}catch{}tl(t)}},tl=e=>{e.writable&&e.end()},oA=async(e,t)=>{if(!(nt(e)||nt(t))){try{await Ve.finished(t,{cleanup:!0,readable:!1,writable:!0})}catch{}nl(e)}},nl=e=>{e.readable&&e.destroy()},aA=(e,t,n)=>{const r=new Map;for(const[s,{stdioItems:i,direction:o}]of Object.entries(t)){for(const{stream:a}of i.filter(({type:c})=>st.has(c)))cA(e,a,o,s);for(const{stream:a}of i.filter(({type:c})=>!st.has(c)))lA({subprocess:e,stream:a,direction:o,fdNumber:s,pipeGroups:r,controller:n})}for(const[s,i]of r.entries()){const o=i.length===1?i[0]:Ii(i);In(o,s)}},cA=(e,t,n,r)=>{n==="output"?In(e.stdio[r],t):In(t,e.stdio[r]);const s=uA[r];s!==void 0&&(e[s]=t),e.stdio[r]=t},uA=["stdin","stdout","stderr"],lA=({subprocess:e,stream:t,direction:n,fdNumber:r,pipeGroups:s,controller:i})=>{if(t===void 0)return;fA(t,i);const[o,a]=n==="output"?[t,e.stdio[r]]:[e.stdio[r],t],c=s.get(o)??[];s.set(o,[...c,a])},fA=(e,{signal:t})=>{nt(e)&&Rn(e,dA,t)},dA=2,pt=[];pt.push("SIGHUP","SIGINT","SIGTERM");process.platform!=="win32"&&pt.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT");process.platform==="linux"&&pt.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT");const yn=e=>!!e&&typeof e=="object"&&typeof e.removeListener=="function"&&typeof e.emit=="function"&&typeof e.reallyExit=="function"&&typeof e.listeners=="function"&&typeof e.kill=="function"&&typeof e.pid=="number"&&typeof e.on=="function",vr=Symbol.for("signal-exit emitter"),Rr=globalThis,hA=Object.defineProperty.bind(Object);class pA{constructor(){ct(this,"emitted",{afterExit:!1,exit:!1});ct(this,"listeners",{afterExit:[],exit:[]});ct(this,"count",0);ct(this,"id",Math.random());if(Rr[vr])return Rr[vr];hA(Rr,vr,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(t,n){this.listeners[t].push(n)}removeListener(t,n){const r=this.listeners[t],s=r.indexOf(n);s!==-1&&(s===0&&r.length===1?r.length=0:r.splice(s,1))}emit(t,n,r){if(this.emitted[t])return!1;this.emitted[t]=!0;let s=!1;for(const i of this.listeners[t])s=i(n,r)===!0||s;return t==="exit"&&(s=this.emit("afterExit",n,r)||s),s}}class rl{}const gA=e=>({onExit(t,n){return e.onExit(t,n)},load(){return e.load()},unload(){return e.unload()}});class mA extends rl{onExit(){return()=>{}}load(){}unload(){}}var Ln,le,V,mt,yt,Ze,Ge,At,sl,il;class yA extends rl{constructor(n){super();X(this,At);X(this,Ln,ss.platform==="win32"?"SIGINT":"SIGHUP");X(this,le,new pA);X(this,V);X(this,mt);X(this,yt);X(this,Ze,{});X(this,Ge,!1);ne(this,V,n),ne(this,Ze,{});for(const r of pt)v(this,Ze)[r]=()=>{const s=v(this,V).listeners(r);let{count:i}=v(this,le);const o=n;if(typeof o.__signal_exit_emitter__=="object"&&typeof o.__signal_exit_emitter__.count=="number"&&(i+=o.__signal_exit_emitter__.count),s.length===i){this.unload();const a=v(this,le).emit("exit",null,r),c=r==="SIGHUP"?v(this,Ln):r;a||n.kill(n.pid,c)}};ne(this,yt,n.reallyExit),ne(this,mt,n.emit)}onExit(n,r){if(!yn(v(this,V)))return()=>{};v(this,Ge)===!1&&this.load();const s=r!=null&&r.alwaysLast?"afterExit":"exit";return v(this,le).on(s,n),()=>{v(this,le).removeListener(s,n),v(this,le).listeners.exit.length===0&&v(this,le).listeners.afterExit.length===0&&this.unload()}}load(){if(!v(this,Ge)){ne(this,Ge,!0),v(this,le).count+=1;for(const n of pt)try{const r=v(this,Ze)[n];r&&v(this,V).on(n,r)}catch{}v(this,V).emit=(n,...r)=>Pt(this,At,il).call(this,n,...r),v(this,V).reallyExit=n=>Pt(this,At,sl).call(this,n)}}unload(){v(this,Ge)&&(ne(this,Ge,!1),pt.forEach(n=>{const r=v(this,Ze)[n];if(!r)throw new Error("Listener not defined for signal: "+n);try{v(this,V).removeListener(n,r)}catch{}}),v(this,V).emit=v(this,mt),v(this,V).reallyExit=v(this,yt),v(this,le).count-=1)}}Ln=new WeakMap,le=new WeakMap,V=new WeakMap,mt=new WeakMap,yt=new WeakMap,Ze=new WeakMap,Ge=new WeakMap,At=new WeakSet,sl=function(n){return yn(v(this,V))?(v(this,V).exitCode=n||0,v(this,le).emit("exit",v(this,V).exitCode,null),v(this,yt).call(v(this,V),v(this,V).exitCode)):0},il=function(n,...r){const s=v(this,mt);if(n==="exit"&&yn(v(this,V))){typeof r[0]=="number"&&(v(this,V).exitCode=r[0]);const i=s.call(v(this,V),n,...r);return v(this,le).emit("exit",v(this,V).exitCode,null),i}else return s.call(v(this,V),n,...r)};const ss=globalThis.process,{onExit:SA}=gA(yn(ss)?new yA(ss):new mA),bA=(e,{cleanup:t,detached:n},{signal:r})=>{if(!t||n)return;const s=SA(()=>{e.kill()});Y.addAbortListener(r,()=>{s()})},wA=({source:e,sourcePromise:t,boundOptions:n,createNested:r},...s)=>{const i=_c(),{destination:o,destinationStream:a,destinationError:c,from:l,unpipeSignal:u}=_A(n,r,s),{sourceStream:f,sourceError:d}=AA(e,l),{options:p,fileDescriptors:h}=rt.get(e);return{sourcePromise:t,sourceStream:f,sourceOptions:p,sourceError:d,destination:o,destinationStream:a,destinationError:c,unpipeSignal:u,fileDescriptors:h,startTime:i}},_A=(e,t,n)=>{try{const{destination:r,pipeOptions:{from:s,to:i,unpipeSignal:o}={}}=EA(e,t,...n),a=qc(r,i);return{destination:r,destinationStream:a,from:s,unpipeSignal:o}}catch(r){return{destinationError:r}}},EA=(e,t,n,...r)=>{if(Array.isArray(n))return{destination:t(Vo,e)(n,...r),pipeOptions:e};if(typeof n=="string"||n instanceof URL||ac(n)){if(Object.keys(e).length>0)throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');const[s,i,o]=uc(n,...r);return{destination:t(Vo)(s,i,o),pipeOptions:o}}if(rt.has(n)){if(Object.keys(e).length>0)throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");return{destination:n,pipeOptions:r[0]}}throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${n}`)},Vo=({options:e})=>({options:{...e,stdin:"pipe",piped:!0}}),AA=(e,t)=>{try{return{sourceStream:di(e,t)}}catch(n){return{sourceError:n}}},vA=({sourceStream:e,sourceError:t,destinationStream:n,destinationError:r,fileDescriptors:s,sourceOptions:i,startTime:o})=>{const a=RA({sourceStream:e,sourceError:t,destinationStream:n,destinationError:r});if(a!==void 0)throw ol({error:a,fileDescriptors:s,sourceOptions:i,startTime:o})},RA=({sourceStream:e,sourceError:t,destinationStream:n,destinationError:r})=>{if(t!==void 0&&r!==void 0)return r;if(r!==void 0)return nl(e),r;if(t!==void 0)return tl(n),t},ol=({error:e,fileDescriptors:t,sourceOptions:n,startTime:r})=>wi({error:e,command:zo,escapedCommand:zo,fileDescriptors:t,options:n,startTime:r,isSync:!1}),zo="source.pipe(destination)",TA=async e=>{const[{status:t,reason:n,value:r=n},{status:s,reason:i,value:o=i}]=await e;if(o.pipedFrom.includes(r)||o.pipedFrom.push(r),s==="rejected")throw o;if(t==="rejected")throw r;return o},PA=(e,t,n)=>{const r=nr.has(t)?OA(e,t):IA(e,t);return Rn(e,CA,n.signal),Rn(t,$A,n.signal),DA(t),r},IA=(e,t)=>{const n=Ii([e]);return In(n,t),nr.set(t,n),n},OA=(e,t)=>{const n=nr.get(t);return n.add(e),n},DA=async e=>{try{await Ve.finished(e,{cleanup:!0,readable:!1,writable:!0})}catch{}nr.delete(e)},nr=new WeakMap,CA=2,$A=1,xA=(e,t)=>e===void 0?[]:[MA(e,t)],MA=async(e,{sourceStream:t,mergedStream:n,fileDescriptors:r,sourceOptions:s,startTime:i})=>{await pe.aborted(e,t),await n.remove(t);const o=new Error("Pipe canceled by `unpipeSignal` option.");throw ol({error:o,fileDescriptors:r,sourceOptions:s,startTime:i})},is=(e,...t)=>{if(be(t[0]))return is.bind(void 0,{...e,boundOptions:{...e.boundOptions,...t[0]}});const{destination:n,...r}=wA(e,...t),s=LA({...r,destination:n});return s.pipe=is.bind(void 0,{...e,source:n,sourcePromise:s,boundOptions:{}}),s},LA=async({sourcePromise:e,sourceStream:t,sourceOptions:n,sourceError:r,destination:s,destinationStream:i,destinationError:o,unpipeSignal:a,fileDescriptors:c,startTime:l})=>{const u=FA(e,s);vA({sourceStream:t,sourceError:r,destinationStream:i,destinationError:o,fileDescriptors:c,sourceOptions:n,startTime:l});const f=new AbortController;try{const d=PA(t,i,f);return await Promise.race([TA(u),...xA(a,{sourceStream:t,mergedStream:d,sourceOptions:n,fileDescriptors:c,startTime:l})])}finally{f.abort()}},FA=(e,t)=>Promise.allSettled([e,t]),al=({subprocessStdout:e,subprocess:t,binary:n,shouldEncode:r,encoding:s,preserveNewlines:i})=>{const o=new AbortController;return jA(t,o),ul({stream:e,controller:o,binary:n,shouldEncode:!e.readableObjectMode&&r,encoding:s,shouldSplit:!e.readableObjectMode,preserveNewlines:i})},jA=async(e,t)=>{try{await e}catch{}finally{t.abort()}},cl=({stream:e,onStreamEnd:t,lines:n,encoding:r,stripFinalNewline:s,allMixed:i})=>{const o=new AbortController;NA(t,o,e);const a=e.readableObjectMode&&!i;return ul({stream:e,controller:o,binary:r==="buffer",shouldEncode:!a,encoding:r,shouldSplit:!a&&n,preserveNewlines:!s})},NA=async(e,t,n)=>{try{await e}catch{n.destroy()}finally{t.abort()}},ul=({stream:e,controller:t,binary:n,shouldEncode:r,encoding:s,shouldSplit:i,preserveNewlines:o})=>{const a=Y.on(e,"data",{signal:t.signal,highWaterMark:Ko,highWatermark:Ko});return BA({onStdoutChunk:a,controller:t,binary:n,shouldEncode:r,encoding:s,shouldSplit:i,preserveNewlines:o})},ll=ee.getDefaultHighWaterMark(!0),Ko=ll,BA=async function*({onStdoutChunk:e,controller:t,binary:n,shouldEncode:r,encoding:s,shouldSplit:i,preserveNewlines:o}){const a=kA({binary:n,shouldEncode:r,encoding:s,shouldSplit:i,preserveNewlines:o});try{for await(const[c]of e)yield*Xt(c,a,0)}catch(c){if(!t.signal.aborted)throw c}finally{yield*Pi(a)}},kA=({binary:e,shouldEncode:t,encoding:n,shouldSplit:r,preserveNewlines:s})=>[Gu(e,n,!t),Bu(e,s,!r,{})].filter(Boolean),UA=async({stream:e,onStreamEnd:t,fdNumber:n,encoding:r,buffer:s,maxBuffer:i,lines:o,allMixed:a,stripFinalNewline:c,verboseInfo:l,streamInfo:u})=>{const f=HA({stream:e,onStreamEnd:t,fdNumber:n,encoding:r,allMixed:a,verboseInfo:l,streamInfo:u});if(!s){await Promise.all([GA(e),f]);return}const d=Nu(c,n),p=cl({stream:e,onStreamEnd:t,lines:o,encoding:r,stripFinalNewline:d,allMixed:a}),[h]=await Promise.all([WA({stream:e,iterable:p,fdNumber:n,encoding:r,maxBuffer:i,lines:o}),f]);return h},HA=async({stream:e,onStreamEnd:t,fdNumber:n,encoding:r,allMixed:s,verboseInfo:i,streamInfo:{fileDescriptors:o}})=>{var c;if(!Vu({stdioItems:(c=o[n])==null?void 0:c.stdioItems,encoding:r,verboseInfo:i,fdNumber:n}))return;const a=cl({stream:e,onStreamEnd:t,lines:!0,encoding:r,stripFinalNewline:!0,allMixed:s});await iE(a,e,n,i)},GA=async e=>{await Ht.setImmediate(),e.readableFlowing===null&&e.resume()},WA=async({stream:e,stream:{readableObjectMode:t},iterable:n,fdNumber:r,encoding:s,maxBuffer:i,lines:o})=>{try{return t||o?await Ab(n,{maxBuffer:i}):s==="buffer"?new Uint8Array(await Ib(n,{maxBuffer:i})):await Nb(n,{maxBuffer:i})}catch(a){return fl(Wb({error:a,stream:e,readableObjectMode:t,lines:o,encoding:s,fdNumber:r}))}},Yo=async e=>{try{return await e}catch(t){return fl(t)}},fl=({bufferedData:e})=>Bg(e)?new Uint8Array(e):e,Di=async(e,t,n,{isSameDirection:r,stopOnExit:s=!1}={})=>{const i=qA(e,n),o=new AbortController;try{await Promise.race([...s?[n.exitPromise]:[],Ve.finished(e,{cleanup:!0,signal:o.signal})])}catch(a){i.stdinCleanedUp||KA(a,t,n,r)}finally{o.abort()}},qA=(e,{originalStreams:[t],subprocess:n})=>{const r={stdinCleanedUp:!1};return e===t&&VA(e,n,r),r},VA=(e,t,n)=>{const{_destroy:r}=e;e._destroy=(...s)=>{zA(t,n),r.call(e,...s)}},zA=({exitCode:e,signalCode:t},n)=>{(e!==null||t!==null)&&(n.stdinCleanedUp=!0)},KA=(e,t,n,r)=>{if(!YA(e,t,n,r))throw e},YA=(e,t,n,r=!0)=>n.propagating?Jo(e)||os(e):(n.propagating=!0,dl(n,t)===r?Jo(e):os(e)),dl=({fileDescriptors:e},t)=>t!=="all"&&e[t].direction==="input",os=e=>(e==null?void 0:e.code)==="ERR_STREAM_PREMATURE_CLOSE",Jo=e=>(e==null?void 0:e.code)==="EPIPE",JA=({subprocess:e,encoding:t,buffer:n,maxBuffer:r,lines:s,stripFinalNewline:i,verboseInfo:o,streamInfo:a})=>e.stdio.map((c,l)=>hl({stream:c,fdNumber:l,encoding:t,buffer:n[l],maxBuffer:r[l],lines:s[l],allMixed:!1,stripFinalNewline:i,verboseInfo:o,streamInfo:a})),hl=async({stream:e,fdNumber:t,encoding:n,buffer:r,maxBuffer:s,lines:i,allMixed:o,stripFinalNewline:a,verboseInfo:c,streamInfo:l})=>{if(!e)return;const u=Di(e,t,l);if(dl(l,t)){await u;return}const[f]=await Promise.all([UA({stream:e,onStreamEnd:u,fdNumber:t,encoding:n,buffer:r,maxBuffer:s,lines:i,allMixed:o,stripFinalNewline:a,verboseInfo:c,streamInfo:l}),u]);return f},QA=({stdout:e,stderr:t},{all:n})=>n&&(e||t)?Ii([e,t].filter(Boolean)):void 0,XA=({subprocess:e,encoding:t,buffer:n,maxBuffer:r,lines:s,stripFinalNewline:i,verboseInfo:o,streamInfo:a})=>hl({...ZA(e,n),fdNumber:"all",encoding:t,maxBuffer:r[1]+r[2],lines:s[1]||s[2],allMixed:e0(e),stripFinalNewline:i,verboseInfo:o,streamInfo:a}),ZA=({stdout:e,stderr:t,all:n},[,r,s])=>{const i=r||s;return i?r?s?{stream:n,buffer:i}:{stream:e,buffer:i}:{stream:t,buffer:i}:{stream:n,buffer:i}},e0=({all:e,stdout:t,stderr:n})=>e&&t&&n&&t.readableObjectMode!==n.readableObjectMode,t0=e=>Qs(e,"ipc"),n0=(e,t)=>{const n=wc(e);Yt({type:"ipc",verboseMessage:n,fdNumber:"ipc",verboseInfo:t})},r0=async({subprocess:e,buffer:t,maxBuffer:n,ipc:r,ipcOutput:s,verboseInfo:i})=>{if(!r)return s;const o=t0(i),a=jt(t,"ipc"),c=jt(n,"ipc");for await(const l of Ju({anyProcess:e,channel:e.channel,isSubprocess:!1,ipc:r,shouldAwait:!1,reference:!0}))a&&(Vb(e,s,c),s.push(l)),o&&n0(l,i);return s},s0=async(e,t)=>(await Promise.allSettled([e]),t),i0=async({subprocess:e,options:{encoding:t,buffer:n,maxBuffer:r,lines:s,timeoutDuration:i,cancelSignal:o,gracefulCancel:a,forceKillAfterDelay:c,stripFinalNewline:l,ipc:u,ipcInput:f},context:d,verboseInfo:p,fileDescriptors:h,originalStreams:g,onInternalError:w,controller:_})=>{const I=gE(e,d),$={originalStreams:g,fileDescriptors:h,subprocess:e,exitPromise:I,propagating:!1},F=JA({subprocess:e,encoding:t,buffer:n,maxBuffer:r,lines:s,stripFinalNewline:l,verboseInfo:p,streamInfo:$}),B=XA({subprocess:e,encoding:t,buffer:n,maxBuffer:r,lines:s,stripFinalNewline:l,verboseInfo:p,streamInfo:$}),T=[],P=r0({subprocess:e,buffer:n,maxBuffer:r,ipc:u,ipcOutput:T,verboseInfo:p}),b=o0(g,e,$),O=a0(h,$);try{return await Promise.race([Promise.all([{},yE(I),Promise.all(F),B,P,tb(e,f),...b,...O]),w,c0(e,_),...zS(e,i,d,_),...nS({subprocess:e,cancelSignal:o,gracefulCancel:a,context:d,controller:_}),...GS({subprocess:e,cancelSignal:o,gracefulCancel:a,forceKillAfterDelay:c,context:d,controller:_})])}catch(k){return d.terminationReason??(d.terminationReason="other"),Promise.all([{error:k},I,Promise.all(F.map(S=>Yo(S))),Yo(B),s0(P,T),Promise.allSettled(b),Promise.allSettled(O)])}},o0=(e,t,n)=>e.map((r,s)=>r===t.stdio[s]?void 0:Di(r,s,n)),a0=(e,t)=>e.flatMap(({stdioItems:n},r)=>n.filter(({value:s,stream:i=s})=>ot(i,{checkOpen:!1})&&!nt(i)).map(({type:s,value:i,stream:o=i})=>Di(o,r,t,{isSameDirection:st.has(s),stopOnExit:s==="native"}))),c0=async(e,{signal:t})=>{const[n]=await Y.once(e,"error",{signal:t});throw n},u0=()=>({readableDestroy:new WeakMap,writableFinal:new WeakMap,writableDestroy:new WeakMap}),as=(e,t,n)=>{const r=e[n];r.has(t)||r.set(t,[]);const s=r.get(t),i=Qt();return s.push(i),{resolve:i.resolve.bind(i),promises:s}},On=async({resolve:e,promises:t},n)=>{e();const[r]=await Promise.race([Promise.allSettled([!0,n]),Promise.all([!1,...t])]);return!r},Qo=async e=>{if(e!==void 0)try{await pl(e)}catch{}},l0=async e=>{if(e!==void 0)try{await gl(e)}catch{}},pl=async e=>{await Ve.finished(e,{cleanup:!0,readable:!1,writable:!0})},gl=async e=>{await Ve.finished(e,{cleanup:!0,readable:!0,writable:!1})},ml=async(e,t)=>{if(await e,t)throw t},yl=(e,t,n)=>{n&&!os(n)?e.destroy(n):t&&e.destroy()},f0=({subprocess:e,concurrentStreams:t,encoding:n},{from:r,binary:s=!0,preserveNewlines:i=!0}={})=>{const o=s||it.has(n),{subprocessStdout:a,waitReadableDestroy:c}=Sl(e,r,t),{readableEncoding:l,readableObjectMode:u,readableHighWaterMark:f}=bl(a,o),{read:d,onStdoutDataDone:p}=wl({subprocessStdout:a,subprocess:e,binary:o,encoding:n,preserveNewlines:i}),h=new ee.Readable({read:d,destroy:pe.callbackify(El.bind(void 0,{subprocessStdout:a,subprocess:e,waitReadableDestroy:c})),highWaterMark:f,objectMode:u,encoding:l});return _l({subprocessStdout:a,onStdoutDataDone:p,readable:h,subprocess:e}),h},Sl=(e,t,n)=>{const r=di(e,t),s=as(n,r,"readableDestroy");return{subprocessStdout:r,waitReadableDestroy:s}},bl=({readableEncoding:e,readableObjectMode:t,readableHighWaterMark:n},r)=>r?{readableEncoding:e,readableObjectMode:t,readableHighWaterMark:n}:{readableEncoding:e,readableObjectMode:!0,readableHighWaterMark:ll},wl=({subprocessStdout:e,subprocess:t,binary:n,encoding:r,preserveNewlines:s})=>{const i=Qt(),o=al({subprocessStdout:e,subprocess:t,binary:n,shouldEncode:!n,encoding:r,preserveNewlines:s});return{read(){d0(this,o,i)},onStdoutDataDone:i}},d0=async(e,t,n)=>{try{const{value:r,done:s}=await t.next();s?n.resolve():e.push(r)}catch{}},_l=async({subprocessStdout:e,onStdoutDataDone:t,readable:n,subprocess:r,subprocessStdin:s})=>{try{await gl(e),await r,await Qo(s),await t,n.readable&&n.push(null)}catch(i){await Qo(s),Al(n,i)}},El=async({subprocessStdout:e,subprocess:t,waitReadableDestroy:n},r)=>{await On(n,t)&&(Al(e,r),await ml(t,r))},Al=(e,t)=>{yl(e,e.readable,t)},h0=({subprocess:e,concurrentStreams:t},{to:n}={})=>{const{subprocessStdin:r,waitWritableFinal:s,waitWritableDestroy:i}=vl(e,n,t),o=new ee.Writable({...Rl(r,e,s),destroy:pe.callbackify(Pl.bind(void 0,{subprocessStdin:r,subprocess:e,waitWritableFinal:s,waitWritableDestroy:i})),highWaterMark:r.writableHighWaterMark,objectMode:r.writableObjectMode});return Tl(r,o),o},vl=(e,t,n)=>{const r=qc(e,t),s=as(n,r,"writableFinal"),i=as(n,r,"writableDestroy");return{subprocessStdin:r,waitWritableFinal:s,waitWritableDestroy:i}},Rl=(e,t,n)=>({write:p0.bind(void 0,e),final:pe.callbackify(g0.bind(void 0,e,t,n))}),p0=(e,t,n,r)=>{e.write(t,n)?r():e.once("drain",r)},g0=async(e,t,n)=>{await On(n,t)&&(e.writable&&e.end(),await t)},Tl=async(e,t,n)=>{try{await pl(e),t.writable&&t.end()}catch(r){await l0(n),Il(t,r)}},Pl=async({subprocessStdin:e,subprocess:t,waitWritableFinal:n,waitWritableDestroy:r},s)=>{await On(n,t),await On(r,t)&&(Il(e,s),await ml(t,s))},Il=(e,t)=>{yl(e,e.writable,t)},m0=({subprocess:e,concurrentStreams:t,encoding:n},{from:r,to:s,binary:i=!0,preserveNewlines:o=!0}={})=>{const a=i||it.has(n),{subprocessStdout:c,waitReadableDestroy:l}=Sl(e,r,t),{subprocessStdin:u,waitWritableFinal:f,waitWritableDestroy:d}=vl(e,s,t),{readableEncoding:p,readableObjectMode:h,readableHighWaterMark:g}=bl(c,a),{read:w,onStdoutDataDone:_}=wl({subprocessStdout:c,subprocess:e,binary:a,encoding:n,preserveNewlines:o}),I=new ee.Duplex({read:w,...Rl(u,e,f),destroy:pe.callbackify(y0.bind(void 0,{subprocessStdout:c,subprocessStdin:u,subprocess:e,waitReadableDestroy:l,waitWritableFinal:f,waitWritableDestroy:d})),readableHighWaterMark:g,writableHighWaterMark:u.writableHighWaterMark,readableObjectMode:h,writableObjectMode:u.writableObjectMode,encoding:p});return _l({subprocessStdout:c,onStdoutDataDone:_,readable:I,subprocess:e,subprocessStdin:u}),Tl(u,I,c),I},y0=async({subprocessStdout:e,subprocessStdin:t,subprocess:n,waitReadableDestroy:r,waitWritableFinal:s,waitWritableDestroy:i},o)=>{await Promise.all([El({subprocessStdout:e,subprocess:n,waitReadableDestroy:r},o),Pl({subprocessStdin:t,subprocess:n,waitWritableFinal:s,waitWritableDestroy:i},o)])},Xo=(e,t,{from:n,binary:r=!1,preserveNewlines:s=!1}={})=>{const i=r||it.has(t),o=di(e,n),a=al({subprocessStdout:o,subprocess:e,binary:i,shouldEncode:!0,encoding:t,preserveNewlines:s});return S0(a,o,e)},S0=async function*(e,t,n){try{yield*e}finally{t.readable&&t.destroy(),await n}},b0=(e,{encoding:t})=>{const n=u0();e.readable=f0.bind(void 0,{subprocess:e,concurrentStreams:n,encoding:t}),e.writable=h0.bind(void 0,{subprocess:e,concurrentStreams:n}),e.duplex=m0.bind(void 0,{subprocess:e,concurrentStreams:n,encoding:t}),e.iterable=Xo.bind(void 0,e,t),e[Symbol.asyncIterator]=Xo.bind(void 0,e,t,{})},w0=(e,t)=>{for(const[n,r]of E0){const s=r.value.bind(t);Reflect.defineProperty(e,n,{...r,value:s})}},_0=(async()=>{})().constructor.prototype,E0=["then","catch","finally"].map(e=>[e,Reflect.getOwnPropertyDescriptor(_0,e)]),A0=(e,t,n,r)=>{const{file:s,commandArguments:i,command:o,escapedCommand:a,startTime:c,verboseInfo:l,options:u,fileDescriptors:f}=v0(e,t,n),{subprocess:d,promise:p}=T0({file:s,commandArguments:i,options:u,startTime:c,verboseInfo:l,command:o,escapedCommand:a,fileDescriptors:f});return d.pipe=is.bind(void 0,{source:d,sourcePromise:p,boundOptions:{},createNested:r}),w0(d,p),rt.set(d,{options:u,fileDescriptors:f}),d},v0=(e,t,n)=>{const{command:r,escapedCommand:s,startTime:i,verboseInfo:o}=Ac(e,t,n),{file:a,commandArguments:c,options:l}=su(e,t,n),u=R0(l),f=VE(u,o);return{file:a,commandArguments:c,command:r,escapedCommand:s,startTime:i,verboseInfo:o,options:u,fileDescriptors:f}},R0=({timeout:e,signal:t,...n})=>{if(t!==void 0)throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');return{...n,timeoutDuration:e}},T0=({file:e,commandArguments:t,options:n,startTime:r,verboseInfo:s,command:i,escapedCommand:o,fileDescriptors:a})=>{let c;try{c=Ut.spawn(...iu(e,t,n))}catch(h){return kE({error:h,command:i,escapedCommand:o,fileDescriptors:a,options:n,startTime:r,verboseInfo:s})}const l=new AbortController;Y.setMaxListeners(Number.POSITIVE_INFINITY,l.signal);const u=[...c.stdio];aA(c,a,l),bA(c,n,l);const f={},d=Qt();c.kill=Qy.bind(void 0,{kill:c.kill.bind(c),options:n,onInternalError:d,context:f,controller:l}),c.all=QA(c,n),b0(c,n),NE(c,n);const p=P0({subprocess:c,options:n,startTime:r,verboseInfo:s,fileDescriptors:a,originalStreams:u,command:i,escapedCommand:o,context:f,onInternalError:d,controller:l});return{subprocess:c,promise:p}},P0=async({subprocess:e,options:t,startTime:n,verboseInfo:r,fileDescriptors:s,originalStreams:i,command:o,escapedCommand:a,context:c,onInternalError:l,controller:u})=>{const[f,[d,p],h,g,w]=await i0({subprocess:e,options:t,context:c,verboseInfo:r,fileDescriptors:s,originalStreams:i,onInternalError:l,controller:u});u.abort(),l.resolve();const _=h.map((F,B)=>_t(F,t,B)),I=_t(g,t,"all"),$=I0({errorInfo:f,exitCode:d,signal:p,stdio:_,all:I,ipcOutput:w,context:c,options:t,command:o,escapedCommand:a,startTime:n});return Ei($,r,t)},I0=({errorInfo:e,exitCode:t,signal:n,stdio:r,all:s,ipcOutput:i,context:o,options:a,command:c,escapedCommand:l,startTime:u})=>"error"in e?_i({error:e.error,command:c,escapedCommand:l,timedOut:o.terminationReason==="timeout",isCanceled:o.terminationReason==="cancel"||o.terminationReason==="gracefulCancel",isGracefullyCanceled:o.terminationReason==="gracefulCancel",isMaxBuffer:e.error instanceof er,isForcefullyTerminated:o.isForcefullyTerminated,exitCode:t,signal:n,stdio:r,all:s,ipcOutput:i,options:a,startTime:u,isSync:!1}):wu({command:c,escapedCommand:l,stdio:r,all:s,ipcOutput:i,options:a,startTime:u}),cs=(e,t)=>{const n=Object.fromEntries(Object.entries(t).map(([r,s])=>[r,O0(r,e[r],s)]));return{...e,...n}},O0=(e,t,n)=>D0.has(e)&&be(t)&&be(n)?{...t,...n}:n,D0=new Set(["env",...yc]),at=(e,t,n,r)=>{const s=(o,a,c)=>at(o,a,n,c),i=(...o)=>C0({mapArguments:e,deepOptions:n,boundOptions:t,setBoundExeca:r,createNested:s},...o);return r!==void 0&&r(i,s,t),i},C0=({mapArguments:e,deepOptions:t={},boundOptions:n={},setBoundExeca:r,createNested:s},i,...o)=>{if(be(i))return s(e,cs(n,i),r);const{file:a,commandArguments:c,options:l,isSync:u}=$0({mapArguments:e,firstArgument:i,nextArguments:o,deepOptions:t,boundOptions:n});return u?_E(a,c,l):A0(a,c,l,s)},$0=({mapArguments:e,firstArgument:t,nextArguments:n,deepOptions:r,boundOptions:s})=>{const i=Vg(t)?zg(t,n):[t,...n],[o,a,c]=uc(...i),l=cs(cs(r,s),c),{file:u=o,commandArguments:f=a,options:d=l,isSync:p=!1}=e({file:o,commandArguments:a,options:l});return{file:u,commandArguments:f,options:d,isSync:p}},x0=({file:e,commandArguments:t})=>Ol(e,t),M0=({file:e,commandArguments:t})=>({...Ol(e,t),isSync:!0}),Ol=(e,t)=>{if(t.length>0)throw new TypeError(`The command and its arguments must be passed as a single string: ${e} ${t}.`);const[n,...r]=L0(e);return{file:n,commandArguments:r}},L0=e=>{if(typeof e!="string")throw new TypeError(`The command must be a string: ${String(e)}.`);const t=e.trim();if(t==="")return[];const n=[];for(const r of t.split(F0)){const s=n.at(-1);s&&s.endsWith("\\")?n[n.length-1]=`${s.slice(0,-1)} ${r}`:n.push(r)}return n},F0=/ +/g,j0=(e,t,n)=>{e.sync=t(B0,n),e.s=e.sync},N0=({options:e})=>Dl(e),B0=({options:e})=>({...Dl(e),isSync:!0}),Dl=e=>({options:{...k0(e),...e}}),k0=({input:e,inputFile:t,stdio:n})=>e===void 0&&t===void 0&&n===void 0?{stdin:"inherit"}:{},U0={preferLocal:!0},Ci=at(()=>({}));at(()=>({isSync:!0}));at(x0);at(M0);at(YS);at(N0,{},U0,j0);BE();async function Cl(e){try{const t=z.join(e,".git");return(await me.stat(t)).isDirectory()}catch{return!1}}async function H0(e,t=1e4){const n={isGit:!1,branch:null,lastCommitHash:null,remotes:[]};try{if(!await Cl(e))return n;const[r,s,i]=await Promise.all([G0(e,t),W0(e,t),q0(e,t)]);return{isGit:!0,branch:r,lastCommitHash:s,remotes:i}}catch(r){return R.warn(`Failed to get git info for ${e}:`,r.message),n}}async function G0(e,t){try{const{stdout:n}=await Ci("git",["-C",e,"rev-parse","--abbrev-ref","HEAD"],{timeout:t,reject:!1});return n.trim()||null}catch{return null}}async function W0(e,t){try{const{stdout:n}=await Ci("git",["-C",e,"rev-parse","HEAD"],{timeout:t,reject:!1});return n.trim()||null}catch{return null}}async function q0(e,t){try{const{stdout:n}=await Ci("git",["-C",e,"remote","-v"],{timeout:t,reject:!1});if(!n)return[];const r=new Map,s=n.split(`
`);for(const o of s){const a=o.match(/^(\S+)\s+(\S+)\s+\(fetch\)$/);if(a){const[,c,l]=a;r.set(c,l)}}const i=[];for(const[o,a]of r.entries()){const c=V0(a);i.push({name:o,url:a,...c})}return i}catch{return[]}}function V0(e){const t=e.match(/git@([^:]+):([^/]+)\/(.+?)(\.git)?$/);if(t){const[,r,s,i]=t;return{provider:Zo(r),owner:s,repo:i.replace(/\.git$/,"")}}const n=e.match(/https?:\/\/([^/]+)\/([^/]+)\/(.+?)(\.git)?$/);if(n){const[,r,s,i]=n;return{provider:Zo(r),owner:s,repo:i.replace(/\.git$/,"")}}return{}}function Zo(e){const t=e.toLowerCase();if(t.includes("github"))return"github";if(t.includes("gitlab"))return"gitlab";if(t.includes("bitbucket"))return"bitbucket"}class z0{constructor(t){this.config=t,this.cancelled=!1}setProgressCallback(t){this.onProgress=t}cancel(){this.cancelled=!0,R.info("Scan cancelled")}async scan(){const t=Date.now(),n=[],r=[];let s=0,i=0;R.info("Starting scan with paths:",this.config.paths);try{const o=await this.findCandidates();s=o.length,R.info(`Found ${s} potential projects`);for(const l of o){if(this.cancelled){R.info("Scan cancelled by user");break}try{const u=await this.processCandidate(l);u&&n.push(u),i++,(i%10===0||i===s)&&this.reportProgress(s,i,l)}catch(u){R.warn(`Failed to process ${l}:`,u.message),r.push({path:l,error:u.message}),i++}}const a=Date.now()-t,c=n.filter(l=>l.type==="git").length;return{projects:n,errors:r,stats:{totalScanned:i,gitRepos:c,localProjects:n.length-c,duration:a}}}catch(o){throw R.error("Scan failed:",o),o}}async findCandidates(){const t=new Set;for(const n of this.config.paths){const r=typeof n=="string"?n:n.path,s=typeof n=="string"?!1:!!n.includeAsProject;try{await me.access(r);const i=(this.config.ignoredPatterns||[]).filter(c=>!c.includes(".git")),o=await ft.glob("**/.git",{cwd:r,onlyFiles:!1,deep:this.config.maxDepth,ignore:i,absolute:!0,followSymbolicLinks:!1});for(const c of o){const l=z.dirname(c);t.add(l)}const a=o.length>0;try{const c=await me.stat(z.join(r,".git"));c&&c.isDirectory()&&(s||!a)&&t.add(r)}catch{}if(s)t.add(r);else if(!a)try{const c=await this.findReadmeFiles(r),l=await this.detectLanguage(r);(c&&c.length>0||l)&&t.add(r)}catch{}}catch(i){R.warn(`Failed to scan path ${r}:`,i.message)}}return Array.from(t)}async processCandidate(t){var n;try{const r=await me.stat(t);if(!r.isDirectory())return null;const s=await this.getDirectorySize(t);if(s<this.config.minSizeBytes)return null;const i=await Cl(t),o=i?await H0(t):null,a=await this.countFiles(t),c=await this.findReadmeFiles(t),l=await this.detectLanguage(t),u=((n=o==null?void 0:o.remotes[0])==null?void 0:n.provider)||null;return{id:la.randomUUID(),name:z.basename(t),path:t,type:i?"git":"local",tags:[],importance:3,sizeBytes:s,createdAt:r.birthtime.toISOString(),lastModifiedAt:r.mtime.toISOString(),fileCount:a,provider:u,lastCommitHash:(o==null?void 0:o.lastCommitHash)||null,branch:(o==null?void 0:o.branch)||null,remotes:(o==null?void 0:o.remotes)||[],readmeFiles:c,language:l,scanStatus:"complete",lastScannedAt:new Date().toISOString()}}catch(r){return R.warn(`Failed to process candidate ${t}:`,r),null}}async getDirectorySize(t){var n;try{const r=await ft.glob("**/*",{cwd:t,onlyFiles:!0,deep:3,ignore:this.config.ignoredPatterns,stats:!0});let s=0;for(const i of r)if(s+=((n=i.stats)==null?void 0:n.size)||0,s>1e8)break;return s}catch{return 0}}async countFiles(t){try{return(await ft.glob("**/*",{cwd:t,onlyFiles:!0,deep:5,ignore:this.config.ignoredPatterns})).length}catch{return 0}}async findReadmeFiles(t){try{return await ft.glob("**/README*.{md,txt,rst}",{cwd:t,onlyFiles:!0,deep:2,caseSensitiveMatch:!1})}catch{return[]}}async detectLanguage(t){try{const n={typescript:["tsconfig.json","package.json"],javascript:["package.json","yarn.lock"],python:["requirements.txt","setup.py","pyproject.toml"],rust:["Cargo.toml"],go:["go.mod","go.sum"],java:["pom.xml","build.gradle"],ruby:["Gemfile"],php:["composer.json"],csharp:["*.csproj","*.sln"],swift:["Package.swift"]};for(const[r,s]of Object.entries(n))for(const i of s)if((await ft.glob(i,{cwd:t,deep:1,caseSensitiveMatch:!1})).length>0)return r;return}catch{return}}reportProgress(t,n,r){this.onProgress&&this.onProgress({discovered:t,processed:n,currentPath:r})}}function Ne(e){return Array.isArray?Array.isArray(e):Ml(e)==="[object Array]"}function K0(e){if(typeof e=="string")return e;let t=e+"";return t=="0"&&1/e==-1/0?"-0":t}function Y0(e){return e==null?"":K0(e)}function $e(e){return typeof e=="string"}function $l(e){return typeof e=="number"}function J0(e){return e===!0||e===!1||Q0(e)&&Ml(e)=="[object Boolean]"}function xl(e){return typeof e=="object"}function Q0(e){return xl(e)&&e!==null}function fe(e){return e!=null}function Tr(e){return!e.trim().length}function Ml(e){return e==null?e===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}const X0="Incorrect 'index' type",Z0=e=>`Invalid value for key ${e}`,ev=e=>`Pattern length exceeds max of ${e}.`,tv=e=>`Missing ${e} property in key`,nv=e=>`Property 'weight' in key '${e}' must be a positive integer`,ea=Object.prototype.hasOwnProperty;class rv{constructor(t){this._keys=[],this._keyMap={};let n=0;t.forEach(r=>{let s=Ll(r);this._keys.push(s),this._keyMap[s.id]=s,n+=s.weight}),this._keys.forEach(r=>{r.weight/=n})}get(t){return this._keyMap[t]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function Ll(e){let t=null,n=null,r=null,s=1,i=null;if($e(e)||Ne(e))r=e,t=ta(e),n=us(e);else{if(!ea.call(e,"name"))throw new Error(tv("name"));const o=e.name;if(r=o,ea.call(e,"weight")&&(s=e.weight,s<=0))throw new Error(nv(o));t=ta(o),n=us(o),i=e.getFn}return{path:t,id:n,weight:s,src:r,getFn:i}}function ta(e){return Ne(e)?e:e.split(".")}function us(e){return Ne(e)?e.join("."):e}function sv(e,t){let n=[],r=!1;const s=(i,o,a)=>{if(fe(i))if(!o[a])n.push(i);else{let c=o[a];const l=i[c];if(!fe(l))return;if(a===o.length-1&&($e(l)||$l(l)||J0(l)))n.push(Y0(l));else if(Ne(l)){r=!0;for(let u=0,f=l.length;u<f;u+=1)s(l[u],o,a+1)}else o.length&&s(l,o,a+1)}};return s(e,$e(t)?t.split("."):t,0),r?n:n[0]}const iv={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},ov={isCaseSensitive:!1,ignoreDiacritics:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1},av={location:0,threshold:.6,distance:100},cv={useExtendedSearch:!1,getFn:sv,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};var C={...ov,...iv,...av,...cv};const uv=/[^ ]+/g;function lv(e=1,t=3){const n=new Map,r=Math.pow(10,t);return{get(s){const i=s.match(uv).length;if(n.has(i))return n.get(i);const o=1/Math.pow(i,.5*e),a=parseFloat(Math.round(o*r)/r);return n.set(i,a),a},clear(){n.clear()}}}class $i{constructor({getFn:t=C.getFn,fieldNormWeight:n=C.fieldNormWeight}={}){this.norm=lv(n,3),this.getFn=t,this.isCreated=!1,this.setIndexRecords()}setSources(t=[]){this.docs=t}setIndexRecords(t=[]){this.records=t}setKeys(t=[]){this.keys=t,this._keysMap={},t.forEach((n,r)=>{this._keysMap[n.id]=r})}create(){this.isCreated||!this.docs.length||(this.isCreated=!0,$e(this.docs[0])?this.docs.forEach((t,n)=>{this._addString(t,n)}):this.docs.forEach((t,n)=>{this._addObject(t,n)}),this.norm.clear())}add(t){const n=this.size();$e(t)?this._addString(t,n):this._addObject(t,n)}removeAt(t){this.records.splice(t,1);for(let n=t,r=this.size();n<r;n+=1)this.records[n].i-=1}getValueForItemAtKeyId(t,n){return t[this._keysMap[n]]}size(){return this.records.length}_addString(t,n){if(!fe(t)||Tr(t))return;let r={v:t,i:n,n:this.norm.get(t)};this.records.push(r)}_addObject(t,n){let r={i:n,$:{}};this.keys.forEach((s,i)=>{let o=s.getFn?s.getFn(t):this.getFn(t,s.path);if(fe(o)){if(Ne(o)){let a=[];const c=[{nestedArrIndex:-1,value:o}];for(;c.length;){const{nestedArrIndex:l,value:u}=c.pop();if(fe(u))if($e(u)&&!Tr(u)){let f={v:u,i:l,n:this.norm.get(u)};a.push(f)}else Ne(u)&&u.forEach((f,d)=>{c.push({nestedArrIndex:d,value:f})})}r.$[i]=a}else if($e(o)&&!Tr(o)){let a={v:o,n:this.norm.get(o)};r.$[i]=a}}}),this.records.push(r)}toJSON(){return{keys:this.keys,records:this.records}}}function Fl(e,t,{getFn:n=C.getFn,fieldNormWeight:r=C.fieldNormWeight}={}){const s=new $i({getFn:n,fieldNormWeight:r});return s.setKeys(e.map(Ll)),s.setSources(t),s.create(),s}function fv(e,{getFn:t=C.getFn,fieldNormWeight:n=C.fieldNormWeight}={}){const{keys:r,records:s}=e,i=new $i({getFn:t,fieldNormWeight:n});return i.setKeys(r),i.setIndexRecords(s),i}function fn(e,{errors:t=0,currentLocation:n=0,expectedLocation:r=0,distance:s=C.distance,ignoreLocation:i=C.ignoreLocation}={}){const o=t/e.length;if(i)return o;const a=Math.abs(r-n);return s?o+a/s:a?1:o}function dv(e=[],t=C.minMatchCharLength){let n=[],r=-1,s=-1,i=0;for(let o=e.length;i<o;i+=1){let a=e[i];a&&r===-1?r=i:!a&&r!==-1&&(s=i-1,s-r+1>=t&&n.push([r,s]),r=-1)}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n}const Xe=32;function hv(e,t,n,{location:r=C.location,distance:s=C.distance,threshold:i=C.threshold,findAllMatches:o=C.findAllMatches,minMatchCharLength:a=C.minMatchCharLength,includeMatches:c=C.includeMatches,ignoreLocation:l=C.ignoreLocation}={}){if(t.length>Xe)throw new Error(ev(Xe));const u=t.length,f=e.length,d=Math.max(0,Math.min(r,f));let p=i,h=d;const g=a>1||c,w=g?Array(f):[];let _;for(;(_=e.indexOf(t,h))>-1;){let P=fn(t,{currentLocation:_,expectedLocation:d,distance:s,ignoreLocation:l});if(p=Math.min(P,p),h=_+u,g){let b=0;for(;b<u;)w[_+b]=1,b+=1}}h=-1;let I=[],$=1,F=u+f;const B=1<<u-1;for(let P=0;P<u;P+=1){let b=0,O=F;for(;b<O;)fn(t,{errors:P,currentLocation:d+O,expectedLocation:d,distance:s,ignoreLocation:l})<=p?b=O:F=O,O=Math.floor((F-b)/2+b);F=O;let k=Math.max(1,d-O+1),S=o?f:Math.min(d+O,f)+u,N=Array(S+2);N[S+1]=(1<<P)-1;for(let Q=S;Q>=k;Q-=1){let m=Q-1,y=n[e.charAt(m)];if(g&&(w[m]=+!!y),N[Q]=(N[Q+1]<<1|1)&y,P&&(N[Q]|=(I[Q+1]|I[Q])<<1|1|I[Q+1]),N[Q]&B&&($=fn(t,{errors:P,currentLocation:m,expectedLocation:d,distance:s,ignoreLocation:l}),$<=p)){if(p=$,h=m,h<=d)break;k=Math.max(1,2*d-h)}}if(fn(t,{errors:P+1,currentLocation:d,expectedLocation:d,distance:s,ignoreLocation:l})>p)break;I=N}const T={isMatch:h>=0,score:Math.max(.001,$)};if(g){const P=dv(w,a);P.length?c&&(T.indices=P):T.isMatch=!1}return T}function pv(e){let t={};for(let n=0,r=e.length;n<r;n+=1){const s=e.charAt(n);t[s]=(t[s]||0)|1<<r-n-1}return t}const Dn=String.prototype.normalize?e=>e.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g,""):e=>e;class jl{constructor(t,{location:n=C.location,threshold:r=C.threshold,distance:s=C.distance,includeMatches:i=C.includeMatches,findAllMatches:o=C.findAllMatches,minMatchCharLength:a=C.minMatchCharLength,isCaseSensitive:c=C.isCaseSensitive,ignoreDiacritics:l=C.ignoreDiacritics,ignoreLocation:u=C.ignoreLocation}={}){if(this.options={location:n,threshold:r,distance:s,includeMatches:i,findAllMatches:o,minMatchCharLength:a,isCaseSensitive:c,ignoreDiacritics:l,ignoreLocation:u},t=c?t:t.toLowerCase(),t=l?Dn(t):t,this.pattern=t,this.chunks=[],!this.pattern.length)return;const f=(p,h)=>{this.chunks.push({pattern:p,alphabet:pv(p),startIndex:h})},d=this.pattern.length;if(d>Xe){let p=0;const h=d%Xe,g=d-h;for(;p<g;)f(this.pattern.substr(p,Xe),p),p+=Xe;if(h){const w=d-Xe;f(this.pattern.substr(w),w)}}else f(this.pattern,0)}searchIn(t){const{isCaseSensitive:n,ignoreDiacritics:r,includeMatches:s}=this.options;if(t=n?t:t.toLowerCase(),t=r?Dn(t):t,this.pattern===t){let g={isMatch:!0,score:0};return s&&(g.indices=[[0,t.length-1]]),g}const{location:i,distance:o,threshold:a,findAllMatches:c,minMatchCharLength:l,ignoreLocation:u}=this.options;let f=[],d=0,p=!1;this.chunks.forEach(({pattern:g,alphabet:w,startIndex:_})=>{const{isMatch:I,score:$,indices:F}=hv(t,g,w,{location:i+_,distance:o,threshold:a,findAllMatches:c,minMatchCharLength:l,includeMatches:s,ignoreLocation:u});I&&(p=!0),d+=$,I&&F&&(f=[...f,...F])});let h={isMatch:p,score:p?d/this.chunks.length:1};return p&&s&&(h.indices=f),h}}class Ke{constructor(t){this.pattern=t}static isMultiMatch(t){return na(t,this.multiRegex)}static isSingleMatch(t){return na(t,this.singleRegex)}search(){}}function na(e,t){const n=e.match(t);return n?n[1]:null}class gv extends Ke{constructor(t){super(t)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(t){const n=t===this.pattern;return{isMatch:n,score:n?0:1,indices:[0,this.pattern.length-1]}}}class mv extends Ke{constructor(t){super(t)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(t){const r=t.indexOf(this.pattern)===-1;return{isMatch:r,score:r?0:1,indices:[0,t.length-1]}}}class yv extends Ke{constructor(t){super(t)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(t){const n=t.startsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,this.pattern.length-1]}}}class Sv extends Ke{constructor(t){super(t)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(t){const n=!t.startsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,t.length-1]}}}class bv extends Ke{constructor(t){super(t)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(t){const n=t.endsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[t.length-this.pattern.length,t.length-1]}}}class wv extends Ke{constructor(t){super(t)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(t){const n=!t.endsWith(this.pattern);return{isMatch:n,score:n?0:1,indices:[0,t.length-1]}}}class Nl extends Ke{constructor(t,{location:n=C.location,threshold:r=C.threshold,distance:s=C.distance,includeMatches:i=C.includeMatches,findAllMatches:o=C.findAllMatches,minMatchCharLength:a=C.minMatchCharLength,isCaseSensitive:c=C.isCaseSensitive,ignoreDiacritics:l=C.ignoreDiacritics,ignoreLocation:u=C.ignoreLocation}={}){super(t),this._bitapSearch=new jl(t,{location:n,threshold:r,distance:s,includeMatches:i,findAllMatches:o,minMatchCharLength:a,isCaseSensitive:c,ignoreDiacritics:l,ignoreLocation:u})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(t){return this._bitapSearch.searchIn(t)}}class Bl extends Ke{constructor(t){super(t)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(t){let n=0,r;const s=[],i=this.pattern.length;for(;(r=t.indexOf(this.pattern,n))>-1;)n=r+i,s.push([r,n-1]);const o=!!s.length;return{isMatch:o,score:o?0:1,indices:s}}}const ls=[gv,Bl,yv,Sv,wv,bv,mv,Nl],ra=ls.length,_v=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,Ev="|";function Av(e,t={}){return e.split(Ev).map(n=>{let r=n.trim().split(_v).filter(i=>i&&!!i.trim()),s=[];for(let i=0,o=r.length;i<o;i+=1){const a=r[i];let c=!1,l=-1;for(;!c&&++l<ra;){const u=ls[l];let f=u.isMultiMatch(a);f&&(s.push(new u(f,t)),c=!0)}if(!c)for(l=-1;++l<ra;){const u=ls[l];let f=u.isSingleMatch(a);if(f){s.push(new u(f,t));break}}}return s})}const vv=new Set([Nl.type,Bl.type]);class Rv{constructor(t,{isCaseSensitive:n=C.isCaseSensitive,ignoreDiacritics:r=C.ignoreDiacritics,includeMatches:s=C.includeMatches,minMatchCharLength:i=C.minMatchCharLength,ignoreLocation:o=C.ignoreLocation,findAllMatches:a=C.findAllMatches,location:c=C.location,threshold:l=C.threshold,distance:u=C.distance}={}){this.query=null,this.options={isCaseSensitive:n,ignoreDiacritics:r,includeMatches:s,minMatchCharLength:i,findAllMatches:a,ignoreLocation:o,location:c,threshold:l,distance:u},t=n?t:t.toLowerCase(),t=r?Dn(t):t,this.pattern=t,this.query=Av(this.pattern,this.options)}static condition(t,n){return n.useExtendedSearch}searchIn(t){const n=this.query;if(!n)return{isMatch:!1,score:1};const{includeMatches:r,isCaseSensitive:s,ignoreDiacritics:i}=this.options;t=s?t:t.toLowerCase(),t=i?Dn(t):t;let o=0,a=[],c=0;for(let l=0,u=n.length;l<u;l+=1){const f=n[l];a.length=0,o=0;for(let d=0,p=f.length;d<p;d+=1){const h=f[d],{isMatch:g,indices:w,score:_}=h.search(t);if(g){if(o+=1,c+=_,r){const I=h.constructor.type;vv.has(I)?a=[...a,...w]:a.push(w)}}else{c=0,o=0,a.length=0;break}}if(o){let d={isMatch:!0,score:c/o};return r&&(d.indices=a),d}}return{isMatch:!1,score:1}}}const fs=[];function Tv(...e){fs.push(...e)}function ds(e,t){for(let n=0,r=fs.length;n<r;n+=1){let s=fs[n];if(s.condition(e,t))return new s(e,t)}return new jl(e,t)}const Cn={AND:"$and",OR:"$or"},hs={PATH:"$path",PATTERN:"$val"},ps=e=>!!(e[Cn.AND]||e[Cn.OR]),Pv=e=>!!e[hs.PATH],Iv=e=>!Ne(e)&&xl(e)&&!ps(e),sa=e=>({[Cn.AND]:Object.keys(e).map(t=>({[t]:e[t]}))});function kl(e,t,{auto:n=!0}={}){const r=s=>{let i=Object.keys(s);const o=Pv(s);if(!o&&i.length>1&&!ps(s))return r(sa(s));if(Iv(s)){const c=o?s[hs.PATH]:i[0],l=o?s[hs.PATTERN]:s[c];if(!$e(l))throw new Error(Z0(c));const u={keyId:us(c),pattern:l};return n&&(u.searcher=ds(l,t)),u}let a={children:[],operator:i[0]};return i.forEach(c=>{const l=s[c];Ne(l)&&l.forEach(u=>{a.children.push(r(u))})}),a};return ps(e)||(e=sa(e)),r(e)}function Ov(e,{ignoreFieldNorm:t=C.ignoreFieldNorm}){e.forEach(n=>{let r=1;n.matches.forEach(({key:s,norm:i,score:o})=>{const a=s?s.weight:null;r*=Math.pow(o===0&&a?Number.EPSILON:o,(a||1)*(t?1:i))}),n.score=r})}function Dv(e,t){const n=e.matches;t.matches=[],fe(n)&&n.forEach(r=>{if(!fe(r.indices)||!r.indices.length)return;const{indices:s,value:i}=r;let o={indices:s,value:i};r.key&&(o.key=r.key.src),r.idx>-1&&(o.refIndex=r.idx),t.matches.push(o)})}function Cv(e,t){t.score=e.score}function $v(e,t,{includeMatches:n=C.includeMatches,includeScore:r=C.includeScore}={}){const s=[];return n&&s.push(Dv),r&&s.push(Cv),e.map(i=>{const{idx:o}=i,a={item:t[o],refIndex:o};return s.length&&s.forEach(c=>{c(i,a)}),a})}class Tt{constructor(t,n={},r){this.options={...C,...n},this.options.useExtendedSearch,this._keyStore=new rv(this.options.keys),this.setCollection(t,r)}setCollection(t,n){if(this._docs=t,n&&!(n instanceof $i))throw new Error(X0);this._myIndex=n||Fl(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(t){fe(t)&&(this._docs.push(t),this._myIndex.add(t))}remove(t=()=>!1){const n=[];for(let r=0,s=this._docs.length;r<s;r+=1){const i=this._docs[r];t(i,r)&&(this.removeAt(r),r-=1,s-=1,n.push(i))}return n}removeAt(t){this._docs.splice(t,1),this._myIndex.removeAt(t)}getIndex(){return this._myIndex}search(t,{limit:n=-1}={}){const{includeMatches:r,includeScore:s,shouldSort:i,sortFn:o,ignoreFieldNorm:a}=this.options;let c=$e(t)?$e(this._docs[0])?this._searchStringList(t):this._searchObjectList(t):this._searchLogical(t);return Ov(c,{ignoreFieldNorm:a}),i&&c.sort(o),$l(n)&&n>-1&&(c=c.slice(0,n)),$v(c,this._docs,{includeMatches:r,includeScore:s})}_searchStringList(t){const n=ds(t,this.options),{records:r}=this._myIndex,s=[];return r.forEach(({v:i,i:o,n:a})=>{if(!fe(i))return;const{isMatch:c,score:l,indices:u}=n.searchIn(i);c&&s.push({item:i,idx:o,matches:[{score:l,value:i,norm:a,indices:u}]})}),s}_searchLogical(t){const n=kl(t,this.options),r=(a,c,l)=>{if(!a.children){const{keyId:f,searcher:d}=a,p=this._findMatches({key:this._keyStore.get(f),value:this._myIndex.getValueForItemAtKeyId(c,f),searcher:d});return p&&p.length?[{idx:l,item:c,matches:p}]:[]}const u=[];for(let f=0,d=a.children.length;f<d;f+=1){const p=a.children[f],h=r(p,c,l);if(h.length)u.push(...h);else if(a.operator===Cn.AND)return[]}return u},s=this._myIndex.records,i={},o=[];return s.forEach(({$:a,i:c})=>{if(fe(a)){let l=r(n,a,c);l.length&&(i[c]||(i[c]={idx:c,item:a,matches:[]},o.push(i[c])),l.forEach(({matches:u})=>{i[c].matches.push(...u)}))}}),o}_searchObjectList(t){const n=ds(t,this.options),{keys:r,records:s}=this._myIndex,i=[];return s.forEach(({$:o,i:a})=>{if(!fe(o))return;let c=[];r.forEach((l,u)=>{c.push(...this._findMatches({key:l,value:o[u],searcher:n}))}),c.length&&i.push({idx:a,item:o,matches:c})}),i}_findMatches({key:t,value:n,searcher:r}){if(!fe(n))return[];let s=[];if(Ne(n))n.forEach(({v:i,i:o,n:a})=>{if(!fe(i))return;const{isMatch:c,score:l,indices:u}=r.searchIn(i);c&&s.push({score:l,key:t,value:i,idx:o,norm:a,indices:u})});else{const{v:i,n:o}=n,{isMatch:a,score:c,indices:l}=r.searchIn(i);a&&s.push({score:c,key:t,value:i,norm:o,indices:l})}return s}}Tt.version="7.1.0";Tt.createIndex=Fl;Tt.parseIndex=fv;Tt.config=C;Tt.parseQuery=kl;Tv(Rv);class xv{constructor(){this.fuse=null,this.projects=[],this.fuseOptions={keys:[{name:"name",weight:.4},{name:"path",weight:.3},{name:"description",weight:.2},{name:"tags",weight:.1}],threshold:.4,includeScore:!0,includeMatches:!0,minMatchCharLength:2}}buildIndex(t){const n=Date.now();this.projects=t,this.fuse=new Tt(t,this.fuseOptions);const r=Date.now()-n;R.info(`Search index built for ${t.length} projects in ${r}ms`)}addProject(t){if(!this.fuse){this.buildIndex([t]);return}this.projects.push(t),this.buildIndex(this.projects)}updateProject(t){const n=this.projects.findIndex(r=>r.id===t.id);n>=0?(this.projects[n]=t,this.buildIndex(this.projects)):this.addProject(t)}removeProject(t){this.projects=this.projects.filter(n=>n.id!==t),this.projects.length>0?this.buildIndex(this.projects):this.fuse=null}search(t,n=50){return!this.fuse||!t||t.trim().length===0?this.projects.slice(0,n):this.fuse.search(t,{limit:n}).map(s=>s.item)}getAll(t){let n=[...this.projects];if(t!=null&&t.filters){const{type:a,provider:c,tags:l,importance:u}=t.filters;a&&(n=n.filter(f=>f.type===a)),c&&(n=n.filter(f=>f.provider===c)),l&&l.length>0&&(n=n.filter(f=>l.some(d=>f.tags.includes(d)))),u!==void 0&&(n=n.filter(f=>f.importance===u))}if(t!=null&&t.sort){const{by:a,order:c}=t.sort;n.sort((l,u)=>{let f=l[a],d=u[a];if(f==null&&d==null)return 0;if(f==null)return c==="asc"?1:-1;if(d==null)return c==="asc"?-1:1;if(typeof f=="string"){const p=f.localeCompare(d);return c==="asc"?p:-p}return c==="asc"?f-d:d-f})}const r=(t==null?void 0:t.page)||1,s=(t==null?void 0:t.pageSize)||50,i=(r-1)*s;return{projects:n.slice(i,i+s),total:n.length}}getStats(){return{projectCount:this.projects.length,indexSize:this.fuse?JSON.stringify(this.fuse.getIndex()).length:0}}}let Pr=null;function $n(){return Pr||(Pr=new xv),Pr}class Mv{constructor(){this.currentJob=null,this.scanner=null,this.progressCallbacks=new Set}async startScan(t){this.currentJob&&this.currentJob.status==="running"&&this.cancelScan(this.currentJob.id);const n=la.randomUUID();return R.info(`Starting scan job ${n}`),this.currentJob={id:n,status:"running",progress:{discovered:0,processed:0,currentPath:""},startedAt:Date.now()},this.scanner=new z0(t),this.scanner.setProgressCallback(r=>{this.currentJob&&this.currentJob.id===n&&(this.currentJob.progress=r,this.notifyProgress(n,r))}),this.runScan(n,this.scanner).catch(r=>{R.error(`Scan job ${n} failed:`,r)}),n}async runScan(t,n){try{const r=await n.scan();if(!this.currentJob||this.currentJob.id!==t)return;const s=$t();for(const a of r.projects)await s.upsertProject(a);await s.flush();const i=await s.getAllProjects();$n().buildIndex(i),this.currentJob.status="complete",this.currentJob.result=r,this.currentJob.completedAt=Date.now(),R.info(`Scan job ${t} completed: ${r.projects.length} projects found`)}catch(r){if(!this.currentJob||this.currentJob.id!==t)return;this.currentJob.status="error",this.currentJob.error=r.message,this.currentJob.completedAt=Date.now(),R.error(`Scan job ${t} error:`,r)}}cancelScan(t){return!this.currentJob||this.currentJob.id!==t||this.currentJob.status!=="running"?!1:(this.scanner&&this.scanner.cancel(),this.currentJob.status="cancelled",this.currentJob.completedAt=Date.now(),R.info(`Scan job ${t} cancelled`),!0)}getJobStatus(t){return this.currentJob&&this.currentJob.id===t?{...this.currentJob}:null}onProgress(t){return this.progressCallbacks.add(t),()=>{this.progressCallbacks.delete(t)}}notifyProgress(t,n){for(const r of this.progressCallbacks)try{r(t,n)}catch(s){R.error("Progress callback error:",s)}}}let Ir=null;function Or(){return Ir||(Ir=new Mv),Ir}function Lv(){const e=$t();function t(n,r,s,i=""){return{success:n,data:r,error:s,requestId:i}}x.ipcMain.handle("project:touchAll",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const i=(r==null?void 0:r.timestamp)||new Date().toISOString(),o=await e.getAllProjects();let a=0;for(const l of o)try{await e.updateProject(l.id,{lastModifiedAt:i}),a++}catch(u){R.warn(`Failed to touch project ${l.id}:`,(u==null?void 0:u.message)||u)}const c=x.BrowserWindow.getAllWindows();for(const l of c)l.webContents.send("projects:touched",{timestamp:i,touched:a});return t(!0,{touched:a},void 0,s)}catch(i){return R.error("Error touching all projects:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("project:refreshModifiedFromFS",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const i=await e.getAllProjects();let o=0;for(const c of i)if(c.path)try{let l=null;try{const f=await ft.glob("**/*",{cwd:c.path,onlyFiles:!0,deep:6,ignore:["**/node_modules/**","**/.git/**","**/dist/**"],stats:!0});for(const d of f){const p=d.stats;if(p&&p.mtime){const h=new Date(p.mtime);(!l||h.getTime()>l.getTime())&&(l=h)}}}catch{l=null}l||(l=(await Fe.stat(c.path)).mtime);const u=l.toISOString();c.lastModifiedAt!==u&&(await e.updateProject(c.id,{lastModifiedAt:u}),o++)}catch(l){R.warn(`Failed to stat/update project ${c.id} (${c.path}):`,(l==null?void 0:l.message)||l)}const a=x.BrowserWindow.getAllWindows();for(const c of a)c.webContents.send("projects:refreshed",{refreshed:o});return t(!0,{refreshed:o},void 0,s)}catch(i){return R.error("Error refreshing projects from FS:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("project:list",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const i=$n(),{query:o,filters:a,sort:c,page:l,pageSize:u}=r||{};let f;typeof c=="string"&&c.length>0?c.startsWith("-")?f={by:c.substring(1),order:"desc"}:f={by:c,order:"asc"}:c&&typeof c=="object"&&(c.by||c.order)&&(f={by:c.by,order:c.order||"asc"});let d;if(o&&o.trim().length>0){let p=i.search(o,u||50);f&&f.by&&(p=p.slice(),p.sort((h,g)=>{let w=h[f.by],_=g[f.by];if(w==null&&_==null)return 0;if(w==null)return f.order==="asc"?1:-1;if(_==null)return f.order==="asc"?-1:1;if(typeof w=="string"){const I=w.localeCompare(_);return f.order==="asc"?I:-I}return f.order==="asc"?w-_:_-w})),d={projects:p,total:p.length,page:1}}else d={...i.getAll({filters:a,sort:f,page:l,pageSize:u}),page:l||1};return t(!0,d,void 0,s)}catch(i){return R.error("Error listing projects:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message||"Failed to list projects"},s)}}),x.ipcMain.handle("project:get",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{id:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID is required"},s);const o=await e.getProject(i);return o?t(!0,{project:o},void 0,s):t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s)}catch(i){return R.error("Error getting project:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("project:update",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{id:i,updates:o}=r;if(!i||!o)return t(!1,void 0,{code:"INVALID_INPUT",message:"ID and updates are required"},s);const a=await e.updateProject(i,o);return a?(n.sender.send("project:updated",{projectId:i,changes:o}),t(!0,{project:a},void 0,s)):t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s)}catch(i){return R.error("Error updating project:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("project:delete",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{id:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID is required"},s);const o=await e.deleteProject(i);return o&&n.sender.send("project:deleted",{projectId:i}),t(!0,{deleted:o},void 0,s)}catch(i){return R.error("Error deleting project:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("scan:start",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{paths:i}=r;if(!i||!Array.isArray(i)||i.length===0)return t(!1,void 0,{code:"INVALID_INPUT",message:"Scan paths are required"},s);const o=Or(),a=await o.startScan({paths:i,ignoredPatterns:["**/node_modules/**","**/.git/**","**/dist/**","**/build/**","**/.next/**","**/target/**","**/.venv/**","**/__pycache__/**"],maxDepth:5,minSizeBytes:0});return o.onProgress((c,l)=>{const u=x.BrowserWindow.getAllWindows();for(const f of u)f.webContents.send("scan:progress",{jobId:c,discovered:l.discovered,processed:l.processed})}),t(!0,{jobId:a},void 0,s)}catch(i){return R.error("Error starting scan:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("scan:status",async(n,r)=>{var i;const s=(r==null?void 0:r.requestId)||"";try{const{jobId:o}=r;if(!o)return t(!1,void 0,{code:"INVALID_INPUT",message:"Job ID is required"},s);const c=Or().getJobStatus(o);if(!c)return t(!1,void 0,{code:"NOT_FOUND",message:`Scan job ${o} not found`},s);const l=c.status==="running"?c.progress.discovered>0?c.progress.processed/c.progress.discovered*100:0:100;return t(!0,{progress:l,status:c.status,errors:((i=c.result)==null?void 0:i.errors)||[]},void 0,s)}catch(o){return R.error("Error getting scan status:",o),t(!1,void 0,{code:"INTERNAL_ERROR",message:o.message},s)}}),x.ipcMain.handle("scan:cancel",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{jobId:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Job ID is required"},s);const a=Or().cancelScan(i);return t(!0,{cancelled:a},void 0,s)}catch(i){return R.error("Error cancelling scan:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("file:tree",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i,maxDepth:o=3}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID is required"},s);const a=await e.getProject(i);if(!a)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const c=await Ul(a.path,o);return t(!0,{tree:c},void 0,s)}catch(i){return R.error("Error getting file tree:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("readme:list",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID is required"},s);const o=await e.getProject(i);if(!o)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const a=o.readmeFiles||[];return t(!0,{readmeFiles:a},void 0,s)}catch(i){return R.error("Error listing README files:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("readme:fetch",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i,filePath:o}=r;if(!i||!o)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID and file path are required"},s);const a=await e.getProject(i);if(!a)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const c=ke.join(a.path,o),l=ke.normalize(a.path);if(!ke.normalize(c).startsWith(l))return t(!1,void 0,{code:"INVALID_INPUT",message:"File path must be within project directory"},s);const f=await Fe.readFile(c,"utf-8");return t(!0,{content:f,filePath:o},void 0,s)}catch(i){return R.error("Error fetching README:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("git:list-branches",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID is required"},s);const o=await e.getProject(i);if(!o)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const{exec:a}=require("child_process"),{promisify:c}=require("util"),l=c(a),u=`git -C "${o.path}" for-each-ref --format="%(refname:short)" refs/heads`,{stdout:f}=await l(u),d=f.split(/\r?\n/).map(p=>p.trim()).filter(Boolean);return t(!0,{branches:d},void 0,s)}catch(i){return R.error("Error listing git branches:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("git:list-commits",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i,limit:o=20}=r||{};if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID is required"},s);const a=await e.getProject(i);if(!a)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const{exec:c}=require("child_process"),{promisify:l}=require("util"),u=l(c),d=`git -C "${a.path}" log -n ${Number(o)} --pretty=format:"%H|||%an|||%ae|||%ad|||%s" --date=iso`,{stdout:p}=await u(d),g=p.split(/\r?\n/).filter(Boolean).map(w=>{const _=w.split("|||");return{hash:_[0]||"",authorName:_[1]||"",authorEmail:_[2]||"",date:_[3]||"",message:_[4]||""}});return t(!0,{commits:g},void 0,s)}catch(i){return R.error("Error listing recent commits:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("git:checkout",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i,branch:o}=r;if(!i||!o)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID and branch are required"},s);const a=await e.getProject(i);if(!a)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const{exec:c}=require("child_process"),{promisify:l}=require("util"),u=l(c),f=`git -C "${a.path}" status --porcelain`,{stdout:d}=await u(f);if(d&&d.trim().length>0&&!(r!=null&&r.force))return t(!1,void 0,{code:"UNCOMMITTED_CHANGES",message:"There are uncommitted changes",details:d},s);const p=`git -C "${a.path}" checkout "${o}"`;await u(p);const h=await e.updateProject(i,{branch:o}),g=x.BrowserWindow.getAllWindows();for(const w of g)w.webContents.send("project:updated",{projectId:i,changes:{branch:o}});return t(!0,{branch:o,project:h},void 0,s)}catch(i){return R.error("Error checking out branch:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("markdown:list",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID is required"},s);const o=await e.getProject(i);if(!o)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const c=(await Fe.readdir(o.path)).filter(l=>l.match(/\.md$/i));return t(!0,{mdFiles:c},void 0,s)}catch(i){return R.error("Error listing Markdown files:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("markdown:fetch",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectId:i,filePath:o}=r;if(!i||!o)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project ID and file path are required"},s);const a=await e.getProject(i);if(!a)return t(!1,void 0,{code:"NOT_FOUND",message:`Project ${i} not found`},s);const c=ke.join(a.path,o),l=ke.normalize(a.path);if(!ke.normalize(c).startsWith(l))return t(!1,void 0,{code:"INVALID_INPUT",message:"File path must be within project directory"},s);const f=await Fe.readFile(c,"utf-8");return t(!0,{content:f,filePath:o},void 0,s)}catch(i){return R.error("Error fetching Markdown:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("dialog:select-folder",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{dialog:i}=require("electron"),o=x.BrowserWindow.getFocusedWindow(),a=r==null?void 0:r.defaultPath,c=await i.showOpenDialog(o,{title:"Select Folder",properties:["openDirectory","createDirectory"],defaultPath:a||void 0});return c.canceled||!c.filePaths||c.filePaths.length===0?t(!1,void 0,{code:"CANCELLED",message:"No folder selected"},s):t(!0,{path:c.filePaths[0]},void 0,s)}catch(i){return R.error("Error showing folder dialog:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:i.message},s)}}),x.ipcMain.handle("action:open-ide",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectPath:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project path is required"},s);let c=(await $t().getSettings()).ideCommand;(!c||typeof c!="string"||!c.includes("{path}"))&&(process.platform==="darwin"?c='open -a "Visual Studio Code" "{path}"':(process.platform,c='code "{path}"')),c=c.replace("{path}",i);const{exec:l}=require("child_process"),{promisify:u}=require("util");return await u(l)(c),t(!0,{opened:!0},void 0,s)}catch(i){return R.error("Error opening IDE:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:`Failed to open IDE: ${i.message}`},s)}}),x.ipcMain.handle("action:open-terminal",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{projectPath:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Project path is required"},s);let c=(await $t().getSettings()).terminalCommand;if(!c||typeof c!="string"||!c.includes("{path}"))if(process.platform==="darwin")c='open -a Terminal "{path}"';else if(process.platform==="win32")c='start cmd /K cd "{path}"';else{const d=["gnome-terminal","konsole","xfce4-terminal","x-terminal-emulator","xterm"],{execSync:p}=require("child_process");let h="";for(const g of d)try{p(`command -v ${g}`),h=g;break}catch{}h?c=`${h} --working-directory="{path}" &`:c="xterm &"}c=c.replace("{path}",i);const{exec:l}=require("child_process"),{promisify:u}=require("util");return await u(l)(c),t(!0,{opened:!0},void 0,s)}catch(i){return R.error("Error opening terminal:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:`Failed to open terminal: ${i.message}`},s)}}),x.ipcMain.handle("action:open-remote",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{remoteUrl:i}=r;if(!i)return t(!1,void 0,{code:"INVALID_INPUT",message:"Remote URL is required"},s);const{shell:o}=require("electron");let a=(i||"").trim();const c=a.match(/^git@([^:]+):(.+?)(?:\.git)?$/);if(c){const u=c[1],f=c[2].replace(/\.git$/,"");a=`https://${u}/${f}`}const l=a.match(/^(?:git\+ssh:\/\/|ssh:\/\/)?(?:git@)?([^\/]+)\/(.+?)(?:\.git)?$/);if(l&&!a.startsWith("http")){const u=l[1],f=l[2].replace(/\.git$/,"");a=`https://${u}/${f}`}return a.startsWith("git://")&&(a=a.replace(/^git:\/\//,"https://").replace(/\.git$/,"")),a.startsWith("http")&&a.endsWith(".git")&&(a=a.replace(/\.git$/,"")),await o.openExternal(a),t(!0,{opened:!0},void 0,s)}catch(i){return R.error("Error opening remote:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:`Failed to open remote: ${i.message}`},s)}}),x.ipcMain.handle("project:export",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const i=await e.export(),{dialog:o}=require("electron"),a=x.BrowserWindow.getFocusedWindow(),c=await o.showSaveDialog(a,{title:"Export Projects",defaultPath:"projects.json",filters:[{name:"JSON",extensions:["json"]}]});return c.canceled||!c.filePath?t(!1,void 0,{code:"CANCELLED",message:"Export cancelled"},s):(await Fe.writeFile(c.filePath,JSON.stringify(i,null,2),"utf-8"),t(!0,{path:c.filePath},void 0,s))}catch(i){return R.error("Error exporting projects:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:`Failed to export projects: ${i.message}`},s)}}),x.ipcMain.handle("project:import",async(n,r)=>{const s=(r==null?void 0:r.requestId)||"";try{const{dialog:i}=require("electron"),o=x.BrowserWindow.getFocusedWindow(),a=await i.showOpenDialog(o,{title:"Import Projects",properties:["openFile"],filters:[{name:"JSON",extensions:["json"]}]});if(a.canceled||!a.filePaths||a.filePaths.length===0)return t(!1,void 0,{code:"CANCELLED",message:"Import cancelled"},s);const c=a.filePaths[0],l=await Fe.readFile(c,"utf-8"),u=JSON.parse(l),f=(r==null?void 0:r.mode)==="merge"?"merge":"replace",d=(r==null?void 0:r.onConflict)==="skip"?"skip":"overwrite";if(f==="replace")await e.import(u);else{const g=Array.isArray(u.projects)?u.projects:[];for(const w of g){if(!(w!=null&&w.id))continue;await e.getProject(w.id)?d==="overwrite"&&await e.upsertProject(w):await e.upsertProject(w)}}const p=$n(),h=await e.getAllProjects();return p.buildIndex(h),n.sender.send("projects:imported",{imported:!0,count:h.length,mode:f,onConflict:d}),t(!0,{imported:!0,count:h.length,mode:f,onConflict:d},void 0,s)}catch(i){return R.error("Error importing projects:",i),t(!1,void 0,{code:"INTERNAL_ERROR",message:`Failed to import projects: ${i.message}`},s)}}),x.ipcMain.handle("project:preview-import",async n=>{const r="";try{const{dialog:s}=require("electron"),i=x.BrowserWindow.getFocusedWindow(),o=await s.showOpenDialog(i,{title:"Preview Import Projects",properties:["openFile"],filters:[{name:"JSON",extensions:["json"]}]});if(o.canceled||!o.filePaths||o.filePaths.length===0)return t(!1,void 0,{code:"CANCELLED",message:"Preview cancelled"},r);const a=o.filePaths[0],c=await Fe.readFile(a,"utf-8"),l=JSON.parse(c||"{}"),u=Array.isArray(l.projects)?l.projects:[],f=u.slice(0,10).map(d=>({id:d.id,name:d.name,path:d.path,provider:d.provider}));return t(!0,{filePath:a,count:u.length,sample:f},void 0,r)}catch(s){return R.error("Error previewing import:",s),t(!1,void 0,{code:"INTERNAL_ERROR",message:s.message},r)}}),x.ipcMain.handle("settings:get",async n=>{try{const r=await e.getSettings();return t(!0,{settings:r})}catch(r){return R.error("Error getting settings:",r),t(!1,void 0,{code:"INTERNAL_ERROR",message:r.message})}}),x.ipcMain.handle("settings:set",async(n,r)=>{try{const{settings:s}=r;return s?(await e.setSettings(s),t(!0,{saved:!0})):t(!1,void 0,{code:"INVALID_INPUT",message:"Settings required"})}catch(s){return R.error("Error saving settings:",s),t(!1,void 0,{code:"INTERNAL_ERROR",message:s.message})}}),x.ipcMain.handle("cache:clear",async n=>{try{await e.clear();const r=x.BrowserWindow.getAllWindows();for(const s of r)s.webContents.send("cache:cleared",{cleared:!0});return t(!0,{cleared:!0})}catch(r){return R.error("Error clearing cache:",r),t(!1,void 0,{code:"INTERNAL_ERROR",message:r.message})}}),R.info("IPC handlers registered")}async function Ul(e,t,n=0){const r=await Fe.stat(e),i={name:ke.basename(e),path:e,type:r.isDirectory()?"directory":"file",size:r.size,children:[]};if(!r.isDirectory()||n>=t)return i;try{const o=await Fe.readdir(e,{withFileTypes:!0}),a=new Set(["node_modules",".git","dist","build",".next","target",".venv","__pycache__",".cache","coverage",".idea",".vscode"]),c=o.filter(u=>!(u.name.startsWith(".")&&u.name!==".github"||u.isDirectory()&&a.has(u.name)));c.sort((u,f)=>u.isDirectory()&&!f.isDirectory()?-1:!u.isDirectory()&&f.isDirectory()?1:u.name.localeCompare(f.name));const l=c.map(async u=>{const f=ke.join(e,u.name);return Ul(f,t,n+1)});i.children=await Promise.all(l)}catch(o){R.error(`Error reading directory ${e}:`,o)}return i}const ia=se.dirname(gs.fileURLToPath(typeof document>"u"?require("url").pathToFileURL(__filename).href:ir&&ir.tagName.toUpperCase()==="SCRIPT"&&ir.src||new URL("main.js",document.baseURI).href));R.transports.file.level="info";R.info("Application starting...");let De=null;const Fv=process.env.NODE_ENV==="development"||!x.app.isPackaged,jv=x.app.requestSingleInstanceLock();jv?x.app.on("second-instance",()=>{De&&(De.isMinimized()&&De.restore(),De.focus())}):x.app.quit();function oa(){if(De=new x.BrowserWindow({width:1280,height:800,minWidth:1024,minHeight:600,title:"Desktop Project Explorer",webPreferences:{preload:se.join(ia,"preload.js"),contextIsolation:!0,nodeIntegration:!1,sandbox:!0}}),Fv){const e=process.env.VITE_DEV_SERVER_PORT||"5173";De.loadURL(`http://localhost:${e}`),De.webContents.openDevTools()}else De.loadFile(se.join(ia,"../dist/index.html"));De.on("closed",()=>{De=null}),R.info("Main window created")}async function Nv(){try{const e=$t();await e.initialize(),R.info("Store initialized successfully");const t=await e.getAllProjects();$n().buildIndex(t),R.info(`Search index built with ${t.length} projects`),Lv()}catch(e){throw R.error("Failed to initialize app:",e),e}}x.app.whenReady().then(async()=>{await Nv(),oa(),x.app.on("activate",()=>{x.BrowserWindow.getAllWindows().length===0&&oa()})});x.app.on("window-all-closed",()=>{process.platform!=="darwin"&&x.app.quit()});process.on("uncaughtException",e=>{R.error("Uncaught exception:",e)});process.on("unhandledRejection",e=>{R.error("Unhandled rejection:",e)});
